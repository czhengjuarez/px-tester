import {
  generateId
} from "./chunk-ZRSJIC2B.js";
import {
  FloatingPortalLite
} from "./chunk-Y7GOPZIF.js";
import {
  inertValue
} from "./chunk-HC2V6TPM.js";
import {
  useButton
} from "./chunk-PODRTBZK.js";
import {
  FocusGuard,
  transitionStatusMapping,
  useOpenChangeComplete
} from "./chunk-UAJXLITD.js";
import {
  visuallyHidden
} from "./chunk-JLMIKHN4.js";
import {
  Timeout
} from "./chunk-ZDUACO7A.js";
import {
  ownerDocument
} from "./chunk-3FELFY6H.js";
import {
  activeElement,
  contains,
  getTarget,
  matchesFocusVisible
} from "./chunk-CSZZYMWP.js";
import {
  getWindow,
  useEventCallback
} from "./chunk-5VFA47B3.js";
import {
  useLatestRef
} from "./chunk-E6E6BQH7.js";
import {
  useId,
  useIsoLayoutEffect,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __export,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Action: () => ToastAction,
  Close: () => ToastClose,
  Content: () => ToastContent,
  Description: () => ToastDescription,
  Portal: () => ToastPortal,
  Provider: () => ToastProvider,
  Root: () => ToastRoot,
  Title: () => ToastTitle,
  Viewport: () => ToastViewport,
  createToastManager: () => createToastManager,
  useToastManager: () => useToastManager
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/provider/ToastProvider.js
var React2 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/provider/ToastProviderContext.js
var React = __toESM(require_react(), 1);
var ToastContext = React.createContext(void 0);
if (true) ToastContext.displayName = "ToastContext";
function useToastContext() {
  const context = React.useContext(ToastContext);
  if (!context) {
    throw new Error("Base UI: useToast must be used within <Toast.Provider>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/utils/resolvePromiseOptions.js
function resolvePromiseOptions(options, result) {
  if (typeof options === "string") {
    return {
      description: options
    };
  }
  if (typeof options === "function") {
    const resolvedOptions = options(result);
    return typeof resolvedOptions === "string" ? {
      description: resolvedOptions
    } : resolvedOptions;
  }
  return options;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/provider/ToastProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ToastProvider = function ToastProvider2(props) {
  const {
    children,
    timeout = 5e3,
    limit = 3,
    toastManager
  } = props;
  const [toasts, setToasts] = React2.useState([]);
  const [hovering, setHovering] = React2.useState(false);
  const [focused, setFocused] = React2.useState(false);
  const [prevFocusElement, setPrevFocusElement] = React2.useState(null);
  if (toasts.length === 0) {
    if (hovering) {
      setHovering(false);
    }
    if (focused) {
      setFocused(false);
    }
  }
  const expanded = hovering || focused;
  const timersRef = React2.useRef(/* @__PURE__ */ new Map());
  const viewportRef = React2.useRef(null);
  const windowFocusedRef = React2.useRef(true);
  const isPausedRef = React2.useRef(false);
  const hoveringRef = useLatestRef(hovering);
  const focusedRef = useLatestRef(focused);
  const handleFocusManagement = useEventCallback((toastId) => {
    var _a, _b;
    const activeEl = activeElement(ownerDocument(viewportRef.current));
    if (!viewportRef.current || !contains(viewportRef.current, activeEl) || !matchesFocusVisible(activeEl)) {
      return;
    }
    const currentIndex = toasts.findIndex((toast) => toast.id === toastId);
    let nextToast = null;
    let index = currentIndex + 1;
    while (index < toasts.length) {
      if (toasts[index].transitionStatus !== "ending") {
        nextToast = toasts[index];
        break;
      }
      index += 1;
    }
    if (!nextToast) {
      index = currentIndex - 1;
      while (index >= 0) {
        if (toasts[index].transitionStatus !== "ending") {
          nextToast = toasts[index];
          break;
        }
        index -= 1;
      }
    }
    if (nextToast) {
      (_b = (_a = nextToast.ref) == null ? void 0 : _a.current) == null ? void 0 : _b.focus();
    } else {
      prevFocusElement == null ? void 0 : prevFocusElement.focus({
        preventScroll: true
      });
    }
  });
  const pauseTimers = useEventCallback(() => {
    if (isPausedRef.current) {
      return;
    }
    isPausedRef.current = true;
    timersRef.current.forEach((timer) => {
      if (timer.timeout) {
        timer.timeout.clear();
        const elapsed = Date.now() - timer.start;
        const remaining = timer.delay - elapsed;
        timer.remaining = remaining > 0 ? remaining : 0;
      }
    });
  });
  const resumeTimers = useEventCallback(() => {
    if (!isPausedRef.current) {
      return;
    }
    isPausedRef.current = false;
    timersRef.current.forEach((timer, id) => {
      timer.remaining = timer.remaining > 0 ? timer.remaining : timer.delay;
      timer.timeout ?? (timer.timeout = Timeout.create());
      timer.timeout.start(timer.remaining, () => {
        timersRef.current.delete(id);
        timer.callback();
      });
      timer.start = Date.now();
    });
  });
  const close = useEventCallback((toastId) => {
    var _a;
    setToasts((prevToasts) => {
      const toastsWithEnding = prevToasts.map((toast2) => toast2.id === toastId ? {
        ...toast2,
        transitionStatus: "ending",
        height: 0
      } : toast2);
      const activeToasts = toastsWithEnding.filter((t) => t.transitionStatus !== "ending");
      return toastsWithEnding.map((toast2) => {
        if (toast2.transitionStatus === "ending") {
          return toast2;
        }
        const isActiveToastLimited = activeToasts.indexOf(toast2) >= limit;
        return {
          ...toast2,
          limited: isActiveToastLimited
        };
      });
    });
    const timer = timersRef.current.get(toastId);
    if (timer && timer.timeout) {
      timer.timeout.clear();
      timersRef.current.delete(toastId);
    }
    const toast = toasts.find((t) => t.id === toastId);
    (_a = toast == null ? void 0 : toast.onClose) == null ? void 0 : _a.call(toast);
    handleFocusManagement(toastId);
    if (toasts.length === 1) {
      hoveringRef.current = false;
      focusedRef.current = false;
    }
  });
  const remove = useEventCallback((toastId) => {
    var _a;
    setToasts((prev) => prev.filter((toast2) => toast2.id !== toastId));
    const toast = toasts.find((t) => t.id === toastId);
    (_a = toast == null ? void 0 : toast.onRemove) == null ? void 0 : _a.call(toast);
  });
  const scheduleTimer = useEventCallback((id, delay, callback) => {
    const start = Date.now();
    const shouldStartActive = windowFocusedRef.current && !hoveringRef.current && !focusedRef.current;
    const currentTimeout = shouldStartActive ? Timeout.create() : void 0;
    currentTimeout == null ? void 0 : currentTimeout.start(delay, () => {
      timersRef.current.delete(id);
      callback();
    });
    timersRef.current.set(id, {
      timeout: currentTimeout,
      start: shouldStartActive ? start : 0,
      delay,
      remaining: delay,
      callback
    });
  });
  const add = useEventCallback((toast) => {
    const id = toast.id || generateId("toast");
    const toastToAdd = {
      ...toast,
      id,
      transitionStatus: "starting"
    };
    setToasts((prev) => {
      const updatedToasts = [toastToAdd, ...prev];
      const activeToasts = updatedToasts.filter((t) => t.transitionStatus !== "ending");
      if (activeToasts.length > limit) {
        const excessCount = activeToasts.length - limit;
        const oldestActiveToasts = activeToasts.slice(-excessCount);
        return updatedToasts.map((t) => oldestActiveToasts.some((old) => old.id === t.id) ? {
          ...t,
          limited: true
        } : {
          ...t,
          limited: false
        });
      }
      return updatedToasts.map((t) => ({
        ...t,
        limited: false
      }));
    });
    const duration = toastToAdd.timeout ?? timeout;
    if (toastToAdd.type !== "loading" && duration > 0) {
      scheduleTimer(id, duration, () => close(id));
    }
    if (hoveringRef.current || focusedRef.current || !windowFocusedRef.current) {
      pauseTimers();
    }
    return id;
  });
  const update = useEventCallback((id, updates) => {
    setToasts((prev) => prev.map((toast) => toast.id === id ? {
      ...toast,
      ...updates
    } : toast));
  });
  const promise = useEventCallback((promiseValue, options) => {
    const loadingOptions = resolvePromiseOptions(options.loading);
    const id = add({
      ...loadingOptions,
      type: "loading"
    });
    const handledPromise = promiseValue.then((result) => {
      const successOptions = resolvePromiseOptions(options.success, result);
      update(id, {
        ...successOptions,
        type: "success"
      });
      const successTimeout = successOptions.timeout ?? timeout;
      if (successTimeout > 0) {
        scheduleTimer(id, successTimeout, () => close(id));
      }
      if (hoveringRef.current || focusedRef.current || !windowFocusedRef.current) {
        pauseTimers();
      }
      return result;
    }).catch((error) => {
      const errorOptions = resolvePromiseOptions(options.error, error);
      update(id, {
        ...errorOptions,
        type: "error"
      });
      const errorTimeout = errorOptions.timeout ?? timeout;
      if (errorTimeout > 0) {
        scheduleTimer(id, errorTimeout, () => close(id));
      }
      if (hoveringRef.current || focusedRef.current || !windowFocusedRef.current) {
        pauseTimers();
      }
      return Promise.reject(error);
    });
    if ({}.hasOwnProperty.call(options, "setPromise")) {
      options.setPromise(handledPromise);
    }
    return handledPromise;
  });
  React2.useEffect(function subscribeToToastManager() {
    if (!toastManager) {
      return void 0;
    }
    const unsubscribe = toastManager[" subscribe"](({
      action,
      options
    }) => {
      const id = options.id;
      if (action === "promise" && options.promise) {
        promise(options.promise, options);
      } else if (action === "update" && id) {
        update(id, options);
      } else if (action === "close" && id) {
        close(id);
      } else {
        add(options);
      }
    });
    return unsubscribe;
  }, [add, update, scheduleTimer, timeout, toastManager, promise, close]);
  const contextValue = React2.useMemo(() => ({
    toasts,
    setToasts,
    hovering,
    setHovering,
    focused,
    setFocused,
    expanded,
    add,
    close,
    remove,
    update,
    promise,
    pauseTimers,
    resumeTimers,
    prevFocusElement,
    setPrevFocusElement,
    viewportRef,
    scheduleTimer,
    windowFocusedRef
  }), [add, close, focused, hovering, expanded, pauseTimers, prevFocusElement, promise, remove, resumeTimers, scheduleTimer, toasts, update]);
  return (0, import_jsx_runtime.jsx)(ToastContext.Provider, {
    value: contextValue,
    children
  });
};
if (true) ToastProvider.displayName = "ToastProvider";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/viewport/ToastViewport.js
var React4 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/viewport/ToastViewportContext.js
var React3 = __toESM(require_react(), 1);
var ToastViewportContext = React3.createContext(void 0);
if (true) ToastViewportContext.displayName = "ToastViewportContext";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/viewport/ToastViewportCssVars.js
var ToastViewportCssVars = (function(ToastViewportCssVars2) {
  ToastViewportCssVars2["frontmostHeight"] = "--toast-frontmost-height";
  return ToastViewportCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/viewport/ToastViewport.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var ToastViewport = React4.forwardRef(function ToastViewport2(componentProps, forwardedRef) {
  var _a;
  const {
    render,
    className,
    children,
    ...elementProps
  } = componentProps;
  const {
    toasts,
    pauseTimers,
    resumeTimers,
    hovering,
    setHovering,
    setFocused,
    viewportRef,
    windowFocusedRef,
    prevFocusElement,
    setPrevFocusElement,
    expanded,
    focused
  } = useToastContext();
  const handlingFocusGuardRef = React4.useRef(false);
  const focusedRef = useLatestRef(focused);
  const hoveringRef = useLatestRef(hovering);
  const numToasts = toasts.length;
  const frontmostHeight = ((_a = toasts[0]) == null ? void 0 : _a.height) ?? 0;
  const markedReadyForMouseLeave = React4.useRef(false);
  const hasTransitioningToasts = React4.useMemo(() => toasts.some((toast) => toast.transitionStatus === "ending"), [toasts]);
  React4.useEffect(() => {
    if (!viewportRef.current) {
      return void 0;
    }
    function handleGlobalKeyDown(event) {
      var _a2;
      if (numToasts === 0) {
        return;
      }
      if (event.key === "F6" && event.target !== viewportRef.current) {
        event.preventDefault();
        setPrevFocusElement(activeElement(ownerDocument(viewportRef.current)));
        (_a2 = viewportRef.current) == null ? void 0 : _a2.focus();
        pauseTimers();
        setFocused(true);
      }
    }
    const win = getWindow(viewportRef.current);
    win.addEventListener("keydown", handleGlobalKeyDown);
    return () => {
      win.removeEventListener("keydown", handleGlobalKeyDown);
    };
  }, [pauseTimers, setFocused, setPrevFocusElement, numToasts, viewportRef]);
  React4.useEffect(() => {
    if (!viewportRef.current || !numToasts) {
      return void 0;
    }
    const win = getWindow(viewportRef.current);
    function handleWindowBlur(event) {
      if (event.target !== win) {
        return;
      }
      windowFocusedRef.current = false;
      pauseTimers();
    }
    function handleWindowFocus(event) {
      if (event.relatedTarget || event.target === win) {
        return;
      }
      const target = getTarget(event);
      const activeEl = activeElement(ownerDocument(viewportRef.current));
      if (!contains(viewportRef.current, target) || !matchesFocusVisible(activeEl)) {
        resumeTimers();
      }
      setTimeout(() => {
        windowFocusedRef.current = true;
      });
    }
    win.addEventListener("blur", handleWindowBlur, true);
    win.addEventListener("focus", handleWindowFocus, true);
    return () => {
      win.removeEventListener("blur", handleWindowBlur, true);
      win.removeEventListener("focus", handleWindowFocus, true);
    };
  }, [
    pauseTimers,
    resumeTimers,
    viewportRef,
    windowFocusedRef,
    setFocused,
    focusedRef,
    // `viewportRef.current` isn't available on the first render,
    // since the portal node hasn't yet been created.
    // By adding this dependency, we ensure the window listeners
    // are added when toasts have been created, once the ref is available.
    numToasts
  ]);
  React4.useEffect(() => {
    const viewportNode = viewportRef.current;
    if (!viewportNode || numToasts === 0) {
      return void 0;
    }
    const doc = ownerDocument(viewportNode);
    function handlePointerDown(event) {
      if (event.pointerType !== "touch") {
        return;
      }
      const target = getTarget(event);
      if (contains(viewportNode, target)) {
        return;
      }
      resumeTimers();
      setHovering(false);
      setFocused(false);
    }
    doc.addEventListener("pointerdown", handlePointerDown, true);
    return () => {
      doc.removeEventListener("pointerdown", handlePointerDown, true);
    };
  }, [focusedRef, hoveringRef, numToasts, resumeTimers, setFocused, setHovering, viewportRef]);
  function handleFocusGuard(event) {
    var _a2, _b, _c;
    if (!viewportRef.current) {
      return;
    }
    handlingFocusGuardRef.current = true;
    if (event.relatedTarget === viewportRef.current) {
      (_c = (_b = (_a2 = toasts[0]) == null ? void 0 : _a2.ref) == null ? void 0 : _b.current) == null ? void 0 : _c.focus();
    } else {
      prevFocusElement == null ? void 0 : prevFocusElement.focus({
        preventScroll: true
      });
    }
  }
  function handleKeyDown(event) {
    if (event.key === "Tab" && event.shiftKey && event.target === viewportRef.current) {
      event.preventDefault();
      prevFocusElement == null ? void 0 : prevFocusElement.focus({
        preventScroll: true
      });
      resumeTimers();
    }
  }
  React4.useEffect(() => {
    if (!windowFocusedRef.current || hasTransitioningToasts || !markedReadyForMouseLeave.current) {
      return;
    }
    resumeTimers();
    setHovering(false);
    markedReadyForMouseLeave.current = false;
  }, [hasTransitioningToasts, resumeTimers, setHovering, windowFocusedRef]);
  function handleMouseEnter() {
    pauseTimers();
    setHovering(true);
    markedReadyForMouseLeave.current = false;
  }
  function handleMouseLeave() {
    if (toasts.some((toast) => toast.transitionStatus === "ending")) {
      markedReadyForMouseLeave.current = true;
    } else {
      resumeTimers();
      setHovering(false);
    }
  }
  function handleFocus() {
    if (handlingFocusGuardRef.current) {
      handlingFocusGuardRef.current = false;
      return;
    }
    if (focused) {
      return;
    }
    if (matchesFocusVisible(ownerDocument(viewportRef.current).activeElement)) {
      setFocused(true);
      pauseTimers();
    }
  }
  function handleBlur(event) {
    if (!focused || contains(viewportRef.current, event.relatedTarget)) {
      return;
    }
    setFocused(false);
    resumeTimers();
  }
  const defaultProps = {
    tabIndex: -1,
    role: "region",
    "aria-live": "polite",
    "aria-atomic": false,
    "aria-relevant": "additions text",
    "aria-label": "Notifications",
    onMouseEnter: handleMouseEnter,
    onMouseMove: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onKeyDown: handleKeyDown,
    onClick: handleFocus
  };
  const state = React4.useMemo(() => ({
    expanded
  }), [expanded]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, viewportRef],
    state,
    props: [defaultProps, {
      style: {
        [ToastViewportCssVars.frontmostHeight]: frontmostHeight ? `${frontmostHeight}px` : void 0
      }
    }, elementProps, {
      children: (0, import_jsx_runtime2.jsxs)(React4.Fragment, {
        children: [numToasts > 0 && prevFocusElement && (0, import_jsx_runtime2.jsx)(FocusGuard, {
          onFocus: handleFocusGuard
        }), children, numToasts > 0 && prevFocusElement && (0, import_jsx_runtime2.jsx)(FocusGuard, {
          onFocus: handleFocusGuard
        })]
      })
    }]
  });
  const contextValue = React4.useMemo(() => ({
    viewportRef
  }), [viewportRef]);
  const highPriorityToasts = React4.useMemo(() => toasts.filter((toast) => toast.priority === "high"), [toasts]);
  return (0, import_jsx_runtime2.jsxs)(ToastViewportContext.Provider, {
    value: contextValue,
    children: [numToasts > 0 && prevFocusElement && (0, import_jsx_runtime2.jsx)(FocusGuard, {
      onFocus: handleFocusGuard
    }), element, !focused && highPriorityToasts.length > 0 && (0, import_jsx_runtime2.jsx)("div", {
      style: visuallyHidden,
      children: highPriorityToasts.map((toast) => (0, import_jsx_runtime2.jsxs)("div", {
        role: "alert",
        "aria-atomic": true,
        children: [(0, import_jsx_runtime2.jsx)("div", {
          children: toast.title
        }), (0, import_jsx_runtime2.jsx)("div", {
          children: toast.description
        })]
      }, toast.id))
    })]
  });
});
if (true) ToastViewport.displayName = "ToastViewport";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/root/ToastRoot.js
var React6 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/root/ToastRootContext.js
var React5 = __toESM(require_react(), 1);
var ToastRootContext = React5.createContext(void 0);
if (true) ToastRootContext.displayName = "ToastRootContext";
function useToastRootContext() {
  const context = React5.useContext(ToastRootContext);
  if (!context) {
    throw new Error("Base UI: ToastRootContext is missing. Toast parts must be used within <Toast.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/root/ToastRootCssVars.js
var ToastRootCssVars = (function(ToastRootCssVars2) {
  ToastRootCssVars2["index"] = "--toast-index";
  ToastRootCssVars2["offsetY"] = "--toast-offset-y";
  ToastRootCssVars2["height"] = "--toast-height";
  ToastRootCssVars2["swipeMovementX"] = "--toast-swipe-movement-x";
  ToastRootCssVars2["swipeMovementY"] = "--toast-swipe-movement-y";
  return ToastRootCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/root/ToastRoot.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping = {
  ...transitionStatusMapping,
  swipeDirection(value) {
    return value ? {
      "data-swipe-direction": value
    } : null;
  }
};
var SWIPE_THRESHOLD = 40;
var REVERSE_CANCEL_THRESHOLD = 10;
var OPPOSITE_DIRECTION_DAMPING_FACTOR = 0.5;
var MIN_DRAG_THRESHOLD = 1;
function getDisplacement(direction, deltaX, deltaY) {
  switch (direction) {
    case "up":
      return -deltaY;
    case "down":
      return deltaY;
    case "left":
      return -deltaX;
    case "right":
      return deltaX;
    default:
      return 0;
  }
}
function getElementTransform(element) {
  const computedStyle = window.getComputedStyle(element);
  const transform = computedStyle.transform;
  let translateX = 0;
  let translateY = 0;
  let scale = 1;
  if (transform && transform !== "none") {
    const matrix = transform.match(/matrix(?:3d)?\(([^)]+)\)/);
    if (matrix) {
      const values = matrix[1].split(", ").map(parseFloat);
      if (values.length === 6) {
        translateX = values[4];
        translateY = values[5];
        scale = Math.sqrt(values[0] * values[0] + values[1] * values[1]);
      } else if (values.length === 16) {
        translateX = values[12];
        translateY = values[13];
        scale = values[0];
      }
    }
  }
  return {
    x: translateX,
    y: translateY,
    scale
  };
}
var ToastRoot = React6.forwardRef(function ToastRoot2(componentProps, forwardedRef) {
  const {
    toast,
    render,
    className,
    swipeDirection = ["down", "right"],
    ...elementProps
  } = componentProps;
  const swipeDirections = Array.isArray(swipeDirection) ? swipeDirection : [swipeDirection];
  const {
    toasts,
    focused,
    close,
    remove,
    setToasts,
    pauseTimers,
    expanded,
    setHovering
  } = useToastContext();
  const [currentSwipeDirection, setCurrentSwipeDirection] = React6.useState(void 0);
  const [isSwiping, setIsSwiping] = React6.useState(false);
  const [isRealSwipe, setIsRealSwipe] = React6.useState(false);
  const [dragDismissed, setDragDismissed] = React6.useState(false);
  const [dragOffset, setDragOffset] = React6.useState({
    x: 0,
    y: 0
  });
  const [initialTransform, setInitialTransform] = React6.useState({
    x: 0,
    y: 0,
    scale: 1
  });
  const [titleId, setTitleId] = React6.useState();
  const [descriptionId, setDescriptionId] = React6.useState();
  const [lockedDirection, setLockedDirection] = React6.useState(null);
  const rootRef = React6.useRef(null);
  const dragStartPosRef = React6.useRef({
    x: 0,
    y: 0
  });
  const initialTransformRef = React6.useRef({
    x: 0,
    y: 0,
    scale: 1
  });
  const intendedSwipeDirectionRef = React6.useRef(void 0);
  const maxSwipeDisplacementRef = React6.useRef(0);
  const cancelledSwipeRef = React6.useRef(false);
  const swipeCancelBaselineRef = React6.useRef({
    x: 0,
    y: 0
  });
  const isFirstPointerMoveRef = React6.useRef(false);
  const domIndex = React6.useMemo(() => toasts.indexOf(toast), [toast, toasts]);
  const visibleIndex = React6.useMemo(() => toasts.filter((t) => t.transitionStatus !== "ending").indexOf(toast), [toast, toasts]);
  const offsetY = React6.useMemo(() => {
    return toasts.slice(0, toasts.indexOf(toast)).reduce((acc, t) => acc + (t.height || 0), 0);
  }, [toasts, toast]);
  useOpenChangeComplete({
    open: toast.transitionStatus !== "ending",
    ref: rootRef,
    onComplete() {
      if (toast.transitionStatus === "ending") {
        remove(toast.id);
      }
    }
  });
  const recalculateHeight = useEventCallback(() => {
    const element2 = rootRef.current;
    if (!element2) {
      return;
    }
    const previousHeight = element2.style.height;
    element2.style.height = "auto";
    const height = element2.offsetHeight;
    element2.style.height = previousHeight;
    setToasts((prev) => prev.map((t) => t.id === toast.id ? {
      ...t,
      ref: rootRef,
      height,
      transitionStatus: void 0
    } : t));
  });
  useIsoLayoutEffect(recalculateHeight, [recalculateHeight]);
  function applyDirectionalDamping(deltaX, deltaY) {
    let newDeltaX = deltaX;
    let newDeltaY = deltaY;
    if (!swipeDirections.includes("left") && !swipeDirections.includes("right")) {
      newDeltaX = deltaX > 0 ? deltaX ** OPPOSITE_DIRECTION_DAMPING_FACTOR : -(Math.abs(deltaX) ** OPPOSITE_DIRECTION_DAMPING_FACTOR);
    } else {
      if (!swipeDirections.includes("right") && deltaX > 0) {
        newDeltaX = deltaX ** OPPOSITE_DIRECTION_DAMPING_FACTOR;
      }
      if (!swipeDirections.includes("left") && deltaX < 0) {
        newDeltaX = -(Math.abs(deltaX) ** OPPOSITE_DIRECTION_DAMPING_FACTOR);
      }
    }
    if (!swipeDirections.includes("up") && !swipeDirections.includes("down")) {
      newDeltaY = deltaY > 0 ? deltaY ** OPPOSITE_DIRECTION_DAMPING_FACTOR : -(Math.abs(deltaY) ** OPPOSITE_DIRECTION_DAMPING_FACTOR);
    } else {
      if (!swipeDirections.includes("down") && deltaY > 0) {
        newDeltaY = deltaY ** OPPOSITE_DIRECTION_DAMPING_FACTOR;
      }
      if (!swipeDirections.includes("up") && deltaY < 0) {
        newDeltaY = -(Math.abs(deltaY) ** OPPOSITE_DIRECTION_DAMPING_FACTOR);
      }
    }
    return {
      x: newDeltaX,
      y: newDeltaY
    };
  }
  function handlePointerDown(event) {
    var _a;
    if (event.button !== 0) {
      return;
    }
    if (event.pointerType === "touch") {
      pauseTimers();
    }
    const target = getTarget(event.nativeEvent);
    const isInteractiveElement = target ? target.closest('button,a,input,textarea,[role="button"],[data-swipe-ignore]') : false;
    if (isInteractiveElement) {
      return;
    }
    cancelledSwipeRef.current = false;
    intendedSwipeDirectionRef.current = void 0;
    maxSwipeDisplacementRef.current = 0;
    dragStartPosRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    swipeCancelBaselineRef.current = dragStartPosRef.current;
    if (rootRef.current) {
      const transform = getElementTransform(rootRef.current);
      initialTransformRef.current = transform;
      setInitialTransform(transform);
      setDragOffset({
        x: transform.x,
        y: transform.y
      });
    }
    setHovering(true);
    setIsSwiping(true);
    setIsRealSwipe(false);
    setLockedDirection(null);
    isFirstPointerMoveRef.current = true;
    (_a = rootRef.current) == null ? void 0 : _a.setPointerCapture(event.pointerId);
  }
  function handlePointerMove(event) {
    if (!isSwiping) {
      return;
    }
    event.preventDefault();
    if (isFirstPointerMoveRef.current) {
      dragStartPosRef.current = {
        x: event.clientX,
        y: event.clientY
      };
      isFirstPointerMoveRef.current = false;
    }
    const {
      clientY,
      clientX,
      movementX,
      movementY
    } = event;
    if (movementY < 0 && clientY > swipeCancelBaselineRef.current.y || movementY > 0 && clientY < swipeCancelBaselineRef.current.y) {
      swipeCancelBaselineRef.current = {
        x: swipeCancelBaselineRef.current.x,
        y: clientY
      };
    }
    if (movementX < 0 && clientX > swipeCancelBaselineRef.current.x || movementX > 0 && clientX < swipeCancelBaselineRef.current.x) {
      swipeCancelBaselineRef.current = {
        x: clientX,
        y: swipeCancelBaselineRef.current.y
      };
    }
    const deltaX = clientX - dragStartPosRef.current.x;
    const deltaY = clientY - dragStartPosRef.current.y;
    const cancelDeltaY = clientY - swipeCancelBaselineRef.current.y;
    const cancelDeltaX = clientX - swipeCancelBaselineRef.current.x;
    if (!isRealSwipe) {
      const movementDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (movementDistance >= MIN_DRAG_THRESHOLD) {
        setIsRealSwipe(true);
        if (lockedDirection === null) {
          const hasHorizontal = swipeDirections.includes("left") || swipeDirections.includes("right");
          const hasVertical = swipeDirections.includes("up") || swipeDirections.includes("down");
          if (hasHorizontal && hasVertical) {
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            setLockedDirection(absX > absY ? "horizontal" : "vertical");
          }
        }
      }
    }
    let candidate;
    if (!intendedSwipeDirectionRef.current) {
      if (lockedDirection === "vertical") {
        if (deltaY > 0) {
          candidate = "down";
        } else if (deltaY < 0) {
          candidate = "up";
        }
      } else if (lockedDirection === "horizontal") {
        if (deltaX > 0) {
          candidate = "right";
        } else if (deltaX < 0) {
          candidate = "left";
        }
      } else if (Math.abs(deltaX) >= Math.abs(deltaY)) {
        candidate = deltaX > 0 ? "right" : "left";
      } else {
        candidate = deltaY > 0 ? "down" : "up";
      }
      if (candidate && swipeDirections.includes(candidate)) {
        intendedSwipeDirectionRef.current = candidate;
        maxSwipeDisplacementRef.current = getDisplacement(candidate, deltaX, deltaY);
        setCurrentSwipeDirection(candidate);
      }
    } else {
      const direction = intendedSwipeDirectionRef.current;
      const currentDisplacement = getDisplacement(direction, cancelDeltaX, cancelDeltaY);
      if (currentDisplacement > SWIPE_THRESHOLD) {
        cancelledSwipeRef.current = false;
        setCurrentSwipeDirection(direction);
      } else if (maxSwipeDisplacementRef.current - currentDisplacement >= REVERSE_CANCEL_THRESHOLD) {
        cancelledSwipeRef.current = true;
      }
    }
    const dampedDelta = applyDirectionalDamping(deltaX, deltaY);
    let newOffsetX = initialTransformRef.current.x;
    let newOffsetY = initialTransformRef.current.y;
    if (lockedDirection === "horizontal") {
      if (swipeDirections.includes("left") || swipeDirections.includes("right")) {
        newOffsetX += dampedDelta.x;
      }
    } else if (lockedDirection === "vertical") {
      if (swipeDirections.includes("up") || swipeDirections.includes("down")) {
        newOffsetY += dampedDelta.y;
      }
    } else {
      if (swipeDirections.includes("left") || swipeDirections.includes("right")) {
        newOffsetX += dampedDelta.x;
      }
      if (swipeDirections.includes("up") || swipeDirections.includes("down")) {
        newOffsetY += dampedDelta.y;
      }
    }
    setDragOffset({
      x: newOffsetX,
      y: newOffsetY
    });
  }
  function handlePointerUp(event) {
    var _a;
    if (!isSwiping) {
      return;
    }
    setIsSwiping(false);
    setIsRealSwipe(false);
    setLockedDirection(null);
    (_a = rootRef.current) == null ? void 0 : _a.releasePointerCapture(event.pointerId);
    if (cancelledSwipeRef.current) {
      setDragOffset({
        x: initialTransform.x,
        y: initialTransform.y
      });
      setCurrentSwipeDirection(void 0);
      return;
    }
    let shouldClose = false;
    const deltaX = dragOffset.x - initialTransform.x;
    const deltaY = dragOffset.y - initialTransform.y;
    let dismissDirection;
    for (const direction of swipeDirections) {
      switch (direction) {
        case "right":
          if (deltaX > SWIPE_THRESHOLD) {
            shouldClose = true;
            dismissDirection = "right";
          }
          break;
        case "left":
          if (deltaX < -SWIPE_THRESHOLD) {
            shouldClose = true;
            dismissDirection = "left";
          }
          break;
        case "down":
          if (deltaY > SWIPE_THRESHOLD) {
            shouldClose = true;
            dismissDirection = "down";
          }
          break;
        case "up":
          if (deltaY < -SWIPE_THRESHOLD) {
            shouldClose = true;
            dismissDirection = "up";
          }
          break;
        default:
          break;
      }
      if (shouldClose) {
        break;
      }
    }
    if (shouldClose) {
      setCurrentSwipeDirection(dismissDirection);
      setDragDismissed(true);
      close(toast.id);
    } else {
      setDragOffset({
        x: initialTransform.x,
        y: initialTransform.y
      });
      setCurrentSwipeDirection(void 0);
    }
  }
  function handleKeyDown(event) {
    if (event.key === "Escape") {
      if (!rootRef.current || !contains(rootRef.current, activeElement(ownerDocument(rootRef.current)))) {
        return;
      }
      close(toast.id);
    }
  }
  React6.useEffect(() => {
    const element2 = rootRef.current;
    if (!element2) {
      return void 0;
    }
    function preventDefaultTouchStart(event) {
      if (contains(element2, event.target)) {
        event.preventDefault();
      }
    }
    element2.addEventListener("touchmove", preventDefaultTouchStart, {
      passive: false
    });
    return () => {
      element2.removeEventListener("touchmove", preventDefaultTouchStart);
    };
  }, []);
  function getDragStyles() {
    if (!isSwiping && dragOffset.x === initialTransform.x && dragOffset.y === initialTransform.y && !dragDismissed) {
      return {
        [ToastRootCssVars.swipeMovementX]: "0px",
        [ToastRootCssVars.swipeMovementY]: "0px"
      };
    }
    const deltaX = dragOffset.x - initialTransform.x;
    const deltaY = dragOffset.y - initialTransform.y;
    return {
      transition: isSwiping ? "none" : void 0,
      // While swiping, freeze the element at its current visual transform so it doesn't snap to the
      // end position.
      transform: isSwiping ? `translateX(${dragOffset.x}px) translateY(${dragOffset.y}px) scale(${initialTransform.scale})` : void 0,
      [ToastRootCssVars.swipeMovementX]: `${deltaX}px`,
      [ToastRootCssVars.swipeMovementY]: `${deltaY}px`
    };
  }
  const isHighPriority = toast.priority === "high";
  const defaultProps = {
    role: isHighPriority ? "alertdialog" : "dialog",
    tabIndex: 0,
    "aria-modal": false,
    "aria-labelledby": titleId,
    "aria-describedby": descriptionId,
    "aria-hidden": isHighPriority && !focused ? true : void 0,
    onPointerDown: handlePointerDown,
    onPointerMove: handlePointerMove,
    onPointerUp: handlePointerUp,
    onKeyDown: handleKeyDown,
    inert: inertValue(toast.limited),
    style: {
      ...getDragStyles(),
      [ToastRootCssVars.index]: toast.transitionStatus === "ending" ? domIndex : visibleIndex,
      [ToastRootCssVars.offsetY]: `${offsetY}px`,
      [ToastRootCssVars.height]: toast.height ? `${toast.height}px` : void 0
    }
  };
  const toastRoot = React6.useMemo(() => ({
    rootRef,
    toast,
    titleId,
    setTitleId,
    descriptionId,
    setDescriptionId,
    swiping: isSwiping,
    swipeDirection: currentSwipeDirection,
    recalculateHeight,
    index: domIndex,
    visibleIndex,
    expanded
  }), [toast, titleId, descriptionId, isSwiping, currentSwipeDirection, recalculateHeight, domIndex, visibleIndex, expanded]);
  const state = React6.useMemo(() => ({
    transitionStatus: toast.transitionStatus,
    expanded,
    limited: toast.limited || false,
    type: toast.type,
    swiping: toastRoot.swiping,
    swipeDirection: toastRoot.swipeDirection
  }), [expanded, toast.transitionStatus, toast.limited, toast.type, toastRoot.swiping, toastRoot.swipeDirection]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, toastRoot.rootRef],
    state,
    stateAttributesMapping,
    props: [defaultProps, elementProps]
  });
  return (0, import_jsx_runtime3.jsx)(ToastRootContext.Provider, {
    value: toastRoot,
    children: element
  });
});
if (true) ToastRoot.displayName = "ToastRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/content/ToastContent.js
var React7 = __toESM(require_react(), 1);
var ToastContent = React7.forwardRef(function ToastContent2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    visibleIndex,
    expanded,
    recalculateHeight
  } = useToastRootContext();
  const contentRef = React7.useRef(null);
  useIsoLayoutEffect(() => {
    const node = contentRef.current;
    if (!node) {
      return void 0;
    }
    recalculateHeight();
    if (typeof ResizeObserver !== "function") {
      return void 0;
    }
    const resizeObserver = new ResizeObserver(recalculateHeight);
    resizeObserver.observe(node);
    return () => {
      resizeObserver.disconnect();
    };
  }, [recalculateHeight]);
  const behind = visibleIndex > 0;
  const state = React7.useMemo(() => ({
    expanded,
    behind
  }), [expanded, behind]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, contentRef],
    state,
    props: elementProps
  });
  return element;
});
if (true) ToastContent.displayName = "ToastContent";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/description/ToastDescription.js
var React8 = __toESM(require_react(), 1);
var ToastDescription = React8.forwardRef(function ToastDescription2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    children: childrenProp,
    ...elementProps
  } = componentProps;
  const {
    toast
  } = useToastRootContext();
  const children = childrenProp ?? toast.description;
  const shouldRender = Boolean(children);
  const id = useId(idProp);
  const {
    setDescriptionId
  } = useToastRootContext();
  useIsoLayoutEffect(() => {
    if (!shouldRender) {
      return void 0;
    }
    setDescriptionId(id);
    return () => {
      setDescriptionId(void 0);
    };
  }, [shouldRender, id, setDescriptionId]);
  const state = React8.useMemo(() => ({
    type: toast.type
  }), [toast.type]);
  const element = useRenderElement("p", componentProps, {
    ref: forwardedRef,
    state,
    props: {
      ...elementProps,
      id,
      children
    }
  });
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) ToastDescription.displayName = "ToastDescription";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/title/ToastTitle.js
var React9 = __toESM(require_react(), 1);
var ToastTitle = React9.forwardRef(function ToastTitle2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    children: childrenProp,
    ...elementProps
  } = componentProps;
  const {
    toast
  } = useToastRootContext();
  const children = childrenProp ?? toast.title;
  const shouldRender = Boolean(children);
  const id = useId(idProp);
  const {
    setTitleId
  } = useToastRootContext();
  useIsoLayoutEffect(() => {
    if (!shouldRender) {
      return void 0;
    }
    setTitleId(id);
    return () => {
      setTitleId(void 0);
    };
  }, [shouldRender, id, setTitleId]);
  const state = React9.useMemo(() => ({
    type: toast.type
  }), [toast.type]);
  const element = useRenderElement("h2", componentProps, {
    ref: forwardedRef,
    state,
    props: {
      ...elementProps,
      id,
      children
    }
  });
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) ToastTitle.displayName = "ToastTitle";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/close/ToastClose.js
var React10 = __toESM(require_react(), 1);
var ToastClose = React10.forwardRef(function ToastClose2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    close,
    expanded
  } = useToastContext();
  const {
    toast
  } = useToastRootContext();
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const state = React10.useMemo(() => ({
    type: toast.type
  }), [toast.type]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state,
    props: [{
      "aria-hidden": !expanded,
      onClick() {
        close(toast.id);
      }
    }, elementProps, getButtonProps]
  });
  return element;
});
if (true) ToastClose.displayName = "ToastClose";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/action/ToastAction.js
var React11 = __toESM(require_react(), 1);
var ToastAction = React11.forwardRef(function ToastAction2(componentProps, forwardedRef) {
  var _a;
  const {
    render,
    className,
    disabled,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    toast
  } = useToastRootContext();
  const computedChildren = ((_a = toast.actionProps) == null ? void 0 : _a.children) ?? elementProps.children;
  const shouldRender = Boolean(computedChildren);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const state = React11.useMemo(() => ({
    type: toast.type
  }), [toast.type]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state,
    props: [elementProps, toast.actionProps, getButtonProps, {
      children: computedChildren
    }]
  });
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) ToastAction.displayName = "ToastAction";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/portal/ToastPortal.js
var React12 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function ToastPortal(props) {
  const {
    children,
    container
  } = props;
  return (0, import_jsx_runtime4.jsx)(FloatingPortalLite, {
    root: container,
    children
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/useToastManager.js
var React13 = __toESM(require_react(), 1);
function useToastManager() {
  const context = React13.useContext(ToastContext);
  if (!context) {
    throw new Error("Base UI: useToast must be used within <Toast.Provider>.");
  }
  const {
    toasts,
    add,
    close,
    update,
    promise
  } = context;
  return React13.useMemo(() => ({
    toasts,
    add,
    close,
    update,
    promise
  }), [toasts, add, close, update, promise]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toast/createToastManager.js
function createToastManager() {
  const listeners = [];
  function emit(data) {
    listeners.forEach((listener) => listener(data));
  }
  return {
    // This should be private aside from ToastProvider needing to access it.
    // https://x.com/drosenwasser/status/1816947740032872664
    " subscribe": function subscribe(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
      };
    },
    add(options) {
      const id = options.id || generateId("toast");
      const toastToAdd = {
        ...options,
        id,
        transitionStatus: "starting"
      };
      emit({
        action: "add",
        options: toastToAdd
      });
      return id;
    },
    close(id) {
      emit({
        action: "close",
        options: {
          id
        }
      });
    },
    update(id, updates) {
      emit({
        action: "update",
        options: {
          ...updates,
          id
        }
      });
    },
    promise(promiseValue, options) {
      let handledPromise = promiseValue;
      emit({
        action: "promise",
        options: {
          ...options,
          promise: promiseValue,
          setPromise(promise) {
            handledPromise = promise;
          }
        }
      });
      return handledPromise;
    }
  };
}

export {
  index_parts_exports
};
//# sourceMappingURL=chunk-PDEOYEX5.js.map
