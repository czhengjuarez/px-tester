import {
  AnimationFrame
} from "./chunk-UAJXLITD.js";
import {
  Timeout
} from "./chunk-ZDUACO7A.js";
import {
  ownerDocument
} from "./chunk-3FELFY6H.js";
import {
  isIOS,
  isWebKit
} from "./chunk-CSZZYMWP.js";
import {
  getWindow
} from "./chunk-5VFA47B3.js";
import {
  NOOP,
  useIsoLayoutEffect,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/separator/Separator.js
var React = __toESM(require_react(), 1);
var Separator = React.forwardRef(function SeparatorComponent(componentProps, forwardedRef) {
  const {
    className,
    render,
    orientation = "horizontal",
    ...elementProps
  } = componentProps;
  const state = React.useMemo(() => ({
    orientation
  }), [orientation]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      role: "separator",
      "aria-orientation": orientation
    }, elementProps]
  });
  return element;
});
if (true) Separator.displayName = "Separator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/useScrollLock.js
var originalHtmlStyles = {};
var originalBodyStyles = {};
var originalHtmlScrollBehavior = "";
function hasInsetScrollbars(referenceElement) {
  if (typeof document === "undefined") {
    return false;
  }
  const doc = ownerDocument(referenceElement);
  const win = getWindow(doc);
  return win.innerWidth - doc.documentElement.clientWidth > 0;
}
function preventScrollBasic(referenceElement) {
  const doc = ownerDocument(referenceElement);
  const html = doc.documentElement;
  const originalOverflow = html.style.overflow;
  html.style.overflow = "hidden";
  return () => {
    html.style.overflow = originalOverflow;
  };
}
function preventScrollStandard(referenceElement) {
  var _a;
  const doc = ownerDocument(referenceElement);
  const html = doc.documentElement;
  const body = doc.body;
  const win = getWindow(html);
  let scrollTop = 0;
  let scrollLeft = 0;
  const resizeFrame = AnimationFrame.create();
  if (isWebKit && (((_a = win.visualViewport) == null ? void 0 : _a.scale) ?? 1) !== 1) {
    return () => {
    };
  }
  function lockScroll() {
    var _a2;
    const htmlStyles = win.getComputedStyle(html);
    const bodyStyles = win.getComputedStyle(body);
    scrollTop = html.scrollTop;
    scrollLeft = html.scrollLeft;
    originalHtmlStyles = {
      scrollbarGutter: html.style.scrollbarGutter,
      overflowY: html.style.overflowY,
      overflowX: html.style.overflowX
    };
    originalHtmlScrollBehavior = html.style.scrollBehavior;
    originalBodyStyles = {
      position: body.style.position,
      height: body.style.height,
      width: body.style.width,
      boxSizing: body.style.boxSizing,
      overflowY: body.style.overflowY,
      overflowX: body.style.overflowX,
      scrollBehavior: body.style.scrollBehavior
    };
    const supportsStableScrollbarGutter = typeof CSS !== "undefined" && ((_a2 = CSS.supports) == null ? void 0 : _a2.call(CSS, "scrollbar-gutter", "stable"));
    const isScrollableY = html.scrollHeight > html.clientHeight;
    const isScrollableX = html.scrollWidth > html.clientWidth;
    const hasConstantOverflowY = htmlStyles.overflowY === "scroll" || bodyStyles.overflowY === "scroll";
    const hasConstantOverflowX = htmlStyles.overflowX === "scroll" || bodyStyles.overflowX === "scroll";
    const scrollbarWidth = Math.max(0, win.innerWidth - html.clientWidth);
    const scrollbarHeight = Math.max(0, win.innerHeight - html.clientHeight);
    const marginY = parseFloat(bodyStyles.marginTop) + parseFloat(bodyStyles.marginBottom);
    const marginX = parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight);
    Object.assign(html.style, {
      scrollbarGutter: "stable",
      overflowY: !supportsStableScrollbarGutter && (isScrollableY || hasConstantOverflowY) ? "scroll" : "hidden",
      overflowX: !supportsStableScrollbarGutter && (isScrollableX || hasConstantOverflowX) ? "scroll" : "hidden"
    });
    Object.assign(body.style, {
      position: "relative",
      height: marginY || scrollbarHeight ? `calc(100dvh - ${marginY + scrollbarHeight}px)` : "100dvh",
      width: marginX || scrollbarWidth ? `calc(100vw - ${marginX + scrollbarWidth}px)` : "100vw",
      boxSizing: "border-box",
      overflow: "hidden",
      scrollBehavior: "unset"
    });
    body.scrollTop = scrollTop;
    body.scrollLeft = scrollLeft;
    html.setAttribute("data-base-ui-scroll-locked", "");
    html.style.scrollBehavior = "unset";
  }
  function cleanup() {
    Object.assign(html.style, originalHtmlStyles);
    Object.assign(body.style, originalBodyStyles);
    html.scrollTop = scrollTop;
    html.scrollLeft = scrollLeft;
    html.removeAttribute("data-base-ui-scroll-locked");
    html.style.scrollBehavior = originalHtmlScrollBehavior;
  }
  function handleResize() {
    cleanup();
    resizeFrame.request(lockScroll);
  }
  lockScroll();
  win.addEventListener("resize", handleResize);
  return () => {
    resizeFrame.cancel();
    cleanup();
    win.removeEventListener("resize", handleResize);
  };
}
var ScrollLocker = class {
  constructor() {
    __publicField(this, "lockCount", 0);
    __publicField(this, "restore", /* @__PURE__ */ (() => null)());
    __publicField(this, "timeoutLock", (() => Timeout.create())());
    __publicField(this, "timeoutUnlock", (() => Timeout.create())());
    __publicField(this, "release", () => {
      this.lockCount -= 1;
      if (this.lockCount === 0 && this.restore) {
        this.timeoutUnlock.start(0, this.unlock);
      }
    });
    __publicField(this, "unlock", () => {
      var _a;
      if (this.lockCount === 0 && this.restore) {
        (_a = this.restore) == null ? void 0 : _a.call(this);
        this.restore = null;
      }
    });
  }
  acquire(referenceElement) {
    this.lockCount += 1;
    if (this.lockCount === 1 && this.restore === null) {
      this.timeoutLock.start(0, () => this.lock(referenceElement));
    }
    return this.release;
  }
  lock(referenceElement) {
    if (this.lockCount === 0 || this.restore !== null) {
      return;
    }
    const doc = ownerDocument(referenceElement);
    const html = doc.documentElement;
    const htmlOverflowY = getWindow(html).getComputedStyle(html).overflowY;
    if (htmlOverflowY === "hidden" || htmlOverflowY === "clip") {
      this.restore = NOOP;
      return;
    }
    const isOverflowHiddenLock = isIOS || !hasInsetScrollbars(referenceElement);
    this.restore = isOverflowHiddenLock ? preventScrollBasic(referenceElement) : preventScrollStandard(referenceElement);
  }
};
var SCROLL_LOCKER = new ScrollLocker();
function useScrollLock(params) {
  const {
    enabled = true,
    mounted,
    open,
    referenceElement = null
  } = params;
  useIsoLayoutEffect(() => {
    if (enabled && isWebKit && mounted && !open) {
      const doc = ownerDocument(referenceElement);
      const originalUserSelect = doc.body.style.userSelect;
      const originalWebkitUserSelect = doc.body.style.webkitUserSelect;
      doc.body.style.userSelect = "none";
      doc.body.style.webkitUserSelect = "none";
      return () => {
        doc.body.style.userSelect = originalUserSelect;
        doc.body.style.webkitUserSelect = originalWebkitUserSelect;
      };
    }
    return void 0;
  }, [enabled, mounted, open, referenceElement]);
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return void 0;
    }
    return SCROLL_LOCKER.acquire(referenceElement);
  }, [enabled, referenceElement]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/root/ToolbarRootContext.js
var React2 = __toESM(require_react(), 1);
var ToolbarRootContext = React2.createContext(void 0);
if (true) ToolbarRootContext.displayName = "ToolbarRootContext";
function useToolbarRootContext(optional) {
  const context = React2.useContext(ToolbarRootContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: ToolbarRootContext is missing. Toolbar parts must be placed within <Toolbar.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/InternalBackdrop.js
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var InternalBackdrop = React3.forwardRef(function InternalBackdrop2(props, ref) {
  const {
    cutout,
    ...otherProps
  } = props;
  let clipPath;
  if (cutout) {
    const rect = cutout == null ? void 0 : cutout.getBoundingClientRect();
    clipPath = `polygon(
      0% 0%,
      100% 0%,
      100% 100%,
      0% 100%,
      0% 0%,
      ${rect.left}px ${rect.top}px,
      ${rect.left}px ${rect.bottom}px,
      ${rect.right}px ${rect.bottom}px,
      ${rect.right}px ${rect.top}px,
      ${rect.left}px ${rect.top}px
    )`;
  }
  return (0, import_jsx_runtime.jsx)("div", {
    ref,
    role: "presentation",
    "data-base-ui-inert": "",
    ...otherProps,
    style: {
      position: "fixed",
      inset: 0,
      userSelect: "none",
      WebkitUserSelect: "none",
      clipPath
    }
  });
});
if (true) InternalBackdrop.displayName = "InternalBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/getPseudoElementBounds.js
function getPseudoElementBounds(element) {
  const elementRect = element.getBoundingClientRect();
  if (false) {
    return elementRect;
  }
  const beforeStyles = window.getComputedStyle(element, "::before");
  const afterStyles = window.getComputedStyle(element, "::after");
  const hasPseudoElements = beforeStyles.content !== "none" || afterStyles.content !== "none";
  if (!hasPseudoElements) {
    return elementRect;
  }
  const beforeWidth = parseFloat(beforeStyles.width) || 0;
  const beforeHeight = parseFloat(beforeStyles.height) || 0;
  const afterWidth = parseFloat(afterStyles.width) || 0;
  const afterHeight = parseFloat(afterStyles.height) || 0;
  const totalWidth = Math.max(elementRect.width, beforeWidth, afterWidth);
  const totalHeight = Math.max(elementRect.height, beforeHeight, afterHeight);
  const widthDiff = totalWidth - elementRect.width;
  const heightDiff = totalHeight - elementRect.height;
  return {
    left: elementRect.left - widthDiff / 2,
    right: elementRect.right + widthDiff / 2,
    top: elementRect.top - heightDiff / 2,
    bottom: elementRect.bottom + heightDiff / 2
  };
}

export {
  InternalBackdrop,
  useScrollLock,
  Separator,
  ToolbarRootContext,
  useToolbarRootContext,
  getPseudoElementBounds
};
//# sourceMappingURL=chunk-MRI4Y6N6.js.map
