import {
  generateId
} from "./chunk-ZRSJIC2B.js";
import {
  useCompositeItem
} from "./chunk-YCZIVBMH.js";
import {
  ALL_KEYS,
  ARROW_DOWN,
  ARROW_KEYS,
  ARROW_LEFT,
  ARROW_RIGHT,
  ARROW_UP,
  CompositeList,
  END,
  HOME,
  HORIZONTAL_KEYS,
  HORIZONTAL_KEYS_WITH_EXTRA_KEYS,
  MODIFIER_KEYS,
  VERTICAL_KEYS,
  VERTICAL_KEYS_WITH_EXTRA_KEYS,
  isNativeInput,
  scrollIntoViewIfNeeded,
  useCompositeListItem
} from "./chunk-IZQX5ZPK.js";
import {
  useBaseUiId
} from "./chunk-EZX2H7FZ.js";
import {
  CompositeRootContext,
  useButton
} from "./chunk-PODRTBZK.js";
import {
  useDirection
} from "./chunk-GJAGVRWM.js";
import {
  useControlled
} from "./chunk-NXVU5FCV.js";
import {
  ownerDocument
} from "./chunk-3FELFY6H.js";
import {
  activeElement,
  contains,
  createGridCellMap,
  findNonDisabledListIndex,
  getGridCellIndexOfCorner,
  getGridCellIndices,
  getGridNavigatedIndex,
  getMaxListIndex,
  getMinListIndex,
  isIndexOutOfListBounds,
  isListIndexDisabled
} from "./chunk-CSZZYMWP.js";
import {
  createChangeEventDetails,
  useEventCallback,
  useOnMount
} from "./chunk-5VFA47B3.js";
import {
  EMPTY_ARRAY,
  EMPTY_OBJECT,
  useIsoLayoutEffect,
  useMergedRefs,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __export,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Indicator: () => TabsIndicator,
  List: () => TabsList,
  Panel: () => TabsPanel,
  Root: () => TabsRoot,
  Tab: () => TabsTab
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/root/TabsRoot.js
var React2 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/root/TabsRootContext.js
var React = __toESM(require_react(), 1);
var TabsRootContext = React.createContext(void 0);
if (true) TabsRootContext.displayName = "TabsRootContext";
function useTabsRootContext() {
  const context = React.useContext(TabsRootContext);
  if (context === void 0) {
    throw new Error("Base UI: TabsRootContext is missing. Tabs parts must be placed within <Tabs.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/root/TabsRootDataAttributes.js
var TabsRootDataAttributes = (function(TabsRootDataAttributes2) {
  TabsRootDataAttributes2["activationDirection"] = "data-activation-direction";
  TabsRootDataAttributes2["orientation"] = "data-orientation";
  return TabsRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/root/stateAttributesMapping.js
var tabsStateAttributesMapping = {
  tabActivationDirection: (dir) => ({
    [TabsRootDataAttributes.activationDirection]: dir
  })
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/root/TabsRoot.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var TabsRoot = React2.forwardRef(function TabsRoot2(componentProps, forwardedRef) {
  const {
    className,
    defaultValue = 0,
    onValueChange: onValueChangeProp,
    orientation = "horizontal",
    render,
    value: valueProp,
    ...elementProps
  } = componentProps;
  const direction = useDirection();
  const tabPanelRefs = React2.useRef([]);
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Tabs",
    state: "value"
  });
  const [tabPanelMap, setTabPanelMap] = React2.useState(() => /* @__PURE__ */ new Map());
  const [tabMap, setTabMap] = React2.useState(() => /* @__PURE__ */ new Map());
  const [tabActivationDirection, setTabActivationDirection] = React2.useState("none");
  const onValueChange = useEventCallback((newValue, eventDetails) => {
    onValueChangeProp == null ? void 0 : onValueChangeProp(newValue, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setValue(newValue);
    setTabActivationDirection(eventDetails.activationDirection);
  });
  const getTabPanelIdByTabValueOrIndex = React2.useCallback((tabValue, index) => {
    if (tabValue === void 0 && index < 0) {
      return void 0;
    }
    for (const tabPanelMetadata of tabPanelMap.values()) {
      if (tabValue !== void 0 && tabPanelMetadata && tabValue === (tabPanelMetadata == null ? void 0 : tabPanelMetadata.value)) {
        return tabPanelMetadata.id;
      }
      if (tabValue === void 0 && (tabPanelMetadata == null ? void 0 : tabPanelMetadata.index) && (tabPanelMetadata == null ? void 0 : tabPanelMetadata.index) === index) {
        return tabPanelMetadata.id;
      }
    }
    return void 0;
  }, [tabPanelMap]);
  const getTabIdByPanelValueOrIndex = React2.useCallback((tabPanelValue, index) => {
    if (tabPanelValue === void 0 && index < 0) {
      return void 0;
    }
    for (const tabMetadata of tabMap.values()) {
      if (tabPanelValue !== void 0 && index > -1 && tabPanelValue === ((tabMetadata == null ? void 0 : tabMetadata.value) ?? (tabMetadata == null ? void 0 : tabMetadata.index) ?? void 0)) {
        return tabMetadata == null ? void 0 : tabMetadata.id;
      }
      if (tabPanelValue === void 0 && index > -1 && index === ((tabMetadata == null ? void 0 : tabMetadata.value) ?? (tabMetadata == null ? void 0 : tabMetadata.index) ?? void 0)) {
        return tabMetadata == null ? void 0 : tabMetadata.id;
      }
    }
    return void 0;
  }, [tabMap]);
  const getTabElementBySelectedValue = React2.useCallback((selectedValue) => {
    if (selectedValue === void 0) {
      return null;
    }
    for (const [tabElement, tabMetadata] of tabMap.entries()) {
      if (tabMetadata != null && selectedValue === (tabMetadata.value ?? tabMetadata.index)) {
        return tabElement;
      }
    }
    return null;
  }, [tabMap]);
  const tabsContextValue = React2.useMemo(() => ({
    direction,
    getTabElementBySelectedValue,
    getTabIdByPanelValueOrIndex,
    getTabPanelIdByTabValueOrIndex,
    onValueChange,
    orientation,
    setTabMap,
    tabActivationDirection,
    value
  }), [direction, getTabElementBySelectedValue, getTabIdByPanelValueOrIndex, getTabPanelIdByTabValueOrIndex, onValueChange, orientation, setTabMap, tabActivationDirection, value]);
  const state = {
    orientation,
    tabActivationDirection
  };
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: tabsStateAttributesMapping
  });
  return (0, import_jsx_runtime.jsx)(TabsRootContext.Provider, {
    value: tabsContextValue,
    children: (0, import_jsx_runtime.jsx)(CompositeList, {
      elementsRef: tabPanelRefs,
      onMapChange: setTabPanelMap,
      children: element
    })
  });
});
if (true) TabsRoot.displayName = "TabsRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/tab/TabsTab.js
var React4 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/composite/constants.js
var ACTIVE_COMPOSITE_ITEM = "data-composite-item-active";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/list/TabsListContext.js
var React3 = __toESM(require_react(), 1);
var TabsListContext = React3.createContext(void 0);
if (true) TabsListContext.displayName = "TabsListContext";
function useTabsListContext() {
  const context = React3.useContext(TabsListContext);
  if (context === void 0) {
    throw new Error("Base UI: TabsListContext is missing. TabsList parts must be placed within <Tabs.List>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/tab/TabsTab.js
var TabsTab = React4.forwardRef(function TabsTab2(componentProps, forwardedRef) {
  const {
    className,
    disabled = false,
    render,
    value: valueProp,
    id: idProp,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    value: selectedTabValue,
    getTabPanelIdByTabValueOrIndex,
    orientation
  } = useTabsRootContext();
  const {
    activateOnFocus,
    highlightedTabIndex,
    onTabActivation,
    setHighlightedTabIndex,
    tabsListRef
  } = useTabsListContext();
  const id = useBaseUiId(idProp);
  const tabMetadata = React4.useMemo(() => ({
    disabled,
    id,
    value: valueProp
  }), [disabled, id, valueProp]);
  const {
    compositeProps,
    compositeRef,
    index
    // hook is used instead of the CompositeItem component
    // because the index is needed for Tab internals
  } = useCompositeItem({
    metadata: tabMetadata
  });
  const tabValue = valueProp ?? index;
  const selected = React4.useMemo(() => {
    if (valueProp === void 0) {
      return index < 0 ? false : index === selectedTabValue;
    }
    return valueProp === selectedTabValue;
  }, [index, selectedTabValue, valueProp]);
  const isNavigatingRef = React4.useRef(false);
  useIsoLayoutEffect(() => {
    if (isNavigatingRef.current) {
      isNavigatingRef.current = false;
      return;
    }
    if (!(selected && index > -1 && highlightedTabIndex !== index)) {
      return;
    }
    const listElement = tabsListRef.current;
    const activeEl = activeElement(ownerDocument(listElement));
    if (listElement && activeEl && contains(listElement, activeEl)) {
      return;
    }
    setHighlightedTabIndex(index);
  }, [selected, index, highlightedTabIndex, setHighlightedTabIndex, disabled, tabsListRef]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton,
    focusableWhenDisabled: true
  });
  const tabPanelId = index > -1 ? getTabPanelIdByTabValueOrIndex(valueProp, index) : void 0;
  const isPressingRef = React4.useRef(false);
  const isMainButtonRef = React4.useRef(false);
  const onClick = useEventCallback((event) => {
    if (selected || disabled) {
      return;
    }
    onTabActivation(tabValue, createChangeEventDetails("none", event.nativeEvent, {
      activationDirection: "none"
    }));
  });
  const onFocus = useEventCallback((event) => {
    if (selected) {
      return;
    }
    if (index > -1) {
      setHighlightedTabIndex(index);
    }
    if (disabled) {
      return;
    }
    if (activateOnFocus && !isPressingRef.current || // keyboard or touch focus
    isPressingRef.current && isMainButtonRef.current) {
      onTabActivation(tabValue, createChangeEventDetails("none", event.nativeEvent, {
        activationDirection: "none"
      }));
    }
  });
  const onPointerDown = useEventCallback((event) => {
    if (selected || disabled) {
      return;
    }
    isPressingRef.current = true;
    function handlePointerUp() {
      isPressingRef.current = false;
      isMainButtonRef.current = false;
    }
    if (!event.button || event.button === 0) {
      isMainButtonRef.current = true;
      const doc = ownerDocument(event.currentTarget);
      doc.addEventListener("pointerup", handlePointerUp, {
        once: true
      });
    }
  });
  const state = React4.useMemo(() => ({
    disabled,
    selected,
    orientation
  }), [disabled, selected, orientation]);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, buttonRef, compositeRef],
    props: [compositeProps, {
      role: "tab",
      "aria-controls": tabPanelId,
      "aria-selected": selected,
      id,
      onClick,
      onFocus,
      onPointerDown,
      [ACTIVE_COMPOSITE_ITEM]: selected ? "" : void 0,
      onKeyDownCapture() {
        isNavigatingRef.current = true;
      }
    }, elementProps, getButtonProps]
  });
  return element;
});
if (true) TabsTab.displayName = "TabsTab";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/indicator/TabsIndicator.js
var React6 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+utils@0.1.2_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/utils/esm/useForcedRerendering.js
var React5 = __toESM(require_react());
function useForcedRerendering() {
  const [, setState] = React5.useState({});
  return React5.useCallback(() => {
    setState({});
  }, []);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/indicator/prehydrationScript.min.js
var script = '!function(){const t=document.currentScript.previousElementSibling;if(!t)return;const e=t.closest(\'[role="tablist"]\');if(!e)return;const o=e.querySelector("[data-selected]");if(!o)return;if(0===o.offsetWidth||0===e.offsetWidth)return;const i=getComputedStyle(e).direction,f=o.offsetLeft-e.clientLeft,{width:n,height:r}=o.getBoundingClientRect(),l=Math.floor(n),c=Math.floor(r),s="ltr"===i?e.scrollWidth-o.offsetLeft-l-e.clientLeft:o.offsetLeft-e.clientLeft,h=o.offsetTop-e.clientTop,d=e.scrollHeight-o.offsetTop-c-e.clientTop;function u(e,o){t.style.setProperty(`--active-tab-${e}`,`${o}px`)}u("left",f),u("right",s),u("top",h),u("bottom",d),u("width",l),u("height",c),l>0&&c>0&&t.removeAttribute("hidden")}();';

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/indicator/TabsIndicatorCssVars.js
var TabsIndicatorCssVars = (function(TabsIndicatorCssVars2) {
  TabsIndicatorCssVars2["activeTabLeft"] = "--active-tab-left";
  TabsIndicatorCssVars2["activeTabRight"] = "--active-tab-right";
  TabsIndicatorCssVars2["activeTabTop"] = "--active-tab-top";
  TabsIndicatorCssVars2["activeTabBottom"] = "--active-tab-bottom";
  TabsIndicatorCssVars2["activeTabWidth"] = "--active-tab-width";
  TabsIndicatorCssVars2["activeTabHeight"] = "--active-tab-height";
  return TabsIndicatorCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/indicator/TabsIndicator.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping = {
  ...tabsStateAttributesMapping,
  selectedTabPosition: () => null,
  selectedTabSize: () => null
};
var TabsIndicator = React6.forwardRef(function TabIndicator(componentProps, forwardedRef) {
  const {
    className,
    render,
    renderBeforeHydration = false,
    ...elementProps
  } = componentProps;
  const {
    getTabElementBySelectedValue,
    orientation,
    tabActivationDirection,
    value
  } = useTabsRootContext();
  const {
    tabsListRef
  } = useTabsListContext();
  const [instanceId] = React6.useState(() => generateId("tab"));
  const [isMounted, setIsMounted] = React6.useState(false);
  const {
    value: activeTabValue
  } = useTabsRootContext();
  const direction = useDirection();
  useOnMount(() => setIsMounted(true));
  const rerender = useForcedRerendering();
  React6.useEffect(() => {
    if (value != null && tabsListRef.current != null && typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(() => {
        rerender();
      });
      resizeObserver.observe(tabsListRef.current);
      return () => {
        resizeObserver.disconnect();
      };
    }
    return void 0;
  }, [value, tabsListRef, rerender]);
  let left = 0;
  let right = 0;
  let top = 0;
  let bottom = 0;
  let width = 0;
  let height = 0;
  let isTabSelected = false;
  if (value != null && tabsListRef.current != null) {
    const selectedTab = getTabElementBySelectedValue(value);
    const tabsList = tabsListRef.current;
    isTabSelected = true;
    if (selectedTab != null) {
      left = selectedTab.offsetLeft - tabsList.clientLeft;
      top = selectedTab.offsetTop - tabsList.clientTop;
      const {
        width: rectWidth,
        height: rectHeight
      } = selectedTab.getBoundingClientRect();
      width = Math.floor(rectWidth);
      height = Math.floor(rectHeight);
      right = direction === "ltr" ? tabsList.scrollWidth - selectedTab.offsetLeft - width - tabsList.clientLeft : selectedTab.offsetLeft - tabsList.clientLeft;
      bottom = tabsList.scrollHeight - selectedTab.offsetTop - height - tabsList.clientTop;
    }
  }
  const selectedTabPosition = React6.useMemo(() => isTabSelected ? {
    left,
    right,
    top,
    bottom
  } : null, [left, right, top, bottom, isTabSelected]);
  const selectedTabSize = React6.useMemo(() => isTabSelected ? {
    width,
    height
  } : null, [width, height, isTabSelected]);
  const style = React6.useMemo(() => {
    if (!isTabSelected) {
      return void 0;
    }
    return {
      [TabsIndicatorCssVars.activeTabLeft]: `${left}px`,
      [TabsIndicatorCssVars.activeTabRight]: `${right}px`,
      [TabsIndicatorCssVars.activeTabTop]: `${top}px`,
      [TabsIndicatorCssVars.activeTabBottom]: `${bottom}px`,
      [TabsIndicatorCssVars.activeTabWidth]: `${width}px`,
      [TabsIndicatorCssVars.activeTabHeight]: `${height}px`
    };
  }, [left, right, top, bottom, width, height, isTabSelected]);
  const displayIndicator = isTabSelected && width > 0 && height > 0;
  const state = React6.useMemo(() => ({
    orientation,
    selectedTabPosition,
    selectedTabSize,
    tabActivationDirection
  }), [orientation, selectedTabPosition, selectedTabSize, tabActivationDirection]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      role: "presentation",
      style,
      hidden: !displayIndicator
      // do not display the indicator before the layout is settled
    }, elementProps, {
      ["data-instance-id"]: !(isMounted && renderBeforeHydration) ? instanceId : void 0,
      suppressHydrationWarning: true
    }],
    stateAttributesMapping
  });
  if (activeTabValue == null) {
    return null;
  }
  return (0, import_jsx_runtime2.jsxs)(React6.Fragment, {
    children: [element, !isMounted && renderBeforeHydration && (0, import_jsx_runtime2.jsx)("script", {
      // eslint-disable-next-line react/no-danger
      dangerouslySetInnerHTML: {
        __html: script
      },
      suppressHydrationWarning: true
    })]
  });
});
if (true) TabsIndicator.displayName = "TabsIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/panel/TabsPanel.js
var React7 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/panel/TabsPanelDataAttributes.js
var TabsPanelDataAttributes = (function(TabsPanelDataAttributes2) {
  TabsPanelDataAttributes2["index"] = "data-index";
  TabsPanelDataAttributes2["activationDirection"] = "data-activation-direction";
  TabsPanelDataAttributes2["orientation"] = "data-orientation";
  TabsPanelDataAttributes2["hidden"] = "data-hidden";
  return TabsPanelDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/panel/TabsPanel.js
var TabsPanel = React7.forwardRef(function TabPanel(componentProps, forwardedRef) {
  const {
    children,
    className,
    value: valueProp,
    render,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const {
    value: selectedValue,
    getTabIdByPanelValueOrIndex,
    orientation,
    tabActivationDirection
  } = useTabsRootContext();
  const id = useBaseUiId();
  const metadata = React7.useMemo(() => ({
    id,
    value: valueProp
  }), [id, valueProp]);
  const {
    ref: listItemRef,
    index
  } = useCompositeListItem({
    metadata
  });
  const tabPanelValue = valueProp ?? index;
  const hidden = tabPanelValue !== selectedValue;
  const correspondingTabId = React7.useMemo(() => {
    return getTabIdByPanelValueOrIndex(valueProp, index);
  }, [getTabIdByPanelValueOrIndex, index, valueProp]);
  const state = React7.useMemo(() => ({
    hidden,
    orientation,
    tabActivationDirection
  }), [hidden, orientation, tabActivationDirection]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, listItemRef],
    props: [{
      "aria-labelledby": correspondingTabId,
      hidden,
      id: id ?? void 0,
      role: "tabpanel",
      tabIndex: hidden ? -1 : 0,
      [TabsPanelDataAttributes.index]: index
    }, elementProps, {
      children: hidden && !keepMounted ? void 0 : children
    }],
    stateAttributesMapping: tabsStateAttributesMapping
  });
  return element;
});
if (true) TabsPanel.displayName = "TabsPanel";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/list/TabsList.js
var React10 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/composite/root/CompositeRoot.js
var React9 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/composite/root/useCompositeRoot.js
var React8 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+utils@0.1.2_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/utils/esm/isElementDisabled.js
function isElementDisabled(element) {
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/composite/root/useCompositeRoot.js
var EMPTY_ARRAY2 = [];
function useCompositeRoot(params) {
  const {
    itemSizes,
    cols = 1,
    loop = true,
    dense = false,
    orientation = "both",
    direction,
    highlightedIndex: externalHighlightedIndex,
    onHighlightedIndexChange: externalSetHighlightedIndex,
    rootRef: externalRef,
    enableHomeAndEndKeys = false,
    stopEventPropagation = false,
    disabledIndices,
    modifierKeys = EMPTY_ARRAY2
  } = params;
  const [internalHighlightedIndex, internalSetHighlightedIndex] = React8.useState(0);
  const isGrid = cols > 1;
  const rootRef = React8.useRef(null);
  const mergedRef = useMergedRefs(rootRef, externalRef);
  const elementsRef = React8.useRef([]);
  const hasSetDefaultIndexRef = React8.useRef(false);
  const highlightedIndex = externalHighlightedIndex ?? internalHighlightedIndex;
  const onHighlightedIndexChange = useEventCallback((index, shouldScrollIntoView = false) => {
    (externalSetHighlightedIndex ?? internalSetHighlightedIndex)(index);
    if (shouldScrollIntoView) {
      const newActiveItem = elementsRef.current[index];
      scrollIntoViewIfNeeded(rootRef.current, newActiveItem, direction, orientation);
    }
  });
  const onMapChange = useEventCallback((map) => {
    if (map.size === 0 || hasSetDefaultIndexRef.current) {
      return;
    }
    hasSetDefaultIndexRef.current = true;
    const sortedElements = Array.from(map.keys());
    const activeItem = sortedElements.find((compositeElement) => compositeElement == null ? void 0 : compositeElement.hasAttribute(ACTIVE_COMPOSITE_ITEM)) ?? null;
    const activeIndex = activeItem ? sortedElements.indexOf(activeItem) : -1;
    if (activeIndex !== -1) {
      onHighlightedIndexChange(activeIndex);
    }
    scrollIntoViewIfNeeded(rootRef.current, activeItem, direction, orientation);
  });
  const props = React8.useMemo(() => ({
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    ref: mergedRef,
    onFocus(event) {
      const element = rootRef.current;
      if (!element || !isNativeInput(event.target)) {
        return;
      }
      event.target.setSelectionRange(0, event.target.value.length ?? 0);
    },
    onKeyDown(event) {
      const RELEVANT_KEYS = enableHomeAndEndKeys ? ALL_KEYS : ARROW_KEYS;
      if (!RELEVANT_KEYS.has(event.key)) {
        return;
      }
      if (isModifierKeySet(event, modifierKeys)) {
        return;
      }
      const element = rootRef.current;
      if (!element) {
        return;
      }
      const isRtl = direction === "rtl";
      const horizontalForwardKey = isRtl ? ARROW_LEFT : ARROW_RIGHT;
      const forwardKey = {
        horizontal: horizontalForwardKey,
        vertical: ARROW_DOWN,
        both: horizontalForwardKey
      }[orientation];
      const horizontalBackwardKey = isRtl ? ARROW_RIGHT : ARROW_LEFT;
      const backwardKey = {
        horizontal: horizontalBackwardKey,
        vertical: ARROW_UP,
        both: horizontalBackwardKey
      }[orientation];
      if (isNativeInput(event.target) && !isElementDisabled(event.target)) {
        const selectionStart = event.target.selectionStart;
        const selectionEnd = event.target.selectionEnd;
        const textContent = event.target.value ?? "";
        if (selectionStart == null || event.shiftKey || selectionStart !== selectionEnd) {
          return;
        }
        if (event.key !== backwardKey && selectionStart < textContent.length) {
          return;
        }
        if (event.key !== forwardKey && selectionStart > 0) {
          return;
        }
      }
      let nextIndex = highlightedIndex;
      const minIndex = getMinListIndex(elementsRef, disabledIndices);
      const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
      if (isGrid) {
        const sizes = itemSizes || Array.from({
          length: elementsRef.current.length
        }, () => ({
          width: 1,
          height: 1
        }));
        const cellMap = createGridCellMap(sizes, cols, dense);
        const minGridIndex = cellMap.findIndex((index) => index != null && !isListIndexDisabled(elementsRef, index, disabledIndices));
        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isListIndexDisabled(elementsRef, index, disabledIndices) ? cellIndex : foundIndex, -1);
        nextIndex = cellMap[getGridNavigatedIndex({
          current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
        }, {
          event,
          orientation,
          loop,
          cols,
          // treat undefined (empty grid spaces) as disabled indices so we
          // don't end up in them
          disabledIndices: getGridCellIndices([...disabledIndices || elementsRef.current.map((_, index) => isListIndexDisabled(elementsRef, index) ? index : void 0), void 0], cellMap),
          minIndex: minGridIndex,
          maxIndex: maxGridIndex,
          prevIndex: getGridCellIndexOfCorner(
            highlightedIndex > maxIndex ? minIndex : highlightedIndex,
            sizes,
            cellMap,
            cols,
            // use a corner matching the edge closest to the direction we're
            // moving in so we don't end up in the same item. Prefer
            // top/left over bottom/right.
            // eslint-disable-next-line no-nested-ternary
            event.key === ARROW_DOWN ? "bl" : event.key === ARROW_RIGHT ? "tr" : "tl"
          ),
          rtl: isRtl
        })];
      }
      const forwardKeys = {
        horizontal: [horizontalForwardKey],
        vertical: [ARROW_DOWN],
        both: [horizontalForwardKey, ARROW_DOWN]
      }[orientation];
      const backwardKeys = {
        horizontal: [horizontalBackwardKey],
        vertical: [ARROW_UP],
        both: [horizontalBackwardKey, ARROW_UP]
      }[orientation];
      const preventedKeys = isGrid ? RELEVANT_KEYS : {
        horizontal: enableHomeAndEndKeys ? HORIZONTAL_KEYS_WITH_EXTRA_KEYS : HORIZONTAL_KEYS,
        vertical: enableHomeAndEndKeys ? VERTICAL_KEYS_WITH_EXTRA_KEYS : VERTICAL_KEYS,
        both: RELEVANT_KEYS
      }[orientation];
      if (enableHomeAndEndKeys) {
        if (event.key === HOME) {
          nextIndex = minIndex;
        } else if (event.key === END) {
          nextIndex = maxIndex;
        }
      }
      if (nextIndex === highlightedIndex && (forwardKeys.includes(event.key) || backwardKeys.includes(event.key))) {
        if (loop && nextIndex === maxIndex && forwardKeys.includes(event.key)) {
          nextIndex = minIndex;
        } else if (loop && nextIndex === minIndex && backwardKeys.includes(event.key)) {
          nextIndex = maxIndex;
        } else {
          nextIndex = findNonDisabledListIndex(elementsRef, {
            startingIndex: nextIndex,
            decrement: backwardKeys.includes(event.key),
            disabledIndices
          });
        }
      }
      if (nextIndex !== highlightedIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
        if (stopEventPropagation) {
          event.stopPropagation();
        }
        if (preventedKeys.has(event.key)) {
          event.preventDefault();
        }
        onHighlightedIndexChange(nextIndex, true);
        queueMicrotask(() => {
          var _a;
          (_a = elementsRef.current[nextIndex]) == null ? void 0 : _a.focus();
        });
      }
    }
  }), [cols, dense, direction, disabledIndices, elementsRef, enableHomeAndEndKeys, highlightedIndex, isGrid, itemSizes, loop, mergedRef, modifierKeys, onHighlightedIndexChange, orientation, stopEventPropagation]);
  return React8.useMemo(() => ({
    props,
    highlightedIndex,
    onHighlightedIndexChange,
    elementsRef,
    disabledIndices,
    onMapChange
  }), [props, highlightedIndex, onHighlightedIndexChange, elementsRef, disabledIndices, onMapChange]);
}
function isModifierKeySet(event, ignoredModifierKeys) {
  for (const key of MODIFIER_KEYS.values()) {
    if (ignoredModifierKeys.includes(key)) {
      continue;
    }
    if (event.getModifierState(key)) {
      return true;
    }
  }
  return false;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/composite/root/CompositeRoot.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function CompositeRoot(componentProps) {
  const {
    render,
    className,
    refs = EMPTY_ARRAY,
    props = EMPTY_ARRAY,
    state = EMPTY_OBJECT,
    stateAttributesMapping: stateAttributesMapping2,
    highlightedIndex: highlightedIndexProp,
    onHighlightedIndexChange: onHighlightedIndexChangeProp,
    orientation,
    dense,
    itemSizes,
    loop,
    cols,
    enableHomeAndEndKeys,
    onMapChange: onMapChangeProp,
    stopEventPropagation = true,
    rootRef,
    disabledIndices,
    modifierKeys,
    highlightItemOnHover = false,
    tag = "div",
    ...elementProps
  } = componentProps;
  const direction = useDirection();
  const {
    props: defaultProps,
    highlightedIndex,
    onHighlightedIndexChange,
    elementsRef,
    onMapChange: onMapChangeUnwrapped
  } = useCompositeRoot({
    itemSizes,
    cols,
    loop,
    dense,
    orientation,
    highlightedIndex: highlightedIndexProp,
    onHighlightedIndexChange: onHighlightedIndexChangeProp,
    rootRef,
    stopEventPropagation,
    enableHomeAndEndKeys,
    direction,
    disabledIndices,
    modifierKeys
  });
  const onMapChange = useEventCallback((newMap) => {
    onMapChangeProp == null ? void 0 : onMapChangeProp(newMap);
    onMapChangeUnwrapped(newMap);
  });
  const element = useRenderElement(tag, componentProps, {
    state,
    ref: refs,
    props: [defaultProps, ...props, elementProps],
    stateAttributesMapping: stateAttributesMapping2
  });
  const contextValue = React9.useMemo(() => ({
    highlightedIndex,
    onHighlightedIndexChange,
    highlightItemOnHover
  }), [highlightedIndex, onHighlightedIndexChange, highlightItemOnHover]);
  return (0, import_jsx_runtime3.jsx)(CompositeRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime3.jsx)(CompositeList, {
      elementsRef,
      onMapChange,
      children: element
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tabs/list/TabsList.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var EMPTY_ARRAY3 = [];
var TabsList = React10.forwardRef(function TabsList2(componentProps, forwardedRef) {
  const {
    activateOnFocus = true,
    className,
    loop = true,
    render,
    ...elementProps
  } = componentProps;
  const {
    getTabElementBySelectedValue,
    onValueChange,
    orientation,
    value,
    setTabMap,
    tabActivationDirection
  } = useTabsRootContext();
  const [highlightedTabIndex, setHighlightedTabIndex] = React10.useState(0);
  const tabsListRef = React10.useRef(null);
  const detectActivationDirection = useActivationDirectionDetector(
    value,
    // the old value
    orientation,
    tabsListRef,
    getTabElementBySelectedValue
  );
  const onTabActivation = useEventCallback((newValue, eventDetails) => {
    if (newValue !== value) {
      const activationDirection = detectActivationDirection(newValue);
      eventDetails.activationDirection = activationDirection;
      onValueChange(newValue, eventDetails);
    }
  });
  const state = React10.useMemo(() => ({
    orientation,
    tabActivationDirection
  }), [orientation, tabActivationDirection]);
  const defaultProps = {
    "aria-orientation": orientation === "vertical" ? "vertical" : void 0,
    role: "tablist"
  };
  const tabsListContextValue = React10.useMemo(() => ({
    activateOnFocus,
    highlightedTabIndex,
    onTabActivation,
    setHighlightedTabIndex,
    tabsListRef,
    value
  }), [activateOnFocus, highlightedTabIndex, onTabActivation, setHighlightedTabIndex, tabsListRef, value]);
  return (0, import_jsx_runtime4.jsx)(TabsListContext.Provider, {
    value: tabsListContextValue,
    children: (0, import_jsx_runtime4.jsx)(CompositeRoot, {
      render,
      className,
      state,
      refs: [forwardedRef, tabsListRef],
      props: [defaultProps, elementProps],
      stateAttributesMapping: tabsStateAttributesMapping,
      highlightedIndex: highlightedTabIndex,
      enableHomeAndEndKeys: true,
      loop,
      orientation,
      onHighlightedIndexChange: setHighlightedTabIndex,
      onMapChange: setTabMap,
      disabledIndices: EMPTY_ARRAY3
    })
  });
});
if (true) TabsList.displayName = "TabsList";
function getInset(tab, tabsList) {
  const {
    left: tabLeft,
    top: tabTop
  } = tab.getBoundingClientRect();
  const {
    left: listLeft,
    top: listTop
  } = tabsList.getBoundingClientRect();
  const left = tabLeft - listLeft;
  const top = tabTop - listTop;
  return {
    left,
    top
  };
}
function useActivationDirectionDetector(selectedTabValue, orientation, tabsListRef, getTabElement) {
  const previousTabEdge = React10.useRef(null);
  useIsoLayoutEffect(() => {
    if (selectedTabValue == null || tabsListRef.current == null) {
      previousTabEdge.current = null;
      return;
    }
    const activeTab = getTabElement(selectedTabValue);
    if (activeTab == null) {
      previousTabEdge.current = null;
      return;
    }
    const {
      left,
      top
    } = getInset(activeTab, tabsListRef.current);
    previousTabEdge.current = orientation === "horizontal" ? left : top;
  }, [orientation, getTabElement, tabsListRef, selectedTabValue]);
  return React10.useCallback((newValue) => {
    if (newValue === selectedTabValue) {
      return "none";
    }
    if (newValue == null) {
      previousTabEdge.current = null;
      return "none";
    }
    if (newValue != null && tabsListRef.current != null) {
      const selectedTabElement = getTabElement(newValue);
      if (selectedTabElement != null) {
        const {
          left,
          top
        } = getInset(selectedTabElement, tabsListRef.current);
        if (previousTabEdge.current == null) {
          previousTabEdge.current = orientation === "horizontal" ? left : top;
          return "none";
        }
        if (orientation === "horizontal") {
          if (left < previousTabEdge.current) {
            previousTabEdge.current = left;
            return "left";
          }
          if (left > previousTabEdge.current) {
            previousTabEdge.current = left;
            return "right";
          }
        } else if (top < previousTabEdge.current) {
          previousTabEdge.current = top;
          return "up";
        } else if (top > previousTabEdge.current) {
          previousTabEdge.current = top;
          return "down";
        }
      }
    }
    return "none";
  }, [getTabElement, orientation, previousTabEdge, tabsListRef, selectedTabValue]);
}

export {
  isElementDisabled,
  ACTIVE_COMPOSITE_ITEM,
  CompositeRoot,
  useForcedRerendering,
  index_parts_exports
};
//# sourceMappingURL=chunk-ZQKMLMJI.js.map
