import {
  useTimeout
} from "./chunk-ZDUACO7A.js";
import {
  useLatestRef
} from "./chunk-E6E6BQH7.js";
import {
  useEventCallback
} from "./chunk-5VFA47B3.js";
import {
  NOOP,
  mergeProps,
  useIsoLayoutEffect
} from "./chunk-BNCDMTRQ.js";
import {
  require_react_dom
} from "./chunk-SXRIVT2P.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/control/FieldControlDataAttributes.js
var FieldControlDataAttributes = (function(FieldControlDataAttributes2) {
  FieldControlDataAttributes2["disabled"] = "data-disabled";
  FieldControlDataAttributes2["valid"] = "data-valid";
  FieldControlDataAttributes2["invalid"] = "data-invalid";
  FieldControlDataAttributes2["touched"] = "data-touched";
  FieldControlDataAttributes2["dirty"] = "data-dirty";
  FieldControlDataAttributes2["filled"] = "data-filled";
  FieldControlDataAttributes2["focused"] = "data-focused";
  return FieldControlDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/utils/constants.js
var DEFAULT_VALIDITY_STATE = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: null,
  valueMissing: false
};
var fieldValidityMapping = {
  valid(value) {
    if (value === null) {
      return null;
    }
    if (value) {
      return {
        [FieldControlDataAttributes.valid]: ""
      };
    }
    return {
      [FieldControlDataAttributes.invalid]: ""
    };
  }
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/root/FieldRootContext.js
var React = __toESM(require_react(), 1);
var FieldRootContext = React.createContext({
  invalid: void 0,
  controlId: void 0,
  setControlId: NOOP,
  labelId: void 0,
  setLabelId: NOOP,
  messageIds: [],
  setMessageIds: NOOP,
  name: void 0,
  validityData: {
    state: DEFAULT_VALIDITY_STATE,
    errors: [],
    error: "",
    value: "",
    initialValue: null
  },
  setValidityData: NOOP,
  disabled: void 0,
  touched: false,
  setTouched: NOOP,
  dirty: false,
  setDirty: NOOP,
  filled: false,
  setFilled: NOOP,
  focused: false,
  setFocused: NOOP,
  validate: () => null,
  validationMode: "onBlur",
  validationDebounceTime: 0,
  state: {
    disabled: false,
    valid: null,
    touched: false,
    dirty: false,
    filled: false,
    focused: false
  },
  markedDirtyRef: {
    current: false
  }
});
if (true) FieldRootContext.displayName = "FieldRootContext";
function useFieldRootContext(optional = true) {
  const context = React.useContext(FieldRootContext);
  if (context.setControlId === NOOP && !optional) {
    throw new Error("Base UI: FieldRootContext is missing. Field parts must be placed within <Field.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/form/FormContext.js
var React2 = __toESM(require_react(), 1);
var FormContext = React2.createContext({
  formRef: {
    current: {
      fields: /* @__PURE__ */ new Map()
    }
  },
  errors: {},
  clearErrors: NOOP
});
if (true) FormContext.displayName = "FormContext";
function useFormContext() {
  return React2.useContext(FormContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/control/useFieldControlValidation.js
var React3 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/utils/getCombinedFieldValidityData.js
function getCombinedFieldValidityData(validityData, invalid) {
  return {
    ...validityData,
    state: {
      ...validityData.state,
      valid: !invalid && validityData.state.valid
    }
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/control/useFieldControlValidation.js
var validityKeys = Object.keys(DEFAULT_VALIDITY_STATE);
function isOnlyValueMissing(state) {
  if (!state || state.valid || !state.valueMissing) {
    return false;
  }
  let onlyValueMissing = false;
  for (const key of validityKeys) {
    if (key === "valid") {
      continue;
    }
    if (key === "valueMissing") {
      onlyValueMissing = state[key];
    }
    if (state[key]) {
      onlyValueMissing = false;
    }
  }
  return onlyValueMissing;
}
function useFieldControlValidation() {
  const {
    setValidityData,
    validate,
    messageIds,
    validityData,
    validationMode,
    validationDebounceTime,
    invalid,
    markedDirtyRef,
    controlId,
    state,
    name
  } = useFieldRootContext();
  const {
    formRef,
    clearErrors
  } = useFormContext();
  const timeout = useTimeout();
  const inputRef = React3.useRef(null);
  const commitValidation = useEventCallback(async (value, revalidate = false) => {
    const element = inputRef.current;
    if (!element) {
      return;
    }
    if (revalidate) {
      if (state.valid !== false) {
        return;
      }
      const currentNativeValidity = element.validity;
      if (!currentNativeValidity.valueMissing) {
        const nextValidityData2 = {
          value,
          state: {
            ...DEFAULT_VALIDITY_STATE,
            valid: true
          },
          error: "",
          errors: [],
          initialValue: validityData.initialValue
        };
        element.setCustomValidity("");
        if (controlId) {
          const currentFieldData = formRef.current.fields.get(controlId);
          if (currentFieldData) {
            formRef.current.fields.set(controlId, {
              ...currentFieldData,
              ...getCombinedFieldValidityData(nextValidityData2, false)
              // invalid = false
            });
          }
        }
        setValidityData(nextValidityData2);
        return;
      }
      const currentNativeValidityObject = validityKeys.reduce((acc, key) => {
        acc[key] = currentNativeValidity[key];
        return acc;
      }, {});
      if (!currentNativeValidityObject.valid && !isOnlyValueMissing(currentNativeValidityObject)) {
        return;
      }
    }
    function getState(el) {
      const computedState = validityKeys.reduce((acc, key) => {
        acc[key] = el.validity[key];
        return acc;
      }, {});
      let hasOnlyValueMissingError = false;
      for (const key of validityKeys) {
        if (key === "valid") {
          continue;
        }
        if (key === "valueMissing" && computedState[key]) {
          hasOnlyValueMissingError = true;
        } else if (computedState[key]) {
          return computedState;
        }
      }
      if (hasOnlyValueMissingError && !markedDirtyRef.current) {
        computedState.valid = true;
        computedState.valueMissing = false;
      }
      return computedState;
    }
    timeout.clear();
    let result = null;
    let validationErrors = [];
    const nextState = getState(element);
    let defaultValidationMessage;
    if (element.validationMessage) {
      defaultValidationMessage = element.validationMessage;
      validationErrors = [element.validationMessage];
    } else {
      const formValues = Array.from(formRef.current.fields.values()).reduce((acc, field) => {
        var _a, _b;
        if (field.name && field.getValueRef) {
          acc[field.name] = (_b = (_a = field.getValueRef).current) == null ? void 0 : _b.call(_a);
        }
        return acc;
      }, {});
      const resultOrPromise = validate(value, formValues);
      if (typeof resultOrPromise === "object" && resultOrPromise !== null && "then" in resultOrPromise) {
        result = await resultOrPromise;
      } else {
        result = resultOrPromise;
      }
      if (result !== null) {
        nextState.valid = false;
        nextState.customError = true;
        if (Array.isArray(result)) {
          validationErrors = result;
          element.setCustomValidity(result.join("\n"));
        } else if (result) {
          validationErrors = [result];
          element.setCustomValidity(result);
        }
      }
    }
    const nextValidityData = {
      value,
      state: nextState,
      error: defaultValidationMessage ?? (Array.isArray(result) ? result[0] : result ?? ""),
      errors: validationErrors,
      initialValue: validityData.initialValue
    };
    if (controlId) {
      const currentFieldData = formRef.current.fields.get(controlId);
      if (currentFieldData) {
        formRef.current.fields.set(controlId, {
          ...currentFieldData,
          ...getCombinedFieldValidityData(nextValidityData, invalid)
        });
      }
    }
    setValidityData(nextValidityData);
  });
  const getValidationProps = React3.useCallback((externalProps = {}) => mergeProps({
    ...messageIds.length && {
      "aria-describedby": messageIds.join(" ")
    },
    ...state.valid === false && {
      "aria-invalid": true
    }
  }, externalProps), [messageIds, state.valid]);
  const getInputValidationProps = React3.useCallback((externalProps = {}) => mergeProps({
    onChange(event) {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      clearErrors(name);
      if (validationMode !== "onChange") {
        commitValidation(event.currentTarget.value, true);
        return;
      }
      if (invalid) {
        return;
      }
      const element = event.currentTarget;
      if (element.value === "") {
        commitValidation(element.value);
        return;
      }
      timeout.clear();
      if (validationDebounceTime) {
        timeout.start(validationDebounceTime, () => {
          commitValidation(element.value);
        });
      } else {
        commitValidation(element.value);
      }
    }
  }, getValidationProps(externalProps)), [getValidationProps, clearErrors, name, timeout, commitValidation, invalid, validationMode, validationDebounceTime]);
  return React3.useMemo(() => ({
    getValidationProps,
    getInputValidationProps,
    inputRef,
    commitValidation
  }), [getValidationProps, getInputValidationProps, commitValidation]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/field/useField.js
var ReactDOM = __toESM(require_react_dom(), 1);
function useField(params) {
  const {
    formRef
  } = useFormContext();
  const {
    invalid,
    markedDirtyRef,
    validityData,
    setValidityData
  } = useFieldRootContext();
  const {
    enabled = true,
    value,
    id,
    name,
    controlRef,
    commitValidation
  } = params;
  const getValueRef = useLatestRef(params.getValue);
  useIsoLayoutEffect(() => {
    var _a;
    if (!enabled) {
      return;
    }
    let initialValue = value;
    if (initialValue === void 0) {
      initialValue = (_a = getValueRef.current) == null ? void 0 : _a.call(getValueRef);
    }
    if (validityData.initialValue === null && initialValue !== validityData.initialValue) {
      setValidityData((prev) => ({
        ...prev,
        initialValue
      }));
    }
  }, [enabled, setValidityData, value, validityData.initialValue, getValueRef]);
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return;
    }
    if (id) {
      formRef.current.fields.set(id, {
        controlRef,
        validityData: getCombinedFieldValidityData(validityData, invalid),
        validate() {
          var _a;
          let nextValue = value;
          if (nextValue === void 0) {
            nextValue = (_a = getValueRef.current) == null ? void 0 : _a.call(getValueRef);
          }
          markedDirtyRef.current = true;
          ReactDOM.flushSync(() => commitValidation(nextValue));
        },
        getValueRef,
        name
      });
    }
  }, [commitValidation, controlRef, enabled, formRef, getValueRef, id, invalid, markedDirtyRef, name, validityData, value]);
  useIsoLayoutEffect(() => {
    const fields = formRef.current.fields;
    return () => {
      if (id) {
        fields.delete(id);
      }
    };
  }, [formRef, id]);
}

export {
  DEFAULT_VALIDITY_STATE,
  fieldValidityMapping,
  FieldRootContext,
  useFieldRootContext,
  FormContext,
  useFormContext,
  getCombinedFieldValidityData,
  useFieldControlValidation,
  useField
};
//# sourceMappingURL=chunk-4U56E4CW.js.map
