import {
  FloatingPortalLite
} from "./chunk-Y7GOPZIF.js";
import {
  popupStateMapping,
  triggerOpenStateMapping,
  useAnchorPositioning,
  useTransitionStatus
} from "./chunk-BCPUTI2J.js";
import {
  useControlled
} from "./chunk-NXVU5FCV.js";
import {
  FloatingDelayGroup,
  safePolygon,
  transitionStatusMapping,
  useClientPoint,
  useDelayGroup,
  useDismiss,
  useFloatingRootContext,
  useFocus,
  useHover,
  useInteractions,
  useOpenChangeComplete
} from "./chunk-UAJXLITD.js";
import {
  createChangeEventDetails,
  useEventCallback
} from "./chunk-5VFA47B3.js";
import {
  DISABLED_TRANSITIONS_STYLE,
  EMPTY_OBJECT,
  POPUP_COLLISION_AVOIDANCE,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_react_dom
} from "./chunk-SXRIVT2P.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __export,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Arrow: () => TooltipArrow,
  Popup: () => TooltipPopup,
  Portal: () => TooltipPortal,
  Positioner: () => TooltipPositioner,
  Provider: () => TooltipProvider,
  Root: () => TooltipRoot,
  Trigger: () => TooltipTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/root/TooltipRoot.js
var React3 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/root/TooltipRootContext.js
var React = __toESM(require_react(), 1);
var TooltipRootContext = React.createContext(void 0);
if (true) TooltipRootContext.displayName = "TooltipRootContext";
function useTooltipRootContext() {
  const context = React.useContext(TooltipRootContext);
  if (context === void 0) {
    throw new Error("Base UI: TooltipRootContext is missing. Tooltip parts must be placed within <Tooltip.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/utils/constants.js
var OPEN_DELAY = 600;

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/provider/TooltipProviderContext.js
var React2 = __toESM(require_react(), 1);
var TooltipProviderContext = React2.createContext(void 0);
if (true) TooltipProviderContext.displayName = "TooltipProviderContext";
function useTooltipProviderContext() {
  return React2.useContext(TooltipProviderContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/root/TooltipRoot.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function TooltipRoot(props) {
  const {
    disabled = false,
    defaultOpen = false,
    onOpenChange,
    open: openProp,
    delay,
    closeDelay,
    hoverable = true,
    trackCursorAxis = "none",
    actionsRef,
    onOpenChangeComplete
  } = props;
  const delayWithDefault = delay ?? OPEN_DELAY;
  const closeDelayWithDefault = closeDelay ?? 0;
  const [triggerElement, setTriggerElement] = React3.useState(null);
  const [positionerElement, setPositionerElement] = React3.useState(null);
  const [instantTypeState, setInstantTypeState] = React3.useState();
  const popupRef = React3.useRef(null);
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Tooltip",
    state: "open"
  });
  const open = !disabled && openState;
  function setOpenUnwrapped(nextOpen, eventDetails) {
    const reason = eventDetails.reason;
    const isHover = reason === "trigger-hover";
    const isFocusOpen = nextOpen && reason === "trigger-focus";
    const isDismissClose = !nextOpen && (reason === "trigger-press" || reason === "escape-key");
    onOpenChange == null ? void 0 : onOpenChange(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    function changeState() {
      setOpenState(nextOpen);
    }
    if (isHover) {
      ReactDOM.flushSync(changeState);
    } else {
      changeState();
    }
    if (isFocusOpen || isDismissClose) {
      setInstantTypeState(isFocusOpen ? "focus" : "dismiss");
    } else if (reason === "trigger-hover") {
      setInstantTypeState(void 0);
    }
  }
  const setOpen = useEventCallback(setOpenUnwrapped);
  if (openState && disabled) {
    setOpenUnwrapped(false, createChangeEventDetails("disabled"));
  }
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  const handleUnmount = useEventCallback(() => {
    setMounted(false);
    onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(false);
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  React3.useImperativeHandle(actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  const floatingRootContext = useFloatingRootContext({
    elements: {
      reference: triggerElement,
      floating: positionerElement
    },
    open,
    onOpenChange: setOpen
  });
  const providerContext = useTooltipProviderContext();
  const {
    delayRef,
    isInstantPhase,
    hasProvider
  } = useDelayGroup(floatingRootContext);
  const instantType = isInstantPhase ? "delay" : instantTypeState;
  const hover = useHover(floatingRootContext, {
    enabled: !disabled,
    mouseOnly: true,
    move: false,
    handleClose: hoverable && trackCursorAxis !== "both" ? safePolygon() : null,
    restMs() {
      const providerDelay = providerContext == null ? void 0 : providerContext.delay;
      const groupOpenValue = typeof delayRef.current === "object" ? delayRef.current.open : void 0;
      let computedRestMs = delayWithDefault;
      if (hasProvider) {
        if (groupOpenValue !== 0) {
          computedRestMs = delay ?? providerDelay ?? delayWithDefault;
        } else {
          computedRestMs = 0;
        }
      }
      return computedRestMs;
    },
    delay() {
      const closeValue = typeof delayRef.current === "object" ? delayRef.current.close : void 0;
      let computedCloseDelay = closeDelayWithDefault;
      if (closeDelay == null && hasProvider) {
        computedCloseDelay = closeValue;
      }
      return {
        close: computedCloseDelay
      };
    }
  });
  const focus = useFocus(floatingRootContext, {
    enabled: !disabled
  });
  const dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled,
    referencePress: true
  });
  const clientPoint = useClientPoint(floatingRootContext, {
    enabled: !disabled && trackCursorAxis !== "none",
    axis: trackCursorAxis === "none" ? void 0 : trackCursorAxis
  });
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([hover, focus, dismiss, clientPoint]);
  const tooltipRoot = React3.useMemo(() => ({
    open,
    setOpen,
    mounted,
    setMounted,
    setTriggerElement,
    positionerElement,
    setPositionerElement,
    popupRef,
    triggerProps: getReferenceProps(),
    popupProps: getFloatingProps(),
    floatingRootContext,
    instantType,
    transitionStatus,
    onOpenChangeComplete
  }), [open, setOpen, mounted, setMounted, setTriggerElement, positionerElement, setPositionerElement, popupRef, getReferenceProps, getFloatingProps, floatingRootContext, instantType, transitionStatus, onOpenChangeComplete]);
  const contextValue = React3.useMemo(() => ({
    ...tooltipRoot,
    delay: delayWithDefault,
    closeDelay: closeDelayWithDefault,
    trackCursorAxis,
    hoverable
  }), [tooltipRoot, delayWithDefault, closeDelayWithDefault, trackCursorAxis, hoverable]);
  return (0, import_jsx_runtime.jsx)(TooltipRootContext.Provider, {
    value: contextValue,
    children: props.children
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/trigger/TooltipTrigger.js
var React4 = __toESM(require_react(), 1);
var TooltipTrigger = React4.forwardRef(function TooltipTrigger2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open,
    setTriggerElement,
    triggerProps
  } = useTooltipRootContext();
  const state = React4.useMemo(() => ({
    open
  }), [open]);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, setTriggerElement],
    props: [triggerProps, elementProps],
    stateAttributesMapping: triggerOpenStateMapping
  });
  return element;
});
if (true) TooltipTrigger.displayName = "TooltipTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/portal/TooltipPortal.js
var React6 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/portal/TooltipPortalContext.js
var React5 = __toESM(require_react(), 1);
var TooltipPortalContext = React5.createContext(void 0);
if (true) TooltipPortalContext.displayName = "TooltipPortalContext";
function useTooltipPortalContext() {
  const value = React5.useContext(TooltipPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <Tooltip.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/portal/TooltipPortal.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function TooltipPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    mounted
  } = useTooltipRootContext();
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(TooltipPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime2.jsx)(FloatingPortalLite, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/positioner/TooltipPositioner.js
var React8 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/positioner/TooltipPositionerContext.js
var React7 = __toESM(require_react(), 1);
var TooltipPositionerContext = React7.createContext(void 0);
if (true) TooltipPositionerContext.displayName = "TooltipPositionerContext";
function useTooltipPositionerContext() {
  const context = React7.useContext(TooltipPositionerContext);
  if (context === void 0) {
    throw new Error("Base UI: TooltipPositionerContext is missing. TooltipPositioner parts must be placed within <Tooltip.Positioner>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/positioner/TooltipPositioner.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var TooltipPositioner = React8.forwardRef(function TooltipPositioner2(componentProps, forwardedRef) {
  const {
    render,
    className,
    anchor,
    positionMethod = "absolute",
    side = "top",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = false,
    trackAnchor = true,
    collisionAvoidance = POPUP_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps;
  const {
    open,
    setPositionerElement,
    mounted,
    floatingRootContext,
    trackCursorAxis,
    hoverable
  } = useTooltipRootContext();
  const keepMounted = useTooltipPortalContext();
  const positioning = useAnchorPositioning({
    anchor,
    positionMethod,
    floatingRootContext,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    collisionBoundary,
    collisionPadding,
    sticky,
    arrowPadding,
    trackAnchor,
    keepMounted,
    collisionAvoidance
  });
  const defaultProps = React8.useMemo(() => {
    const hiddenStyles = {};
    if (!open || trackCursorAxis === "both" || !hoverable) {
      hiddenStyles.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioning.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, trackCursorAxis, hoverable, mounted, positioning.positionerStyles]);
  const positioner = React8.useMemo(() => ({
    props: defaultProps,
    ...positioning
  }), [defaultProps, positioning]);
  const state = React8.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    anchorHidden: positioner.anchorHidden
  }), [open, positioner.side, positioner.align, positioner.anchorHidden]);
  const contextValue = React8.useMemo(() => ({
    ...state,
    arrowRef: positioner.arrowRef,
    arrowStyles: positioner.arrowStyles,
    arrowUncentered: positioner.arrowUncentered
  }), [state, positioner.arrowRef, positioner.arrowStyles, positioner.arrowUncentered]);
  const element = useRenderElement("div", componentProps, {
    state,
    props: [positioner.props, elementProps],
    ref: [forwardedRef, setPositionerElement],
    stateAttributesMapping: popupStateMapping
  });
  return (0, import_jsx_runtime3.jsx)(TooltipPositionerContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) TooltipPositioner.displayName = "TooltipPositioner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/popup/TooltipPopup.js
var React9 = __toESM(require_react(), 1);
var stateAttributesMapping = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var TooltipPopup = React9.forwardRef(function TooltipPopup2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open,
    instantType,
    transitionStatus,
    popupProps,
    popupRef,
    onOpenChangeComplete
  } = useTooltipRootContext();
  const {
    side,
    align
  } = useTooltipPositionerContext();
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      if (open) {
        onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(true);
      }
    }
  });
  const state = React9.useMemo(() => ({
    open,
    side,
    align,
    instant: instantType,
    transitionStatus
  }), [open, side, align, instantType, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, popupRef],
    props: [popupProps, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps],
    stateAttributesMapping
  });
  return element;
});
if (true) TooltipPopup.displayName = "TooltipPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/arrow/TooltipArrow.js
var React10 = __toESM(require_react(), 1);
var TooltipArrow = React10.forwardRef(function TooltipArrow2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open,
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = useTooltipPositionerContext();
  const state = React10.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, arrowRef],
    props: [{
      style: arrowStyles,
      "aria-hidden": true
    }, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return element;
});
if (true) TooltipArrow.displayName = "TooltipArrow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/tooltip/provider/TooltipProvider.js
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var TooltipProvider = function TooltipProvider2(props) {
  const {
    delay,
    closeDelay,
    timeout = 400
  } = props;
  const contextValue = React11.useMemo(() => ({
    delay,
    closeDelay
  }), [delay, closeDelay]);
  const delayValue = React11.useMemo(() => ({
    open: delay,
    close: closeDelay
  }), [delay, closeDelay]);
  return (0, import_jsx_runtime4.jsx)(TooltipProviderContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime4.jsx)(FloatingDelayGroup, {
      delay: delayValue,
      timeoutMs: timeout,
      children: props.children
    })
  });
};
if (true) TooltipProvider.displayName = "TooltipProvider";

export {
  index_parts_exports
};
//# sourceMappingURL=chunk-T5BAW6D3.js.map
