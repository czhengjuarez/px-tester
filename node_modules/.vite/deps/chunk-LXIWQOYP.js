import {
  fieldValidityMapping,
  useField,
  useFieldControlValidation,
  useFieldRootContext,
  useFormContext
} from "./chunk-4XXPS7AP.js";
import {
  useBaseUiId
} from "./chunk-EZX2H7FZ.js";
import {
  useButton
} from "./chunk-PODRTBZK.js";
import {
  useControlled
} from "./chunk-NXVU5FCV.js";
import {
  visuallyHidden
} from "./chunk-JLMIKHN4.js";
import {
  createChangeEventDetails,
  useEventCallback
} from "./chunk-5VFA47B3.js";
import {
  mergeProps,
  useIsoLayoutEffect,
  useMergedRefs,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __export,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Root: () => SwitchRoot,
  Thumb: () => SwitchThumb
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/root/SwitchRoot.js
var React2 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/root/SwitchRootContext.js
var React = __toESM(require_react(), 1);
var SwitchRootContext = React.createContext(void 0);
if (true) SwitchRootContext.displayName = "SwitchRootContext";
function useSwitchRootContext() {
  const context = React.useContext(SwitchRootContext);
  if (context === void 0) {
    throw new Error("Base UI: SwitchRootContext is missing. Switch parts must be placed within <Switch.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/root/SwitchRootDataAttributes.js
var SwitchRootDataAttributes = (function(SwitchRootDataAttributes2) {
  SwitchRootDataAttributes2["checked"] = "data-checked";
  SwitchRootDataAttributes2["unchecked"] = "data-unchecked";
  SwitchRootDataAttributes2["disabled"] = "data-disabled";
  SwitchRootDataAttributes2["readonly"] = "data-readonly";
  SwitchRootDataAttributes2["required"] = "data-required";
  SwitchRootDataAttributes2["valid"] = "data-valid";
  SwitchRootDataAttributes2["invalid"] = "data-invalid";
  SwitchRootDataAttributes2["touched"] = "data-touched";
  SwitchRootDataAttributes2["dirty"] = "data-dirty";
  SwitchRootDataAttributes2["filled"] = "data-filled";
  SwitchRootDataAttributes2["focused"] = "data-focused";
  return SwitchRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/stateAttributesMapping.js
var stateAttributesMapping = {
  ...fieldValidityMapping,
  checked(value) {
    if (value) {
      return {
        [SwitchRootDataAttributes.checked]: ""
      };
    }
    return {
      [SwitchRootDataAttributes.unchecked]: ""
    };
  }
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/root/SwitchRoot.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var SwitchRoot = React2.forwardRef(function SwitchRoot2(componentProps, forwardedRef) {
  const {
    checked: checkedProp,
    className,
    defaultChecked,
    id: idProp,
    inputRef: externalInputRef,
    name: nameProp,
    nativeButton = true,
    onCheckedChange: onCheckedChangeProp,
    readOnly = false,
    required = false,
    disabled: disabledProp = false,
    render,
    ...elementProps
  } = componentProps;
  const {
    clearErrors
  } = useFormContext();
  const {
    state: fieldState,
    labelId,
    setControlId,
    setTouched,
    setDirty,
    validityData,
    setFilled,
    setFocused,
    validationMode,
    disabled: fieldDisabled,
    name: fieldName
  } = useFieldRootContext();
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const {
    getValidationProps,
    getInputValidationProps,
    inputRef: inputValidationRef,
    commitValidation
  } = useFieldControlValidation();
  const onCheckedChange = useEventCallback(onCheckedChangeProp);
  const inputRef = React2.useRef(null);
  const handleInputRef = useMergedRefs(inputRef, externalInputRef, inputValidationRef);
  const switchRef = React2.useRef(null);
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    const element2 = switchRef.current;
    if (!element2) {
      return void 0;
    }
    if (element2.closest("label") != null) {
      setControlId(idProp ?? null);
    } else {
      setControlId(id);
    }
    return () => {
      setControlId(void 0);
    };
  }, [id, idProp, setControlId]);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "Switch",
    state: "checked"
  });
  useField({
    id,
    commitValidation,
    value: checked,
    controlRef: switchRef,
    name,
    getValue: () => checked
  });
  useIsoLayoutEffect(() => {
    if (inputRef.current) {
      setFilled(inputRef.current.checked);
    }
  }, [inputRef, setFilled]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const rootProps = React2.useMemo(() => ({
    id,
    role: "switch",
    disabled,
    "aria-checked": checked,
    "aria-readonly": readOnly || void 0,
    "aria-labelledby": labelId,
    onFocus() {
      setFocused(true);
    },
    onBlur() {
      const element2 = inputRef.current;
      if (!element2) {
        return;
      }
      setTouched(true);
      setFocused(false);
      if (validationMode === "onBlur") {
        commitValidation(element2.checked);
      }
    },
    onClick(event) {
      var _a;
      if (event.defaultPrevented || readOnly) {
        return;
      }
      (_a = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a.click();
    }
  }), [id, disabled, checked, readOnly, labelId, setFocused, setTouched, commitValidation, validationMode, inputRef]);
  const inputProps = React2.useMemo(() => mergeProps({
    checked,
    disabled,
    id: !name ? `${id}-input` : void 0,
    name,
    required,
    style: visuallyHidden,
    tabIndex: -1,
    type: "checkbox",
    "aria-hidden": true,
    ref: handleInputRef,
    onChange(event) {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      const nextChecked = event.target.checked;
      const eventDetails = createChangeEventDetails("none", event.nativeEvent);
      onCheckedChange == null ? void 0 : onCheckedChange(nextChecked, eventDetails);
      if (eventDetails.isCanceled) {
        return;
      }
      clearErrors(name);
      setDirty(nextChecked !== validityData.initialValue);
      setFilled(nextChecked);
      setCheckedState(nextChecked);
      if (validationMode === "onChange") {
        commitValidation(nextChecked);
      } else {
        commitValidation(nextChecked, true);
      }
    }
  }, getInputValidationProps), [checked, clearErrors, commitValidation, disabled, getInputValidationProps, handleInputRef, id, name, onCheckedChange, required, setCheckedState, setDirty, setFilled, validationMode, validityData.initialValue]);
  const state = React2.useMemo(() => ({
    ...fieldState,
    checked,
    disabled,
    readOnly,
    required
  }), [fieldState, checked, disabled, readOnly, required]);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, switchRef, buttonRef],
    props: [rootProps, getValidationProps, elementProps, getButtonProps],
    stateAttributesMapping
  });
  return (0, import_jsx_runtime.jsxs)(SwitchRootContext.Provider, {
    value: state,
    children: [element, !checked && nameProp && (0, import_jsx_runtime.jsx)("input", {
      type: "hidden",
      name: nameProp,
      value: "off"
    }), (0, import_jsx_runtime.jsx)("input", {
      ...inputProps
    })]
  });
});
if (true) SwitchRoot.displayName = "SwitchRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/switch/thumb/SwitchThumb.js
var React3 = __toESM(require_react(), 1);
var SwitchThumb = React3.forwardRef(function SwitchThumb2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state: fieldState
  } = useFieldRootContext();
  const state = useSwitchRootContext();
  const extendedState = {
    ...fieldState,
    ...state
  };
  return useRenderElement("span", componentProps, {
    state: extendedState,
    ref: forwardedRef,
    stateAttributesMapping,
    props: elementProps
  });
});
if (true) SwitchThumb.displayName = "SwitchThumb";

export {
  index_parts_exports
};
//# sourceMappingURL=chunk-LXIWQOYP.js.map
