import {
  useCompositeItem
} from "./chunk-YCZIVBMH.js";
import {
  InternalBackdrop,
  Separator,
  getPseudoElementBounds,
  useScrollLock,
  useToolbarRootContext
} from "./chunk-MRI4Y6N6.js";
import {
  COMPOSITE_KEYS,
  CompositeList,
  useCompositeListItem
} from "./chunk-IZQX5ZPK.js";
import {
  useBaseUiId
} from "./chunk-EZX2H7FZ.js";
import {
  inertValue
} from "./chunk-HC2V6TPM.js";
import {
  useButton
} from "./chunk-PODRTBZK.js";
import {
  popupStateMapping,
  pressableTriggerOpenStateMapping,
  triggerOpenStateMapping,
  useAnchorPositioning,
  useTransitionStatus
} from "./chunk-BCPUTI2J.js";
import {
  useDirection
} from "./chunk-GJAGVRWM.js";
import {
  useControlled
} from "./chunk-NXVU5FCV.js";
import {
  FloatingFocusManager,
  FloatingNode,
  FloatingPortal,
  FloatingTree,
  safePolygon,
  transitionStatusMapping,
  useClick,
  useDismiss,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useFloatingRootContext,
  useFloatingTree,
  useFocus,
  useHover,
  useInteractions,
  useListNavigation,
  useOpenChangeComplete,
  useRole,
  useTypeahead
} from "./chunk-UAJXLITD.js";
import {
  useTimeout
} from "./chunk-ZDUACO7A.js";
import {
  ownerDocument
} from "./chunk-3FELFY6H.js";
import {
  contains
} from "./chunk-CSZZYMWP.js";
import {
  createChangeEventDetails,
  getParentNode,
  isHTMLElement,
  isLastTraversableNode,
  useEventCallback
} from "./chunk-5VFA47B3.js";
import {
  DISABLED_TRANSITIONS_STYLE,
  DROPDOWN_COLLISION_AVOIDANCE,
  EMPTY_ARRAY,
  EMPTY_OBJECT,
  PATIENT_CLICK_THRESHOLD,
  TYPEAHEAD_RESET_MS,
  mergeProps,
  useId,
  useIsoLayoutEffect,
  useMergedRefs,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_react_dom
} from "./chunk-SXRIVT2P.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __export,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Arrow: () => MenuArrow,
  Backdrop: () => MenuBackdrop,
  CheckboxItem: () => MenuCheckboxItem,
  CheckboxItemIndicator: () => MenuCheckboxItemIndicator,
  Group: () => MenuGroup,
  GroupLabel: () => MenuGroupLabel,
  Item: () => MenuItem,
  Popup: () => MenuPopup,
  Portal: () => MenuPortal,
  Positioner: () => MenuPositioner,
  RadioGroup: () => MenuRadioGroup,
  RadioItem: () => MenuRadioItem,
  RadioItemIndicator: () => MenuRadioItemIndicator,
  Root: () => MenuRoot,
  Separator: () => Separator,
  SubmenuRoot: () => MenuSubmenuRoot,
  SubmenuTrigger: () => MenuSubmenuTrigger,
  Trigger: () => MenuTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/arrow/MenuArrow.js
var React3 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/positioner/MenuPositionerContext.js
var React = __toESM(require_react(), 1);
var MenuPositionerContext = React.createContext(void 0);
if (true) MenuPositionerContext.displayName = "MenuPositionerContext";
function useMenuPositionerContext(optional) {
  const context = React.useContext(MenuPositionerContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: MenuPositionerContext is missing. MenuPositioner parts must be placed within <Menu.Positioner>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/root/MenuRootContext.js
var React2 = __toESM(require_react(), 1);
var MenuRootContext = React2.createContext(void 0);
if (true) MenuRootContext.displayName = "MenuRootContext";
function useMenuRootContext(optional) {
  const context = React2.useContext(MenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: MenuRootContext is missing. Menu parts must be placed within <Menu.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/arrow/MenuArrow.js
var MenuArrow = React3.forwardRef(function MenuArrow2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open
  } = useMenuRootContext();
  const {
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = useMenuPositionerContext();
  const state = React3.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  return useRenderElement("div", componentProps, {
    ref: [arrowRef, forwardedRef],
    stateAttributesMapping: popupStateMapping,
    state,
    props: {
      style: arrowStyles,
      "aria-hidden": true,
      ...elementProps
    }
  });
});
if (true) MenuArrow.displayName = "MenuArrow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/backdrop/MenuBackdrop.js
var React5 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/context-menu/root/ContextMenuRootContext.js
var React4 = __toESM(require_react(), 1);
var ContextMenuRootContext = React4.createContext(void 0);
if (true) ContextMenuRootContext.displayName = "ContextMenuRootContext";
function useContextMenuRootContext(optional = true) {
  const context = React4.useContext(ContextMenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: ContextMenuRootContext is missing. ContextMenu parts must be placed within <ContextMenu.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/backdrop/MenuBackdrop.js
var stateAttributesMapping = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var MenuBackdrop = React5.forwardRef(function MenuBackdrop2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open,
    mounted,
    transitionStatus,
    lastOpenChangeReason
  } = useMenuRootContext();
  const contextMenuContext = useContextMenuRootContext();
  const state = React5.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  return useRenderElement("div", componentProps, {
    ref: (contextMenuContext == null ? void 0 : contextMenuContext.backdropRef) ? [forwardedRef, contextMenuContext.backdropRef] : forwardedRef,
    state,
    stateAttributesMapping,
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        pointerEvents: lastOpenChangeReason === "trigger-hover" ? "none" : void 0,
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps]
  });
});
if (true) MenuBackdrop.displayName = "MenuBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/checkbox-item/MenuCheckboxItem.js
var React8 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/checkbox-item/MenuCheckboxItemContext.js
var React6 = __toESM(require_react(), 1);
var MenuCheckboxItemContext = React6.createContext(void 0);
if (true) MenuCheckboxItemContext.displayName = "MenuCheckboxItemContext";
function useMenuCheckboxItemContext() {
  const context = React6.useContext(MenuCheckboxItemContext);
  if (context === void 0) {
    throw new Error("Base UI: MenuCheckboxItemContext is missing. MenuCheckboxItem parts must be placed within <Menu.CheckboxItem>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/item/useMenuItem.js
var React7 = __toESM(require_react(), 1);
var REGULAR_ITEM = {
  type: "regular-item"
};
function useMenuItem(params) {
  const {
    closeOnClick,
    disabled = false,
    highlighted,
    id,
    menuEvents,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    itemMetadata,
    nodeId
  } = params;
  const itemRef = React7.useRef(null);
  const contextMenuContext = useContextMenuRootContext(true);
  const isContextMenu = contextMenuContext !== void 0;
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    native: nativeButton
  });
  const getItemProps = React7.useCallback((externalProps) => {
    return mergeProps({
      id,
      role: "menuitem",
      tabIndex: highlighted ? 0 : -1,
      onMouseMove(event) {
        if (!nodeId) {
          return;
        }
        menuEvents.emit("itemhover", {
          nodeId,
          target: event.currentTarget
        });
      },
      onMouseEnter() {
        if (itemMetadata.type !== "submenu-trigger") {
          return;
        }
        itemMetadata.setActive();
      },
      onKeyUp(event) {
        if (event.key === " " && typingRef.current) {
          event.preventBaseUIHandler();
        }
      },
      onClick(event) {
        if (closeOnClick) {
          menuEvents.emit("close", {
            domEvent: event,
            reason: "item-press"
          });
        }
      },
      onMouseUp(event) {
        if (itemRef.current && allowMouseUpTriggerRef.current && (!isContextMenu || event.button === 2)) {
          if (itemMetadata.type === "regular-item") {
            itemRef.current.click();
          }
        }
      }
    }, externalProps, getButtonProps);
  }, [id, highlighted, getButtonProps, typingRef, closeOnClick, menuEvents, allowMouseUpTriggerRef, isContextMenu, itemMetadata, nodeId]);
  const mergedRef = useMergedRefs(itemRef, buttonRef);
  return React7.useMemo(() => ({
    getItemProps,
    itemRef: mergedRef
  }), [getItemProps, mergedRef]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/checkbox-item/MenuCheckboxItemDataAttributes.js
var MenuCheckboxItemDataAttributes = (function(MenuCheckboxItemDataAttributes2) {
  MenuCheckboxItemDataAttributes2["checked"] = "data-checked";
  MenuCheckboxItemDataAttributes2["unchecked"] = "data-unchecked";
  MenuCheckboxItemDataAttributes2["disabled"] = "data-disabled";
  MenuCheckboxItemDataAttributes2["highlighted"] = "data-highlighted";
  return MenuCheckboxItemDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/utils/stateAttributesMapping.js
var itemMapping = {
  checked(value) {
    if (value) {
      return {
        [MenuCheckboxItemDataAttributes.checked]: ""
      };
    }
    return {
      [MenuCheckboxItemDataAttributes.unchecked]: ""
    };
  },
  ...transitionStatusMapping
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/checkbox-item/MenuCheckboxItem.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var InnerMenuCheckboxItem = React8.memo(React8.forwardRef(function InnerMenuCheckboxItem2(componentProps, forwardedRef) {
  const {
    checked: checkedProp,
    defaultChecked,
    onCheckedChange,
    className,
    closeOnClick,
    disabled = false,
    highlighted,
    id,
    menuEvents,
    itemProps,
    render,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    nodeId,
    ...elementProps
  } = componentProps;
  const [checked, setChecked] = useControlled({
    controlled: checkedProp,
    default: defaultChecked ?? false,
    name: "MenuCheckboxItem",
    state: "checked"
  });
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick,
    disabled,
    highlighted,
    id,
    menuEvents,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    nodeId,
    itemMetadata: REGULAR_ITEM
  });
  const state = React8.useMemo(() => ({
    disabled,
    highlighted,
    checked
  }), [disabled, highlighted, checked]);
  const element = useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: itemMapping,
    props: [itemProps, {
      role: "menuitemcheckbox",
      "aria-checked": checked,
      onClick(event) {
        const details = createChangeEventDetails("item-press", event.nativeEvent);
        onCheckedChange == null ? void 0 : onCheckedChange(!checked, details);
        if (details.isCanceled) {
          return;
        }
        setChecked((currentlyChecked) => !currentlyChecked);
      }
    }, elementProps, getItemProps],
    ref: [itemRef, forwardedRef]
  });
  return (0, import_jsx_runtime.jsx)(MenuCheckboxItemContext.Provider, {
    value: state,
    children: element
  });
}));
if (true) InnerMenuCheckboxItem.displayName = "InnerMenuCheckboxItem";
var MenuCheckboxItem = React8.forwardRef(function MenuCheckboxItem2(props, forwardedRef) {
  const {
    id: idProp,
    label,
    closeOnClick = false,
    nativeButton = false,
    ...other
  } = props;
  const itemRef = React8.useRef(null);
  const listItem = useCompositeListItem({
    label
  });
  const mergedRef = useMergedRefs(forwardedRef, listItem.ref, itemRef);
  const {
    itemProps,
    activeIndex,
    allowMouseUpTriggerRef,
    typingRef
  } = useMenuRootContext();
  const menuPositionerContext = useMenuPositionerContext(true);
  const id = useBaseUiId(idProp);
  const highlighted = listItem.index === activeIndex;
  const {
    events: menuEvents
  } = useFloatingTree();
  return (0, import_jsx_runtime.jsx)(InnerMenuCheckboxItem, {
    ...other,
    id,
    ref: mergedRef,
    highlighted,
    menuEvents,
    itemProps,
    allowMouseUpTriggerRef,
    typingRef,
    closeOnClick,
    nativeButton,
    nodeId: menuPositionerContext == null ? void 0 : menuPositionerContext.floatingContext.nodeId
  });
});
if (true) MenuCheckboxItem.displayName = "MenuCheckboxItem";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/checkbox-item-indicator/MenuCheckboxItemIndicator.js
var React9 = __toESM(require_react(), 1);
var MenuCheckboxItemIndicator = React9.forwardRef(function MenuCheckboxItemIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const item = useMenuCheckboxItemContext();
  const indicatorRef = React9.useRef(null);
  const {
    transitionStatus,
    setMounted
  } = useTransitionStatus(item.checked);
  useOpenChangeComplete({
    open: item.checked,
    ref: indicatorRef,
    onComplete() {
      if (!item.checked) {
        setMounted(false);
      }
    }
  });
  const state = React9.useMemo(() => ({
    checked: item.checked,
    disabled: item.disabled,
    highlighted: item.highlighted,
    transitionStatus
  }), [item.checked, item.disabled, item.highlighted, transitionStatus]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: [forwardedRef, indicatorRef],
    stateAttributesMapping: itemMapping,
    props: {
      "aria-hidden": true,
      ...elementProps
    },
    enabled: keepMounted || item.checked
  });
  return element;
});
if (true) MenuCheckboxItemIndicator.displayName = "MenuCheckboxItemIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/group/MenuGroup.js
var React11 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/group/MenuGroupContext.js
var React10 = __toESM(require_react(), 1);
var MenuGroupContext = React10.createContext(void 0);
if (true) MenuGroupContext.displayName = "MenuGroupContext";
function useMenuGroupRootContext() {
  const context = React10.useContext(MenuGroupContext);
  if (context === void 0) {
    throw new Error("Base UI: MenuGroupRootContext is missing. Menu group parts must be used within <Menu.Group>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/group/MenuGroup.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var MenuGroup = React11.forwardRef(function MenuGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const [labelId, setLabelId] = React11.useState(void 0);
  const context = React11.useMemo(() => ({
    setLabelId
  }), [setLabelId]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: {
      role: "group",
      "aria-labelledby": labelId,
      ...elementProps
    }
  });
  return (0, import_jsx_runtime2.jsx)(MenuGroupContext.Provider, {
    value: context,
    children: element
  });
});
if (true) MenuGroup.displayName = "MenuGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/group-label/MenuGroupLabel.js
var React12 = __toESM(require_react(), 1);
var MenuGroupLabel = React12.forwardRef(function MenuGroupLabelComponent(componentProps, forwardedRef) {
  const {
    className,
    render,
    id: idProp,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const {
    setLabelId
  } = useMenuGroupRootContext();
  useIsoLayoutEffect(() => {
    setLabelId(id);
    return () => {
      setLabelId(void 0);
    };
  }, [setLabelId, id]);
  return useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: {
      id,
      role: "presentation",
      ...elementProps
    }
  });
});
if (true) MenuGroupLabel.displayName = "MenuGroupLabel";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/item/MenuItem.js
var React13 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var InnerMenuItem = React13.memo(React13.forwardRef(function InnerMenuItem2(componentProps, forwardedRef) {
  const {
    className,
    closeOnClick = true,
    disabled = false,
    highlighted,
    id,
    menuEvents,
    itemProps,
    render,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    nodeId,
    ...elementProps
  } = componentProps;
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick,
    disabled,
    highlighted,
    id,
    menuEvents,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    nodeId,
    itemMetadata: REGULAR_ITEM
  });
  const state = React13.useMemo(() => ({
    disabled,
    highlighted
  }), [disabled, highlighted]);
  return useRenderElement("div", componentProps, {
    state,
    ref: [itemRef, forwardedRef],
    props: [itemProps, elementProps, getItemProps]
  });
}));
if (true) InnerMenuItem.displayName = "InnerMenuItem";
var MenuItem = React13.forwardRef(function MenuItem2(props, forwardedRef) {
  const {
    id: idProp,
    label,
    nativeButton = false,
    ...other
  } = props;
  const itemRef = React13.useRef(null);
  const listItem = useCompositeListItem({
    label
  });
  const mergedRef = useMergedRefs(forwardedRef, listItem.ref, itemRef);
  const {
    itemProps,
    activeIndex,
    allowMouseUpTriggerRef,
    typingRef
  } = useMenuRootContext();
  const menuPositionerContext = useMenuPositionerContext(true);
  const id = useBaseUiId(idProp);
  const highlighted = listItem.index === activeIndex;
  const {
    events: menuEvents
  } = useFloatingTree();
  return (0, import_jsx_runtime3.jsx)(InnerMenuItem, {
    ...other,
    id,
    ref: mergedRef,
    highlighted,
    menuEvents,
    itemProps,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    nodeId: menuPositionerContext == null ? void 0 : menuPositionerContext.floatingContext.nodeId
  });
});
if (true) MenuItem.displayName = "MenuItem";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/popup/MenuPopup.js
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping2 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var MenuPopup = React14.forwardRef(function MenuPopup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    finalFocus,
    ...elementProps
  } = componentProps;
  const {
    open,
    setOpen,
    popupRef,
    transitionStatus,
    popupProps,
    mounted,
    instantType,
    triggerElement,
    onOpenChangeComplete,
    parent,
    lastOpenChangeReason,
    rootId
  } = useMenuRootContext();
  const {
    side,
    align,
    floatingContext
  } = useMenuPositionerContext();
  const insideToolbar = useToolbarRootContext(true) != null;
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      if (open) {
        onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(true);
      }
    }
  });
  const {
    events: menuEvents
  } = useFloatingTree();
  React14.useEffect(() => {
    function handleClose(event) {
      setOpen(false, createChangeEventDetails(event.reason, event.domEvent));
    }
    menuEvents.on("close", handleClose);
    return () => {
      menuEvents.off("close", handleClose);
    };
  }, [menuEvents, setOpen]);
  const state = React14.useMemo(() => ({
    transitionStatus,
    side,
    align,
    open,
    nested: parent.type === "menu",
    instant: instantType
  }), [transitionStatus, side, align, open, parent.type, instantType]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, popupRef],
    stateAttributesMapping: stateAttributesMapping2,
    props: [popupProps, {
      onKeyDown(event) {
        if (insideToolbar && COMPOSITE_KEYS.has(event.key)) {
          event.stopPropagation();
        }
      }
    }, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps, {
      "data-rootownerid": rootId
    }]
  });
  let returnFocus = parent.type === void 0 || parent.type === "context-menu";
  if (triggerElement || parent.type === "menubar" && lastOpenChangeReason !== "outside-press") {
    returnFocus = true;
  }
  return (0, import_jsx_runtime4.jsx)(FloatingFocusManager, {
    context: floatingContext,
    modal: false,
    disabled: !mounted,
    returnFocus: finalFocus === void 0 ? returnFocus : finalFocus,
    initialFocus: parent.type !== "menu",
    restoreFocus: true,
    children: element
  });
});
if (true) MenuPopup.displayName = "MenuPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/portal/MenuPortal.js
var React16 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/portal/MenuPortalContext.js
var React15 = __toESM(require_react(), 1);
var MenuPortalContext = React15.createContext(void 0);
if (true) MenuPortalContext.displayName = "MenuPortalContext";
function useMenuPortalContext() {
  const value = React15.useContext(MenuPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <Menu.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/portal/MenuPortal.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function MenuPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    mounted
  } = useMenuRootContext();
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime5.jsx)(MenuPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime5.jsx)(FloatingPortal, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/positioner/MenuPositioner.js
var React17 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var MenuPositioner = React17.forwardRef(function MenuPositioner2(componentProps, forwardedRef) {
  var _a;
  const {
    anchor: anchorProp,
    positionMethod: positionMethodProp = "absolute",
    className,
    render,
    side,
    align: alignProp,
    sideOffset: sideOffsetProp = 0,
    alignOffset: alignOffsetProp = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = false,
    trackAnchor = true,
    collisionAvoidance = DROPDOWN_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps;
  const {
    open,
    setOpen,
    floatingRootContext,
    setPositionerElement,
    itemDomElements,
    itemLabels,
    mounted,
    modal,
    lastOpenChangeReason,
    parent,
    setHoverEnabled,
    triggerElement
  } = useMenuRootContext();
  const keepMounted = useMenuPortalContext();
  const nodeId = useFloatingNodeId();
  const parentNodeId = useFloatingParentNodeId();
  const contextMenuContext = useContextMenuRootContext(true);
  let anchor = anchorProp;
  let sideOffset = sideOffsetProp;
  let alignOffset = alignOffsetProp;
  let align = alignProp;
  if (parent.type === "context-menu") {
    anchor = ((_a = parent.context) == null ? void 0 : _a.anchor) ?? anchorProp;
    align = align ?? "start";
    if (!side && align !== "center") {
      alignOffset = componentProps.alignOffset ?? 2;
      sideOffset = componentProps.sideOffset ?? -5;
    }
  }
  let computedSide = side;
  let computedAlign = align;
  if (parent.type === "menu") {
    computedSide = computedSide ?? "inline-end";
    computedAlign = computedAlign ?? "start";
  } else if (parent.type === "menubar") {
    computedSide = computedSide ?? "bottom";
    computedAlign = computedAlign ?? "start";
  }
  const contextMenu = parent.type === "context-menu";
  const positioner = useAnchorPositioning({
    anchor,
    floatingRootContext,
    positionMethod: contextMenuContext ? "fixed" : positionMethodProp,
    mounted,
    side: computedSide,
    sideOffset,
    align: computedAlign,
    alignOffset,
    arrowPadding: contextMenu ? 0 : arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    nodeId,
    keepMounted,
    trackAnchor,
    collisionAvoidance,
    shiftCrossAxis: contextMenu
  });
  const {
    events: menuEvents
  } = useFloatingTree();
  const positionerProps = React17.useMemo(() => {
    const hiddenStyles = {};
    if (!open) {
      hiddenStyles.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioner.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, mounted, positioner.positionerStyles]);
  React17.useEffect(() => {
    function onMenuOpenChange(details) {
      if (details.open) {
        if (details.parentNodeId === nodeId) {
          setHoverEnabled(false);
        }
        if (details.nodeId !== nodeId && details.parentNodeId === parentNodeId) {
          setOpen(false, createChangeEventDetails("sibling-open"));
        }
      } else if (details.parentNodeId === nodeId) {
        if (details.reason !== "sibling-open") {
          setHoverEnabled(true);
        }
      }
    }
    menuEvents.on("menuopenchange", onMenuOpenChange);
    return () => {
      menuEvents.off("menuopenchange", onMenuOpenChange);
    };
  }, [menuEvents, nodeId, parentNodeId, setOpen, setHoverEnabled]);
  React17.useEffect(() => {
    if (parentNodeId == null) {
      return void 0;
    }
    function onParentClose(details) {
      if (details.open || details.nodeId !== parentNodeId) {
        return;
      }
      const reason = details.reason ?? "sibling-open";
      setOpen(false, createChangeEventDetails(reason));
    }
    menuEvents.on("menuopenchange", onParentClose);
    return () => {
      menuEvents.off("menuopenchange", onParentClose);
    };
  }, [menuEvents, parentNodeId, setOpen]);
  React17.useEffect(() => {
    function onItemHover(event) {
      if (!open || event.nodeId !== parentNodeId) {
        return;
      }
      if (triggerElement && event.target && triggerElement !== event.target) {
        setOpen(false, createChangeEventDetails("sibling-open"));
      }
    }
    menuEvents.on("itemhover", onItemHover);
    return () => {
      menuEvents.off("itemhover", onItemHover);
    };
  }, [menuEvents, parentNodeId, triggerElement, open, setOpen]);
  React17.useEffect(() => {
    const eventDetails = {
      open,
      nodeId,
      parentNodeId,
      reason: lastOpenChangeReason
    };
    menuEvents.emit("menuopenchange", eventDetails);
  }, [menuEvents, open, nodeId, parentNodeId, lastOpenChangeReason]);
  const state = React17.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    anchorHidden: positioner.anchorHidden,
    nested: parent.type === "menu"
  }), [open, positioner.side, positioner.align, positioner.anchorHidden, parent.type]);
  const contextValue = React17.useMemo(() => ({
    side: positioner.side,
    align: positioner.align,
    arrowRef: positioner.arrowRef,
    arrowUncentered: positioner.arrowUncentered,
    arrowStyles: positioner.arrowStyles,
    floatingContext: positioner.context
  }), [positioner.side, positioner.align, positioner.arrowRef, positioner.arrowUncentered, positioner.arrowStyles, positioner.context]);
  const element = useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: popupStateMapping,
    ref: [forwardedRef, setPositionerElement],
    props: {
      ...positionerProps,
      ...elementProps
    }
  });
  const shouldRenderBackdrop = mounted && parent.type !== "menu" && (parent.type !== "menubar" && modal && lastOpenChangeReason !== "trigger-hover" || parent.type === "menubar" && parent.context.modal);
  let backdropCutout = null;
  if (parent.type === "menubar") {
    backdropCutout = parent.context.contentElement;
  } else if (parent.type === void 0) {
    backdropCutout = triggerElement;
  }
  return (0, import_jsx_runtime6.jsxs)(MenuPositionerContext.Provider, {
    value: contextValue,
    children: [shouldRenderBackdrop && (0, import_jsx_runtime6.jsx)(InternalBackdrop, {
      ref: parent.type === "context-menu" || parent.type === "nested-context-menu" ? parent.context.internalBackdropRef : null,
      inert: inertValue(!open),
      cutout: backdropCutout
    }), (0, import_jsx_runtime6.jsx)(FloatingNode, {
      id: nodeId,
      children: (0, import_jsx_runtime6.jsx)(CompositeList, {
        elementsRef: itemDomElements,
        labelsRef: itemLabels,
        children: element
      })
    })]
  });
});
if (true) MenuPositioner.displayName = "MenuPositioner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-group/MenuRadioGroup.js
var React19 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-group/MenuRadioGroupContext.js
var React18 = __toESM(require_react(), 1);
var MenuRadioGroupContext = React18.createContext(void 0);
if (true) MenuRadioGroupContext.displayName = "MenuRadioGroupContext";
function useMenuRadioGroupContext() {
  const context = React18.useContext(MenuRadioGroupContext);
  if (context === void 0) {
    throw new Error("Base UI: MenuRadioGroupContext is missing. MenuRadioGroup parts must be placed within <Menu.RadioGroup>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-group/MenuRadioGroup.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var MenuRadioGroup = React19.memo(React19.forwardRef(function MenuRadioGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    value: valueProp,
    defaultValue,
    onValueChange: onValueChangeProp,
    disabled = false,
    ...elementProps
  } = componentProps;
  const [value, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "MenuRadioGroup"
  });
  const onValueChange = useEventCallback(onValueChangeProp);
  const setValue = useEventCallback((newValue, eventDetails) => {
    onValueChange == null ? void 0 : onValueChange(newValue, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setValueUnwrapped(newValue);
  });
  const state = React19.useMemo(() => ({
    disabled
  }), [disabled]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: {
      role: "group",
      "aria-disabled": disabled || void 0,
      ...elementProps
    }
  });
  const context = React19.useMemo(() => ({
    value,
    setValue,
    disabled
  }), [value, setValue, disabled]);
  return (0, import_jsx_runtime7.jsx)(MenuRadioGroupContext.Provider, {
    value: context,
    children: element
  });
}));
if (true) MenuRadioGroup.displayName = "MenuRadioGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-item/MenuRadioItem.js
var React21 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-item/MenuRadioItemContext.js
var React20 = __toESM(require_react(), 1);
var MenuRadioItemContext = React20.createContext(void 0);
if (true) MenuRadioItemContext.displayName = "MenuRadioItemContext";
function useMenuRadioItemContext() {
  const context = React20.useContext(MenuRadioItemContext);
  if (context === void 0) {
    throw new Error("Base UI: MenuRadioItemContext is missing. MenuRadioItem parts must be placed within <Menu.RadioItem>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-item/MenuRadioItem.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var InnerMenuRadioItem = React21.memo(React21.forwardRef(function InnerMenuRadioItem2(componentProps, forwardedRef) {
  const {
    checked,
    setChecked,
    className,
    closeOnClick,
    disabled = false,
    highlighted,
    id,
    menuEvents,
    itemProps,
    render,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    nodeId,
    ...elementProps
  } = componentProps;
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick,
    disabled,
    highlighted,
    id,
    menuEvents,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    itemMetadata: REGULAR_ITEM,
    nodeId
  });
  const state = React21.useMemo(() => ({
    disabled,
    highlighted,
    checked
  }), [disabled, highlighted, checked]);
  return useRenderElement("div", componentProps, {
    state,
    stateAttributesMapping: itemMapping,
    ref: [itemRef, forwardedRef],
    props: [itemProps, {
      role: "menuitemradio",
      "aria-checked": checked,
      onClick(event) {
        setChecked(createChangeEventDetails("item-press", event.nativeEvent));
      }
    }, elementProps, getItemProps]
  });
}));
if (true) InnerMenuRadioItem.displayName = "InnerMenuRadioItem";
var MenuRadioItem = React21.forwardRef(function MenuRadioItem2(props, forwardedRef) {
  const {
    id: idProp,
    value,
    label,
    disabled: disabledProp = false,
    closeOnClick = false,
    nativeButton = false,
    ...other
  } = props;
  const itemRef = React21.useRef(null);
  const listItem = useCompositeListItem({
    label
  });
  const mergedRef = useMergedRefs(forwardedRef, listItem.ref, itemRef);
  const {
    itemProps,
    activeIndex,
    allowMouseUpTriggerRef,
    typingRef
  } = useMenuRootContext();
  const menuPositionerContext = useMenuPositionerContext(true);
  const id = useBaseUiId(idProp);
  const highlighted = listItem.index === activeIndex;
  const {
    events: menuEvents
  } = useFloatingTree();
  const {
    value: selectedValue,
    setValue: setSelectedValue,
    disabled: groupDisabled
  } = useMenuRadioGroupContext();
  const disabled = groupDisabled || disabledProp;
  const checked = selectedValue === value;
  const setChecked = React21.useCallback((eventDetails) => {
    setSelectedValue(value, eventDetails);
  }, [setSelectedValue, value]);
  const contextValue = React21.useMemo(() => ({
    checked,
    highlighted,
    disabled
  }), [checked, highlighted, disabled]);
  return (0, import_jsx_runtime8.jsx)(MenuRadioItemContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime8.jsx)(InnerMenuRadioItem, {
      ...other,
      id,
      ref: mergedRef,
      disabled,
      highlighted,
      menuEvents,
      itemProps,
      allowMouseUpTriggerRef,
      checked: selectedValue === value,
      setChecked,
      typingRef,
      closeOnClick,
      nativeButton,
      nodeId: menuPositionerContext == null ? void 0 : menuPositionerContext.floatingContext.nodeId
    })
  });
});
if (true) MenuRadioItem.displayName = "MenuRadioItem";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/radio-item-indicator/MenuRadioItemIndicator.js
var React22 = __toESM(require_react(), 1);
var MenuRadioItemIndicator = React22.forwardRef(function MenuRadioItemIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const item = useMenuRadioItemContext();
  const indicatorRef = React22.useRef(null);
  const {
    transitionStatus,
    setMounted
  } = useTransitionStatus(item.checked);
  useOpenChangeComplete({
    open: item.checked,
    ref: indicatorRef,
    onComplete() {
      if (!item.checked) {
        setMounted(false);
      }
    }
  });
  const state = React22.useMemo(() => ({
    checked: item.checked,
    disabled: item.disabled,
    highlighted: item.highlighted,
    transitionStatus
  }), [item.checked, item.disabled, item.highlighted, transitionStatus]);
  const element = useRenderElement("span", componentProps, {
    state,
    stateAttributesMapping: itemMapping,
    ref: [forwardedRef, indicatorRef],
    props: {
      "aria-hidden": true,
      ...elementProps
    },
    enabled: keepMounted || item.checked
  });
  return element;
});
if (true) MenuRadioItemIndicator.displayName = "MenuRadioItemIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/root/MenuRoot.js
var React28 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menubar/MenubarContext.js
var React23 = __toESM(require_react(), 1);
var MenubarContext = React23.createContext(null);
if (true) MenubarContext.displayName = "MenubarContext";
function useMenubarContext(optional) {
  const context = React23.useContext(MenubarContext);
  if (context === null && !optional) {
    throw new Error("Base UI: MenubarContext is missing. Menubar parts must be placed within <Menubar>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/useOpenInteractionType.js
var React25 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+utils@0.1.2_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/utils/esm/useEnhancedClickHandler.js
var React24 = __toESM(require_react());
function useEnhancedClickHandler(handler) {
  const lastClickInteractionTypeRef = React24.useRef("");
  const handlePointerDown = React24.useCallback((event) => {
    if (event.defaultPrevented) {
      return;
    }
    lastClickInteractionTypeRef.current = event.pointerType;
    handler(event, event.pointerType);
  }, [handler]);
  const handleClick = React24.useCallback((event) => {
    if (event.detail === 0) {
      handler(event, "keyboard");
      return;
    }
    if ("pointerType" in event) {
      handler(event, event.pointerType);
    }
    handler(event, lastClickInteractionTypeRef.current);
    lastClickInteractionTypeRef.current = "";
  }, [handler]);
  return {
    onClick: handleClick,
    onPointerDown: handlePointerDown
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/useOpenInteractionType.js
function useOpenInteractionType(open) {
  const [openMethod, setOpenMethod] = React25.useState(null);
  const handleTriggerClick = useEventCallback((_, interactionType) => {
    if (!open) {
      setOpenMethod(interactionType);
    }
  });
  const reset = useEventCallback(() => {
    setOpenMethod(null);
  });
  const {
    onClick,
    onPointerDown
  } = useEnhancedClickHandler(handleTriggerClick);
  return React25.useMemo(() => ({
    openMethod,
    reset,
    triggerProps: {
      onClick,
      onPointerDown
    }
  }), [openMethod, reset, onClick, onPointerDown]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/submenu-root/MenuSubmenuRootContext.js
var React26 = __toESM(require_react(), 1);
var MenuSubmenuRootContext = React26.createContext(false);
if (true) MenuSubmenuRootContext.displayName = "MenuSubmenuRootContext";
function useMenuSubmenuRootContext() {
  return React26.useContext(MenuSubmenuRootContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/useMixedToggleClickHander.js
var React27 = __toESM(require_react(), 1);
function useMixedToggleClickHandler(params) {
  const {
    enabled = true,
    mouseDownAction,
    open
  } = params;
  const ignoreClickRef = React27.useRef(false);
  return React27.useMemo(() => {
    if (!enabled) {
      return EMPTY_OBJECT;
    }
    return {
      onMouseDown: (event) => {
        if (mouseDownAction === "open" && !open || mouseDownAction === "close" && open) {
          ignoreClickRef.current = true;
          ownerDocument(event.currentTarget).addEventListener("click", () => {
            ignoreClickRef.current = false;
          }, {
            once: true
          });
        }
      },
      onClick: (event) => {
        if (ignoreClickRef.current) {
          ignoreClickRef.current = false;
          event.preventBaseUIHandler();
        }
      }
    };
  }, [enabled, mouseDownAction, open]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/root/MenuRoot.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var EMPTY_ARRAY2 = [];
var EMPTY_REF = {
  current: false
};
var MenuRoot = function MenuRoot2(props) {
  const {
    children,
    open: openProp,
    onOpenChange,
    onOpenChangeComplete,
    defaultOpen = false,
    disabled: disabledProp = false,
    modal: modalProp,
    loop = true,
    orientation = "vertical",
    actionsRef,
    openOnHover: openOnHoverProp,
    delay = 100,
    closeDelay = 0,
    closeParentOnEsc = true
  } = props;
  const [triggerElement, setTriggerElement] = React28.useState(null);
  const [positionerElement, setPositionerElementUnwrapped] = React28.useState(null);
  const [instantType, setInstantType] = React28.useState();
  const [hoverEnabled, setHoverEnabled] = React28.useState(true);
  const [activeIndex, setActiveIndex] = React28.useState(null);
  const [lastOpenChangeReason, setLastOpenChangeReason] = React28.useState(null);
  const [stickIfOpen, setStickIfOpen] = React28.useState(true);
  const [allowMouseEnterState, setAllowMouseEnterState] = React28.useState(false);
  const openEventRef = React28.useRef(null);
  const popupRef = React28.useRef(null);
  const positionerRef = React28.useRef(null);
  const itemDomElements = React28.useRef([]);
  const itemLabels = React28.useRef([]);
  const stickIfOpenTimeout = useTimeout();
  const contextMenuContext = useContextMenuRootContext(true);
  const isSubmenu = useMenuSubmenuRootContext();
  const nested = useFloatingParentNodeId() != null;
  let floatingEvents;
  let parent;
  {
    const parentContext = useMenuRootContext(true);
    const menubarContext = useMenubarContext(true);
    if (isSubmenu && parentContext) {
      parent = {
        type: "menu",
        context: parentContext
      };
    } else if (menubarContext) {
      parent = {
        type: "menubar",
        context: menubarContext
      };
    } else if (contextMenuContext && !parentContext) {
      parent = {
        type: "context-menu",
        context: contextMenuContext
      };
    } else {
      parent = {
        type: void 0
      };
    }
  }
  let rootId = useId();
  if (parent.type !== void 0) {
    rootId = parent.context.rootId;
  }
  const modal = (parent.type === void 0 || parent.type === "context-menu") && (modalProp ?? true);
  const disabled = disabledProp || parent.type === "menubar" && parent.context.disabled || false;
  const allowMouseEnter = parent.type === "menu" ? parent.context.allowMouseEnter : allowMouseEnterState;
  const setAllowMouseEnter = parent.type === "menu" ? parent.context.setAllowMouseEnter : setAllowMouseEnterState;
  if (true) {
    if (parent.type !== void 0 && modalProp !== void 0) {
      console.warn("Base UI: The `modal` prop is not supported on nested menus. It will be ignored.");
    }
  }
  const openOnHover = openOnHoverProp ?? (parent.type === "menu" || parent.type === "menubar" && parent.context.hasSubmenuOpen);
  const [open, setOpenUnwrapped] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "MenuRoot",
    state: "open"
  });
  const allowOutsidePressDismissalRef = React28.useRef(parent.type !== "context-menu");
  const allowOutsidePressDismissalTimeout = useTimeout();
  React28.useEffect(() => {
    if (!open) {
      openEventRef.current = null;
    }
    if (parent.type !== "context-menu") {
      return;
    }
    if (!open) {
      allowOutsidePressDismissalTimeout.clear();
      allowOutsidePressDismissalRef.current = false;
      return;
    }
    allowOutsidePressDismissalTimeout.start(500, () => {
      allowOutsidePressDismissalRef.current = true;
    });
  }, [allowOutsidePressDismissalTimeout, open, parent.type]);
  const setPositionerElement = React28.useCallback((value) => {
    positionerRef.current = value;
    setPositionerElementUnwrapped(value);
  }, []);
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  const {
    openMethod,
    triggerProps: interactionTypeProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(open);
  useScrollLock({
    enabled: open && modal && lastOpenChangeReason !== "trigger-hover" && openMethod !== "touch",
    mounted,
    open,
    referenceElement: positionerElement
  });
  if (!open && !hoverEnabled) {
    setHoverEnabled(true);
  }
  const handleUnmount = useEventCallback(() => {
    setMounted(false);
    setStickIfOpen(true);
    setAllowMouseEnter(false);
    onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(false);
    resetOpenInteractionType();
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  const allowTouchToCloseRef = React28.useRef(true);
  const allowTouchToCloseTimeout = useTimeout();
  const setOpen = useEventCallback((nextOpen, eventDetails) => {
    const reason = eventDetails.reason;
    if (open === nextOpen) {
      return;
    }
    onOpenChange == null ? void 0 : onOpenChange(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const details = {
      open: nextOpen,
      nativeEvent: eventDetails.event,
      reason: eventDetails.reason,
      nested
    };
    floatingEvents == null ? void 0 : floatingEvents.emit("openchange", details);
    const nativeEvent = eventDetails.event;
    if (nextOpen === false && (nativeEvent == null ? void 0 : nativeEvent.type) === "click" && nativeEvent.pointerType === "touch" && !allowTouchToCloseRef.current) {
      return;
    }
    if (!nextOpen && activeIndex !== null) {
      const activeOption = itemDomElements.current[activeIndex];
      queueMicrotask(() => {
        activeOption == null ? void 0 : activeOption.setAttribute("tabindex", "-1");
      });
    }
    if (nextOpen && reason === "trigger-focus") {
      allowTouchToCloseRef.current = false;
      allowTouchToCloseTimeout.start(300, () => {
        allowTouchToCloseRef.current = true;
      });
    } else {
      allowTouchToCloseRef.current = true;
      allowTouchToCloseTimeout.clear();
    }
    const isKeyboardClick = (reason === "trigger-press" || reason === "item-press") && nativeEvent.detail === 0 && (nativeEvent == null ? void 0 : nativeEvent.isTrusted);
    const isDismissClose = !nextOpen && (reason === "escape-key" || reason == null);
    function changeState() {
      setOpenUnwrapped(nextOpen);
      setLastOpenChangeReason(reason ?? null);
      openEventRef.current = eventDetails.event ?? null;
    }
    if (reason === "trigger-hover") {
      setStickIfOpen(true);
      stickIfOpenTimeout.start(PATIENT_CLICK_THRESHOLD, () => {
        setStickIfOpen(false);
      });
      ReactDOM.flushSync(changeState);
    } else {
      changeState();
    }
    if (parent.type === "menubar" && (reason === "trigger-focus" || reason === "focus-out" || reason === "trigger-hover" || reason === "list-navigation" || reason === "sibling-open")) {
      setInstantType("group");
    } else if (isKeyboardClick || isDismissClose) {
      setInstantType(isKeyboardClick ? "click" : "dismiss");
    } else {
      setInstantType(void 0);
    }
  });
  React28.useImperativeHandle(actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  let ctx;
  if (parent.type === "context-menu") {
    ctx = parent.context;
  }
  React28.useImperativeHandle(ctx == null ? void 0 : ctx.positionerRef, () => positionerElement, [positionerElement]);
  React28.useImperativeHandle(ctx == null ? void 0 : ctx.actionsRef, () => ({
    setOpen
  }), [setOpen]);
  React28.useEffect(() => {
    if (!open) {
      stickIfOpenTimeout.clear();
    }
  }, [stickIfOpenTimeout, open]);
  const floatingRootContext = useFloatingRootContext({
    elements: {
      reference: triggerElement,
      floating: positionerElement
    },
    open,
    onOpenChange: setOpen
  });
  floatingEvents = floatingRootContext.events;
  const hover = useHover(floatingRootContext, {
    enabled: hoverEnabled && openOnHover && !disabled && parent.type !== "context-menu" && (parent.type !== "menubar" || parent.context.hasSubmenuOpen && !open),
    handleClose: safePolygon({
      blockPointerEvents: true
    }),
    mouseOnly: true,
    move: parent.type === "menu",
    restMs: parent.type === void 0 || parent.type === "menu" && allowMouseEnter ? delay : void 0,
    delay: parent.type === "menu" ? {
      open: allowMouseEnter ? delay : 10 ** 10,
      close: closeDelay
    } : {
      close: closeDelay
    }
  });
  const focus = useFocus(floatingRootContext, {
    enabled: !disabled && !open && parent.type === "menubar" && parent.context.hasSubmenuOpen && !contextMenuContext
  });
  const click = useClick(floatingRootContext, {
    enabled: !disabled && parent.type !== "context-menu",
    event: open && parent.type === "menubar" ? "click" : "mousedown",
    toggle: !openOnHover || parent.type !== "menu",
    ignoreMouse: openOnHover && parent.type === "menu",
    stickIfOpen: parent.type === void 0 ? stickIfOpen : false
  });
  const dismiss = useDismiss(floatingRootContext, {
    enabled: !disabled,
    bubbles: closeParentOnEsc && parent.type === "menu",
    outsidePress() {
      var _a;
      if (parent.type !== "context-menu" || ((_a = openEventRef.current) == null ? void 0 : _a.type) === "contextmenu") {
        return true;
      }
      return allowOutsidePressDismissalRef.current;
    }
  });
  const role = useRole(floatingRootContext, {
    role: "menu"
  });
  const direction = useDirection();
  const listNavigation = useListNavigation(floatingRootContext, {
    enabled: !disabled,
    listRef: itemDomElements,
    activeIndex,
    nested: parent.type !== void 0,
    loop,
    orientation,
    parentOrientation: parent.type === "menubar" ? parent.context.orientation : void 0,
    rtl: direction === "rtl",
    disabledIndices: EMPTY_ARRAY2,
    onNavigate: setActiveIndex,
    openOnArrowKeyDown: parent.type !== "context-menu"
  });
  const typingRef = React28.useRef(false);
  const onTypingChange = React28.useCallback((nextTyping) => {
    typingRef.current = nextTyping;
  }, []);
  const typeahead = useTypeahead(floatingRootContext, {
    listRef: itemLabels,
    activeIndex,
    resetMs: TYPEAHEAD_RESET_MS,
    onMatch: (index) => {
      if (open && index !== activeIndex) {
        setActiveIndex(index);
      }
    },
    onTypingChange
  });
  const {
    getReferenceProps,
    getFloatingProps,
    getItemProps
  } = useInteractions([hover, click, dismiss, focus, role, listNavigation, typeahead]);
  const mixedToggleHandlers = useMixedToggleClickHandler({
    open,
    enabled: parent.type === "menubar",
    mouseDownAction: "open"
  });
  const triggerProps = React28.useMemo(() => {
    const referenceProps = mergeProps(getReferenceProps(), {
      onMouseEnter() {
        setHoverEnabled(true);
      },
      onMouseMove() {
        setAllowMouseEnter(true);
      }
    }, interactionTypeProps, mixedToggleHandlers);
    delete referenceProps.role;
    return referenceProps;
  }, [getReferenceProps, mixedToggleHandlers, setAllowMouseEnter, interactionTypeProps]);
  const popupProps = React28.useMemo(() => getFloatingProps({
    onMouseEnter() {
      if (!openOnHover || parent.type === "menu") {
        setHoverEnabled(false);
      }
    },
    onMouseMove() {
      setAllowMouseEnter(true);
    },
    onClick() {
      if (openOnHover) {
        setHoverEnabled(false);
      }
    }
  }), [getFloatingProps, openOnHover, parent.type, setAllowMouseEnter]);
  const itemProps = React28.useMemo(() => getItemProps(), [getItemProps]);
  const context = React28.useMemo(() => ({
    activeIndex,
    setActiveIndex,
    allowMouseUpTriggerRef: parent.type ? parent.context.allowMouseUpTriggerRef : EMPTY_REF,
    floatingRootContext,
    itemProps,
    popupProps,
    triggerProps,
    itemDomElements,
    itemLabels,
    mounted,
    open,
    popupRef,
    positionerRef,
    setOpen,
    setPositionerElement,
    triggerElement,
    setTriggerElement,
    transitionStatus,
    lastOpenChangeReason,
    instantType,
    onOpenChangeComplete,
    setHoverEnabled,
    typingRef,
    modal,
    disabled,
    parent,
    rootId,
    allowMouseEnter,
    setAllowMouseEnter
  }), [activeIndex, floatingRootContext, itemProps, popupProps, triggerProps, itemDomElements, itemLabels, mounted, open, positionerRef, setOpen, transitionStatus, triggerElement, setPositionerElement, lastOpenChangeReason, instantType, onOpenChangeComplete, modal, disabled, parent, rootId, allowMouseEnter, setAllowMouseEnter]);
  const content = (0, import_jsx_runtime9.jsx)(MenuRootContext.Provider, {
    value: context,
    children
  });
  if (parent.type === void 0 || parent.type === "context-menu") {
    return (0, import_jsx_runtime9.jsx)(FloatingTree, {
      children: content
    });
  }
  return content;
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/submenu-root/MenuSubmenuRoot.js
var React29 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function MenuSubmenuRoot(props) {
  const {
    closeParentOnEsc = false
  } = props;
  return (0, import_jsx_runtime10.jsx)(MenuSubmenuRootContext.Provider, {
    value: true,
    children: (0, import_jsx_runtime10.jsx)(MenuRoot, {
      closeParentOnEsc,
      ...props
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/trigger/MenuTrigger.js
var React30 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/composite/item/CompositeItem.js
function CompositeItem(componentProps) {
  const {
    render,
    className,
    state = EMPTY_OBJECT,
    props = EMPTY_ARRAY,
    refs = EMPTY_ARRAY,
    metadata,
    stateAttributesMapping: stateAttributesMapping3,
    tag = "div",
    ...elementProps
  } = componentProps;
  const {
    compositeProps,
    compositeRef
  } = useCompositeItem({
    metadata
  });
  return useRenderElement(tag, componentProps, {
    state,
    ref: [...refs, compositeRef],
    props: [compositeProps, ...props, elementProps],
    stateAttributesMapping: stateAttributesMapping3
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/utils/findRootOwnerId.js
function findRootOwnerId(node) {
  if (isHTMLElement(node) && node.hasAttribute("data-rootownerid")) {
    return node.getAttribute("data-rootownerid") ?? void 0;
  }
  if (isLastTraversableNode(node)) {
    return void 0;
  }
  return findRootOwnerId(getParentNode(node));
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/trigger/MenuTrigger.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var BOUNDARY_OFFSET = 2;
var MenuTrigger = React30.forwardRef(function MenuTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    triggerProps: rootTriggerProps,
    disabled: menuDisabled,
    setTriggerElement,
    open,
    allowMouseUpTriggerRef,
    positionerRef,
    parent,
    lastOpenChangeReason,
    rootId
  } = useMenuRootContext();
  const disabled = disabledProp || menuDisabled;
  const triggerRef = React30.useRef(null);
  const allowMouseUpTriggerTimeout = useTimeout();
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const handleRef = useMergedRefs(buttonRef, setTriggerElement);
  const {
    events: menuEvents
  } = useFloatingTree();
  React30.useEffect(() => {
    if (!open && parent.type === void 0) {
      allowMouseUpTriggerRef.current = false;
    }
  }, [allowMouseUpTriggerRef, open, parent.type]);
  const handleDocumentMouseUp = useEventCallback((mouseEvent) => {
    if (!triggerRef.current) {
      return;
    }
    allowMouseUpTriggerTimeout.clear();
    allowMouseUpTriggerRef.current = false;
    const mouseUpTarget = mouseEvent.target;
    if (contains(triggerRef.current, mouseUpTarget) || contains(positionerRef.current, mouseUpTarget) || mouseUpTarget === triggerRef.current) {
      return;
    }
    if (mouseUpTarget != null && findRootOwnerId(mouseUpTarget) === rootId) {
      return;
    }
    const bounds = getPseudoElementBounds(triggerRef.current);
    if (mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET) {
      return;
    }
    menuEvents.emit("close", {
      domEvent: mouseEvent,
      reason: "cancel-open"
    });
  });
  React30.useEffect(() => {
    if (open && lastOpenChangeReason === "trigger-hover") {
      const doc = ownerDocument(triggerRef.current);
      doc.addEventListener("mouseup", handleDocumentMouseUp, {
        once: true
      });
    }
  }, [open, handleDocumentMouseUp, lastOpenChangeReason]);
  const isMenubar = parent.type === "menubar";
  const getTriggerProps = React30.useCallback((externalProps) => {
    return mergeProps(isMenubar ? {
      role: "menuitem"
    } : {}, {
      "aria-haspopup": "menu",
      ref: handleRef,
      onMouseDown: (event) => {
        if (open) {
          return;
        }
        allowMouseUpTriggerTimeout.start(200, () => {
          allowMouseUpTriggerRef.current = true;
        });
        const doc = ownerDocument(event.currentTarget);
        doc.addEventListener("mouseup", handleDocumentMouseUp, {
          once: true
        });
      }
    }, externalProps, getButtonProps);
  }, [getButtonProps, handleRef, open, allowMouseUpTriggerRef, allowMouseUpTriggerTimeout, handleDocumentMouseUp, isMenubar]);
  const state = React30.useMemo(() => ({
    disabled,
    open
  }), [disabled, open]);
  const ref = [triggerRef, forwardedRef, buttonRef];
  const props = [rootTriggerProps, elementProps, getTriggerProps];
  const element = useRenderElement("button", componentProps, {
    enabled: !isMenubar,
    stateAttributesMapping: pressableTriggerOpenStateMapping,
    state,
    ref,
    props
  });
  if (isMenubar) {
    return (0, import_jsx_runtime11.jsx)(CompositeItem, {
      tag: "button",
      render,
      className,
      state,
      refs: ref,
      props,
      stateAttributesMapping: pressableTriggerOpenStateMapping
    });
  }
  return element;
});
if (true) MenuTrigger.displayName = "MenuTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menu/submenu-trigger/MenuSubmenuTrigger.js
var React31 = __toESM(require_react(), 1);
var MenuSubmenuTrigger = React31.forwardRef(function SubmenuTriggerComponent(componentProps, forwardedRef) {
  const {
    render,
    className,
    label,
    id: idProp,
    nativeButton = false,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const {
    triggerProps: rootTriggerProps,
    parent,
    setTriggerElement,
    open,
    typingRef,
    disabled,
    allowMouseUpTriggerRef
  } = useMenuRootContext();
  const menuPositionerContext = useMenuPositionerContext();
  if (parent.type !== "menu") {
    throw new Error("Base UI: <Menu.SubmenuTrigger> must be placed in <Menu.SubmenuRoot>.");
  }
  const parentMenuContext = parent.context;
  const {
    activeIndex,
    itemProps,
    setActiveIndex
  } = parentMenuContext;
  const item = useCompositeListItem();
  const highlighted = activeIndex === item.index;
  const {
    events: menuEvents
  } = useFloatingTree();
  const itemMetadata = React31.useMemo(() => ({
    type: "submenu-trigger",
    setActive: () => setActiveIndex(item.index),
    allowMouseEnterEnabled: parentMenuContext.allowMouseEnter
  }), [setActiveIndex, item.index, parentMenuContext.allowMouseEnter]);
  const {
    getItemProps,
    itemRef
  } = useMenuItem({
    closeOnClick: false,
    disabled,
    highlighted,
    id,
    menuEvents,
    allowMouseUpTriggerRef,
    typingRef,
    nativeButton,
    itemMetadata,
    nodeId: menuPositionerContext == null ? void 0 : menuPositionerContext.floatingContext.nodeId
  });
  const state = React31.useMemo(() => ({
    disabled,
    highlighted,
    open
  }), [disabled, highlighted, open]);
  return useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, item.ref, itemRef, setTriggerElement],
    stateAttributesMapping: triggerOpenStateMapping,
    props: [rootTriggerProps, itemProps, elementProps, getItemProps, {
      tabIndex: open || highlighted ? 0 : -1,
      onBlur() {
        if (highlighted) {
          setActiveIndex(null);
        }
      }
    }]
  });
});
if (true) MenuSubmenuTrigger.displayName = "MenuSubmenuTrigger";

export {
  useOpenInteractionType,
  ContextMenuRootContext,
  useContextMenuRootContext,
  MenuRootContext,
  MenuArrow,
  MenuBackdrop,
  MenuCheckboxItem,
  MenuCheckboxItemIndicator,
  MenuGroup,
  MenuGroupLabel,
  MenuItem,
  MenuPopup,
  MenuPortal,
  MenuPositioner,
  MenuRadioGroup,
  MenuRadioItem,
  MenuRadioItemIndicator,
  MenubarContext,
  useMenubarContext,
  MenuSubmenuRoot,
  CompositeItem,
  findRootOwnerId,
  MenuSubmenuTrigger,
  index_parts_exports
};
//# sourceMappingURL=chunk-X6RHBWHP.js.map
