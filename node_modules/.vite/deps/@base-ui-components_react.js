import {
  ACTIVE_COMPOSITE_ITEM,
  CompositeRoot,
  index_parts_exports as index_parts_exports6,
  isElementDisabled,
  useForcedRerendering
} from "./chunk-BF2GTL2Y.js";
import {
  CompositeItem,
  ContextMenuRootContext,
  MenuArrow,
  MenuBackdrop,
  MenuCheckboxItem,
  MenuCheckboxItemIndicator,
  MenuGroup,
  MenuGroupLabel,
  MenuItem,
  MenuPopup,
  MenuPortal,
  MenuPositioner,
  MenuRadioGroup,
  MenuRadioItem,
  MenuRadioItemIndicator,
  MenuRootContext,
  MenuSubmenuRoot,
  MenuSubmenuTrigger,
  MenubarContext,
  findRootOwnerId,
  index_parts_exports,
  useContextMenuRootContext,
  useMenubarContext,
  useOpenInteractionType
} from "./chunk-XQS6GK6O.js";
import "./chunk-YCZIVBMH.js";
import {
  index_parts_exports as index_parts_exports5
} from "./chunk-HYEMG2HK.js";
import {
  index_parts_exports as index_parts_exports7
} from "./chunk-7KVHI4C7.js";
import "./chunk-ZRSJIC2B.js";
import {
  Input
} from "./chunk-GT5BB7W5.js";
import {
  formatNumber,
  formatNumberMaxPrecision,
  getFormatter,
  index_parts_exports as index_parts_exports3,
  valueToPercent
} from "./chunk-IEPDE5NZ.js";
import {
  ReactStore,
  Store,
  compareItemEquality,
  createSelector,
  defaultItemEquality,
  findItemIndex,
  index_parts_exports as index_parts_exports4,
  isGroupedItems,
  itemIncludes,
  resolveSelectedLabel,
  stringifyAsLabel,
  stringifyAsValue,
  styleDisableScrollbar,
  useOnFirstRender,
  useStore,
  warn
} from "./chunk-ZXEDIBCZ.js";
import {
  InternalBackdrop,
  Separator,
  ToolbarRootContext,
  useScrollLock,
  useToolbarRootContext
} from "./chunk-E5UZCLZT.js";
import {
  ARROW_DOWN,
  ARROW_LEFT,
  ARROW_RIGHT,
  ARROW_UP,
  COMPOSITE_KEYS,
  CompositeList,
  END,
  HOME,
  IndexGuessBehavior,
  SHIFT,
  useCompositeListItem
} from "./chunk-IZQX5ZPK.js";
import "./chunk-DGUEW3E4.js";
import {
  inertValue
} from "./chunk-HC2V6TPM.js";
import {
  useButton,
  useFocusableWhenDisabled
} from "./chunk-PODRTBZK.js";
import {
  index_parts_exports as index_parts_exports8
} from "./chunk-DDNZ72ZY.js";
import {
  FloatingPortalLite
} from "./chunk-P7KM66P6.js";
import {
  CommonPopupDataAttributes,
  popupStateMapping,
  pressableTriggerOpenStateMapping,
  triggerOpenStateMapping,
  useAnchorPositioning,
  useTransitionStatus
} from "./chunk-7RNNSII3.js";
import {
  DirectionContext,
  useDirection
} from "./chunk-GJAGVRWM.js";
import {
  AnimationFrame,
  FloatingFocusManager,
  FloatingNode,
  FloatingPortal,
  FloatingTree,
  FocusGuard,
  TransitionStatusDataAttributes,
  getEmptyContext,
  safePolygon,
  transitionStatusMapping,
  useAnimationFrame,
  useAnimationsFinished,
  useClick,
  useDismiss,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useFloatingRootContext,
  useFloatingTree,
  useHover,
  useInteractions,
  useListNavigation,
  useOpenChangeComplete,
  useRole,
  useTypeahead
} from "./chunk-HPEQUUSL.js";
import {
  ownerDocument
} from "./chunk-3FELFY6H.js";
import {
  visuallyHidden
} from "./chunk-JLMIKHN4.js";
import {
  FieldsetRootContext,
  index_parts_exports as index_parts_exports2,
  useFieldsetRootContext
} from "./chunk-B2TO2O52.js";
import {
  FormContext,
  fieldValidityMapping,
  useField,
  useFieldControlValidation,
  useFieldRootContext,
  useFormContext
} from "./chunk-4XXPS7AP.js";
import "./chunk-H2NSF5IV.js";
import {
  useBaseUiId
} from "./chunk-EZX2H7FZ.js";
import {
  useControlled
} from "./chunk-NXVU5FCV.js";
import {
  activeElement,
  contains,
  disableFocusInside,
  enableFocusInside,
  getDocument,
  getNextTabbable,
  getNodeChildren,
  getPreviousTabbable,
  getSide,
  getTarget,
  isIOS,
  isOutsideEvent,
  isReactEvent,
  isTabbable,
  isWebKit,
  round,
  stopEvent
} from "./chunk-CSZZYMWP.js";
import {
  Timeout,
  useTimeout
} from "./chunk-ZDUACO7A.js";
import {
  createChangeEventDetails,
  createGenericEventDetails,
  getComputedStyle as getComputedStyle2,
  getWindow,
  isElement,
  isHTMLElement,
  useEventCallback,
  useOnMount
} from "./chunk-5VFA47B3.js";
import {
  useLatestRef
} from "./chunk-E6E6BQH7.js";
import {
  CLICK_TRIGGER_IDENTIFIER,
  DISABLED_TRANSITIONS_STYLE,
  DROPDOWN_COLLISION_AVOIDANCE,
  EMPTY_ARRAY,
  EMPTY_OBJECT,
  NOOP,
  PATIENT_CLICK_THRESHOLD,
  POPUP_COLLISION_AVOIDANCE,
  makeEventPreventable,
  mergeClassNames,
  mergeProps,
  mergePropsN,
  useId,
  useIsoLayoutEffect,
  useMergedRefs,
  useRefWithInit,
  useRenderElement
} from "./chunk-BNCDMTRQ.js";
import {
  require_react_dom
} from "./chunk-SXRIVT2P.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __export,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/index.parts.js
var index_parts_exports9 = {};
__export(index_parts_exports9, {
  Header: () => AccordionHeader,
  Item: () => AccordionItem,
  Panel: () => AccordionPanel,
  Root: () => AccordionRoot,
  Trigger: () => AccordionTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/root/AccordionRoot.js
var React2 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/root/AccordionRootContext.js
var React = __toESM(require_react(), 1);
var AccordionRootContext = React.createContext(void 0);
if (true) AccordionRootContext.displayName = "AccordionRootContext";
function useAccordionRootContext() {
  const context = React.useContext(AccordionRootContext);
  if (context === void 0) {
    throw new Error("Base UI: AccordionRootContext is missing. Accordion parts must be placed within <Accordion.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/root/AccordionRoot.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var rootStateAttributesMapping = {
  value: () => null
};
var AccordionRoot = React2.forwardRef(function AccordionRoot2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    hiddenUntilFound: hiddenUntilFoundProp,
    keepMounted: keepMountedProp,
    loop = true,
    onValueChange: onValueChangeProp,
    multiple = true,
    orientation = "vertical",
    value: valueProp,
    defaultValue: defaultValueProp,
    ...elementProps
  } = componentProps;
  const direction = useDirection();
  if (true) {
    useIsoLayoutEffect(() => {
      if (hiddenUntilFoundProp && keepMountedProp === false) {
        warn("The `keepMounted={false}` prop on a Accordion.Root will be ignored when using `hiddenUntilFound` since it requires Panels to remain mounted when closed.");
      }
    }, [hiddenUntilFoundProp, keepMountedProp]);
  }
  const defaultValue = React2.useMemo(() => {
    if (valueProp === void 0) {
      return defaultValueProp ?? [];
    }
    return void 0;
  }, [valueProp, defaultValueProp]);
  const onValueChange = useEventCallback(onValueChangeProp);
  const accordionItemRefs = React2.useRef([]);
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Accordion",
    state: "value"
  });
  const handleValueChange = React2.useCallback((newValue, nextOpen) => {
    const details = createChangeEventDetails("none");
    if (!multiple) {
      const nextValue = value[0] === newValue ? [] : [newValue];
      onValueChange(nextValue, details);
      if (details.isCanceled) {
        return;
      }
      setValue(nextValue);
    } else if (nextOpen) {
      const nextOpenValues = value.slice();
      nextOpenValues.push(newValue);
      onValueChange(nextOpenValues, details);
      if (details.isCanceled) {
        return;
      }
      setValue(nextOpenValues);
    } else {
      const nextOpenValues = value.filter((v) => v !== newValue);
      onValueChange(nextOpenValues, details);
      if (details.isCanceled) {
        return;
      }
      setValue(nextOpenValues);
    }
  }, [onValueChange, multiple, setValue, value]);
  const state = React2.useMemo(() => ({
    value,
    disabled,
    orientation
  }), [value, disabled, orientation]);
  const contextValue = React2.useMemo(() => ({
    accordionItemRefs,
    direction,
    disabled,
    handleValueChange,
    hiddenUntilFound: hiddenUntilFoundProp ?? false,
    keepMounted: keepMountedProp ?? false,
    loop,
    orientation,
    state,
    value
  }), [direction, disabled, handleValueChange, hiddenUntilFoundProp, keepMountedProp, loop, orientation, state, value]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      dir: direction,
      role: "region"
    }, elementProps],
    stateAttributesMapping: rootStateAttributesMapping
  });
  return (0, import_jsx_runtime.jsx)(AccordionRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(CompositeList, {
      elementsRef: accordionItemRefs,
      children: element
    })
  });
});
if (true) AccordionRoot.displayName = "AccordionRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/item/AccordionItem.js
var React6 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/root/useCollapsibleRoot.js
var React3 = __toESM(require_react(), 1);
function useCollapsibleRoot(parameters) {
  const {
    open: openParam,
    defaultOpen,
    onOpenChange,
    disabled
  } = parameters;
  const isControlled = openParam !== void 0;
  const [open, setOpen] = useControlled({
    controlled: openParam,
    default: defaultOpen,
    name: "Collapsible",
    state: "open"
  });
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open, true, true);
  const [visible, setVisible] = React3.useState(open);
  const [{
    height,
    width
  }, setDimensions] = React3.useState({
    height: void 0,
    width: void 0
  });
  const defaultPanelId = useBaseUiId();
  const [panelIdState, setPanelIdState] = React3.useState();
  const panelId = panelIdState ?? defaultPanelId;
  const [hiddenUntilFound, setHiddenUntilFound] = React3.useState(false);
  const [keepMounted, setKeepMounted] = React3.useState(false);
  const abortControllerRef = React3.useRef(null);
  const animationTypeRef = React3.useRef(null);
  const transitionDimensionRef = React3.useRef(null);
  const panelRef = React3.useRef(null);
  const runOnceAnimationsFinish = useAnimationsFinished(panelRef, false);
  const handleTrigger = useEventCallback((event) => {
    const nextOpen = !open;
    const eventDetails = createChangeEventDetails("trigger-press", event.nativeEvent);
    onOpenChange(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const panel = panelRef.current;
    if (animationTypeRef.current === "css-animation" && panel != null) {
      panel.style.removeProperty("animation-name");
    }
    if (!hiddenUntilFound && !keepMounted) {
      if (animationTypeRef.current != null && animationTypeRef.current !== "css-animation") {
        if (!mounted && nextOpen) {
          setMounted(true);
        }
      }
      if (animationTypeRef.current === "css-animation") {
        if (!visible && nextOpen) {
          setVisible(true);
        }
        if (!mounted && nextOpen) {
          setMounted(true);
        }
      }
    }
    setOpen(nextOpen);
    if (animationTypeRef.current === "none" && mounted && !nextOpen) {
      setMounted(false);
    }
  });
  useIsoLayoutEffect(() => {
    if (isControlled && animationTypeRef.current === "none" && !keepMounted && !open) {
      setMounted(false);
    }
  }, [isControlled, keepMounted, open, openParam, setMounted]);
  return React3.useMemo(() => ({
    abortControllerRef,
    animationTypeRef,
    disabled,
    handleTrigger,
    height,
    mounted,
    open,
    panelId,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setHiddenUntilFound,
    setKeepMounted,
    setMounted,
    setOpen,
    setPanelIdState,
    setVisible,
    transitionDimensionRef,
    transitionStatus,
    visible,
    width
  }), [abortControllerRef, animationTypeRef, disabled, handleTrigger, height, mounted, open, panelId, panelRef, runOnceAnimationsFinish, setDimensions, setHiddenUntilFound, setKeepMounted, setMounted, setOpen, setVisible, transitionDimensionRef, transitionStatus, visible, width]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/root/CollapsibleRootContext.js
var React4 = __toESM(require_react(), 1);
var CollapsibleRootContext = React4.createContext(void 0);
if (true) CollapsibleRootContext.displayName = "CollapsibleRootContext";
function useCollapsibleRootContext() {
  const context = React4.useContext(CollapsibleRootContext);
  if (context === void 0) {
    throw new Error("Base UI: CollapsibleRootContext is missing. Collapsible parts must be placed within <Collapsible.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/item/AccordionItemContext.js
var React5 = __toESM(require_react(), 1);
var AccordionItemContext = React5.createContext(void 0);
if (true) AccordionItemContext.displayName = "AccordionItemContext";
function useAccordionItemContext() {
  const context = React5.useContext(AccordionItemContext);
  if (context === void 0) {
    throw new Error("Base UI: AccordionItemContext is missing. Accordion parts must be placed within <Accordion.Item>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/panel/CollapsiblePanelDataAttributes.js
var CollapsiblePanelDataAttributes = (function(CollapsiblePanelDataAttributes2) {
  CollapsiblePanelDataAttributes2["open"] = "data-open";
  CollapsiblePanelDataAttributes2["closed"] = "data-closed";
  CollapsiblePanelDataAttributes2[CollapsiblePanelDataAttributes2["startingStyle"] = TransitionStatusDataAttributes.startingStyle] = "startingStyle";
  CollapsiblePanelDataAttributes2[CollapsiblePanelDataAttributes2["endingStyle"] = TransitionStatusDataAttributes.endingStyle] = "endingStyle";
  return CollapsiblePanelDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/trigger/CollapsibleTriggerDataAttributes.js
var CollapsibleTriggerDataAttributes = (function(CollapsibleTriggerDataAttributes2) {
  CollapsibleTriggerDataAttributes2["panelOpen"] = "data-panel-open";
  return CollapsibleTriggerDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/collapsibleOpenStateMapping.js
var PANEL_OPEN_HOOK = {
  [CollapsiblePanelDataAttributes.open]: ""
};
var PANEL_CLOSED_HOOK = {
  [CollapsiblePanelDataAttributes.closed]: ""
};
var triggerOpenStateMapping2 = {
  open(value) {
    if (value) {
      return {
        [CollapsibleTriggerDataAttributes.panelOpen]: ""
      };
    }
    return null;
  }
};
var collapsibleOpenStateMapping = {
  open(value) {
    if (value) {
      return PANEL_OPEN_HOOK;
    }
    return PANEL_CLOSED_HOOK;
  }
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/item/AccordionItemDataAttributes.js
var AccordionItemDataAttributes = (function(AccordionItemDataAttributes2) {
  AccordionItemDataAttributes2["index"] = "data-index";
  AccordionItemDataAttributes2["disabled"] = "data-disabled";
  AccordionItemDataAttributes2["open"] = "data-open";
  return AccordionItemDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/item/stateAttributesMapping.js
var accordionStateAttributesMapping = {
  ...collapsibleOpenStateMapping,
  index: (value) => {
    return Number.isInteger(value) ? {
      [AccordionItemDataAttributes.index]: String(value)
    } : null;
  },
  ...transitionStatusMapping,
  value: () => null
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/item/AccordionItem.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var AccordionItem = React6.forwardRef(function AccordionItem2(componentProps, forwardedRef) {
  const {
    className,
    disabled: disabledProp = false,
    onOpenChange: onOpenChangeProp,
    render,
    value: valueProp,
    ...elementProps
  } = componentProps;
  const {
    ref: listItemRef,
    index
  } = useCompositeListItem();
  const mergedRef = useMergedRefs(forwardedRef, listItemRef);
  const {
    disabled: contextDisabled,
    handleValueChange,
    state: rootState,
    value: openValues
  } = useAccordionRootContext();
  const fallbackValue = useBaseUiId();
  const value = valueProp ?? fallbackValue;
  const disabled = disabledProp || contextDisabled;
  const isOpen = React6.useMemo(() => {
    if (!openValues) {
      return false;
    }
    for (let i = 0; i < openValues.length; i += 1) {
      if (openValues[i] === value) {
        return true;
      }
    }
    return false;
  }, [openValues, value]);
  const onOpenChange = useEventCallback((nextOpen, eventDetails) => {
    onOpenChangeProp == null ? void 0 : onOpenChangeProp(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    handleValueChange(value, nextOpen);
  });
  const collapsible = useCollapsibleRoot({
    open: isOpen,
    onOpenChange,
    disabled
  });
  const collapsibleState = React6.useMemo(() => ({
    open: collapsible.open,
    disabled: collapsible.disabled,
    hidden: !collapsible.mounted
  }), [collapsible.open, collapsible.disabled, collapsible.mounted]);
  const collapsibleContext = React6.useMemo(() => ({
    ...collapsible,
    onOpenChange,
    state: collapsibleState,
    transitionStatus: collapsible.transitionStatus
  }), [collapsible, collapsibleState, onOpenChange]);
  const state = React6.useMemo(() => ({
    ...rootState,
    index,
    disabled,
    open: isOpen
  }), [disabled, index, isOpen, rootState]);
  const [triggerId, setTriggerId] = React6.useState(useBaseUiId());
  const accordionItemContext = React6.useMemo(() => ({
    open: isOpen,
    state,
    setTriggerId,
    triggerId
  }), [isOpen, state, setTriggerId, triggerId]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: mergedRef,
    props: elementProps,
    stateAttributesMapping: accordionStateAttributesMapping
  });
  return (0, import_jsx_runtime2.jsx)(CollapsibleRootContext.Provider, {
    value: collapsibleContext,
    children: (0, import_jsx_runtime2.jsx)(AccordionItemContext.Provider, {
      value: accordionItemContext,
      children: element
    })
  });
});
if (true) AccordionItem.displayName = "AccordionItem";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/header/AccordionHeader.js
var React7 = __toESM(require_react(), 1);
var AccordionHeader = React7.forwardRef(function AccordionHeader2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useAccordionItemContext();
  const element = useRenderElement("h3", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: accordionStateAttributesMapping
  });
  return element;
});
if (true) AccordionHeader.displayName = "AccordionHeader";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/trigger/AccordionTrigger.js
var React8 = __toESM(require_react(), 1);
var SUPPORTED_KEYS = /* @__PURE__ */ new Set([ARROW_DOWN, ARROW_UP, ARROW_RIGHT, ARROW_LEFT, HOME, END]);
function getActiveTriggers(accordionItemRefs) {
  const {
    current: accordionItemElements
  } = accordionItemRefs;
  const output = [];
  for (let i = 0; i < accordionItemElements.length; i += 1) {
    const section = accordionItemElements[i];
    if (!isElementDisabled(section)) {
      const trigger = section == null ? void 0 : section.querySelector('[type="button"]');
      if (!isElementDisabled(trigger)) {
        output.push(trigger);
      }
    }
  }
  return output;
}
var AccordionTrigger = React8.forwardRef(function AccordionTrigger2(componentProps, forwardedRef) {
  const {
    disabled: disabledProp,
    className,
    id: idProp,
    render,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    panelId,
    open,
    handleTrigger,
    disabled: contextDisabled
  } = useCollapsibleRootContext();
  const disabled = disabledProp ?? contextDisabled;
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    native: nativeButton
  });
  const {
    accordionItemRefs,
    direction,
    loop,
    orientation
  } = useAccordionRootContext();
  const isRtl = direction === "rtl";
  const isHorizontal = orientation === "horizontal";
  const {
    state,
    setTriggerId,
    triggerId: id
  } = useAccordionItemContext();
  useIsoLayoutEffect(() => {
    if (idProp) {
      setTriggerId(idProp);
    }
    return () => {
      setTriggerId(void 0);
    };
  }, [idProp, setTriggerId]);
  const props = React8.useMemo(() => ({
    "aria-controls": open ? panelId : void 0,
    "aria-expanded": open,
    disabled,
    id,
    onClick: handleTrigger,
    onKeyDown(event) {
      if (!SUPPORTED_KEYS.has(event.key)) {
        return;
      }
      stopEvent(event);
      const triggers = getActiveTriggers(accordionItemRefs);
      const numOfEnabledTriggers = triggers.length;
      const lastIndex = numOfEnabledTriggers - 1;
      let nextIndex = -1;
      const thisIndex = triggers.indexOf(event.target);
      function toNext() {
        if (loop) {
          nextIndex = thisIndex + 1 > lastIndex ? 0 : thisIndex + 1;
        } else {
          nextIndex = Math.min(thisIndex + 1, lastIndex);
        }
      }
      function toPrev() {
        if (loop) {
          nextIndex = thisIndex === 0 ? lastIndex : thisIndex - 1;
        } else {
          nextIndex = thisIndex - 1;
        }
      }
      switch (event.key) {
        case ARROW_DOWN:
          if (!isHorizontal) {
            toNext();
          }
          break;
        case ARROW_UP:
          if (!isHorizontal) {
            toPrev();
          }
          break;
        case ARROW_RIGHT:
          if (isHorizontal) {
            if (isRtl) {
              toPrev();
            } else {
              toNext();
            }
          }
          break;
        case ARROW_LEFT:
          if (isHorizontal) {
            if (isRtl) {
              toNext();
            } else {
              toPrev();
            }
          }
          break;
        case "Home":
          nextIndex = 0;
          break;
        case "End":
          nextIndex = lastIndex;
          break;
        default:
          break;
      }
      if (nextIndex > -1) {
        triggers[nextIndex].focus();
      }
    }
  }), [accordionItemRefs, disabled, handleTrigger, id, isHorizontal, isRtl, loop, open, panelId]);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, buttonRef],
    props: [props, elementProps, getButtonProps],
    stateAttributesMapping: triggerOpenStateMapping2
  });
  return element;
});
if (true) AccordionTrigger.displayName = "AccordionTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/panel/AccordionPanel.js
var React10 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/panel/useCollapsiblePanel.js
var React9 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/root/AccordionRootDataAttributes.js
var AccordionRootDataAttributes = (function(AccordionRootDataAttributes2) {
  AccordionRootDataAttributes2["disabled"] = "data-disabled";
  AccordionRootDataAttributes2["orientation"] = "data-orientation";
  return AccordionRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/panel/useCollapsiblePanel.js
function useCollapsiblePanel(parameters) {
  const {
    abortControllerRef,
    animationTypeRef,
    externalRef,
    height,
    hiddenUntilFound,
    keepMounted,
    id: idParam,
    mounted,
    onOpenChange,
    open,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setMounted,
    setOpen,
    setVisible,
    transitionDimensionRef,
    visible,
    width
  } = parameters;
  const isBeforeMatchRef = React9.useRef(false);
  const latestAnimationNameRef = React9.useRef(null);
  const shouldCancelInitialOpenAnimationRef = React9.useRef(open);
  const shouldCancelInitialOpenTransitionRef = React9.useRef(open);
  const hidden = React9.useMemo(() => {
    if (animationTypeRef.current === "css-animation") {
      return !visible;
    }
    return !open && !mounted;
  }, [open, mounted, visible, animationTypeRef]);
  const handlePanelRef = useEventCallback((element) => {
    if (!element) {
      return void 0;
    }
    if (animationTypeRef.current == null || transitionDimensionRef.current == null) {
      const panelStyles = getComputedStyle(element);
      const hasAnimation = panelStyles.animationName !== "none" && panelStyles.animationName !== "";
      const hasTransition = panelStyles.transitionDuration !== "0s" && panelStyles.transitionDuration !== "";
      if (hasAnimation && hasTransition) {
        if (true) {
          warn("CSS transitions and CSS animations both detected on Collapsible or Accordion panel.", "Only one of either animation type should be used.");
        }
      } else if (panelStyles.animationName === "none" && panelStyles.transitionDuration !== "0s") {
        animationTypeRef.current = "css-transition";
      } else if (panelStyles.animationName !== "none" && panelStyles.transitionDuration === "0s") {
        animationTypeRef.current = "css-animation";
      } else {
        animationTypeRef.current = "none";
      }
      if (element.getAttribute(AccordionRootDataAttributes.orientation) === "horizontal" || panelStyles.transitionProperty.indexOf("width") > -1) {
        transitionDimensionRef.current = "width";
      } else {
        transitionDimensionRef.current = "height";
      }
    }
    if (animationTypeRef.current !== "css-transition") {
      return void 0;
    }
    element.style.setProperty("display", getComputedStyle(element).display || "block", "important");
    if (height === void 0 || width === void 0) {
      setDimensions({
        height: element.scrollHeight,
        width: element.scrollWidth
      });
      element.style.removeProperty("display");
      if (shouldCancelInitialOpenTransitionRef.current) {
        element.style.setProperty("transition-duration", "0s");
      }
    }
    let frame = -1;
    let nextFrame = -1;
    frame = AnimationFrame.request(() => {
      shouldCancelInitialOpenTransitionRef.current = false;
      nextFrame = AnimationFrame.request(() => {
        setTimeout(() => {
          element.style.removeProperty("transition-duration");
        });
      });
    });
    return () => {
      AnimationFrame.cancel(frame);
      AnimationFrame.cancel(nextFrame);
    };
  });
  const mergedPanelRef = useMergedRefs(externalRef, panelRef, handlePanelRef);
  useIsoLayoutEffect(() => {
    if (animationTypeRef.current !== "css-transition") {
      return void 0;
    }
    const panel = panelRef.current;
    if (!panel) {
      return void 0;
    }
    let resizeFrame = -1;
    if (abortControllerRef.current != null) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    if (open) {
      const originalLayoutStyles = {
        "justify-content": panel.style.justifyContent,
        "align-items": panel.style.alignItems,
        "align-content": panel.style.alignContent,
        "justify-items": panel.style.justifyItems
      };
      panel.style.setProperty("display", getComputedStyle(panel).display || "block", "important");
      Object.keys(originalLayoutStyles).forEach((key) => {
        panel.style.setProperty(key, "initial", "important");
      });
      if (!shouldCancelInitialOpenTransitionRef.current && !keepMounted) {
        panel.setAttribute(CollapsiblePanelDataAttributes.startingStyle, "");
      }
      setDimensions({
        height: panel.scrollHeight,
        width: panel.scrollWidth
      });
      resizeFrame = AnimationFrame.request(() => {
        panel.style.removeProperty("display");
        Object.entries(originalLayoutStyles).forEach(([key, value]) => {
          if (value === "") {
            panel.style.removeProperty(key);
          } else {
            panel.style.setProperty(key, value);
          }
        });
      });
    } else {
      setDimensions({
        height: panel.scrollHeight,
        width: panel.scrollWidth
      });
      abortControllerRef.current = new AbortController();
      const signal = abortControllerRef.current.signal;
      let frame2 = -1;
      const frame1 = AnimationFrame.request(() => {
        frame2 = AnimationFrame.request(() => {
          runOnceAnimationsFinish(() => {
            setDimensions({
              height: 0,
              width: 0
            });
            panel.style.removeProperty("content-visibility");
            panel.style.removeProperty("display");
            setMounted(false);
            abortControllerRef.current = null;
          }, signal);
        });
      });
      return () => {
        AnimationFrame.cancel(frame1);
        AnimationFrame.cancel(frame2);
      };
    }
    return () => {
      AnimationFrame.cancel(resizeFrame);
    };
  }, [abortControllerRef, animationTypeRef, hiddenUntilFound, keepMounted, mounted, open, panelRef, runOnceAnimationsFinish, setDimensions, setMounted, transitionDimensionRef]);
  useIsoLayoutEffect(() => {
    if (animationTypeRef.current !== "css-animation") {
      return;
    }
    const panel = panelRef.current;
    if (!panel) {
      return;
    }
    latestAnimationNameRef.current = panel.style.animationName || latestAnimationNameRef.current;
    panel.style.setProperty("animation-name", "none");
    setDimensions({
      height: panel.scrollHeight,
      width: panel.scrollWidth
    });
    if (!shouldCancelInitialOpenAnimationRef.current && !isBeforeMatchRef.current) {
      panel.style.removeProperty("animation-name");
    }
    if (open) {
      if (abortControllerRef.current != null) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      setMounted(true);
      setVisible(true);
    } else {
      abortControllerRef.current = new AbortController();
      runOnceAnimationsFinish(() => {
        setMounted(false);
        setVisible(false);
        abortControllerRef.current = null;
      }, abortControllerRef.current.signal);
    }
  }, [abortControllerRef, animationTypeRef, open, panelRef, runOnceAnimationsFinish, setDimensions, setMounted, setVisible, visible]);
  useOnMount(() => {
    const frame = AnimationFrame.request(() => {
      shouldCancelInitialOpenAnimationRef.current = false;
    });
    return () => AnimationFrame.cancel(frame);
  });
  useIsoLayoutEffect(() => {
    if (!hiddenUntilFound) {
      return void 0;
    }
    const panel = panelRef.current;
    if (!panel) {
      return void 0;
    }
    let frame = -1;
    let nextFrame = -1;
    if (open && isBeforeMatchRef.current) {
      panel.style.transitionDuration = "0s";
      setDimensions({
        height: panel.scrollHeight,
        width: panel.scrollWidth
      });
      frame = AnimationFrame.request(() => {
        isBeforeMatchRef.current = false;
        nextFrame = AnimationFrame.request(() => {
          setTimeout(() => {
            panel.style.removeProperty("transition-duration");
          });
        });
      });
    }
    return () => {
      AnimationFrame.cancel(frame);
      AnimationFrame.cancel(nextFrame);
    };
  }, [hiddenUntilFound, open, panelRef, setDimensions]);
  useIsoLayoutEffect(() => {
    const panel = panelRef.current;
    if (panel && hiddenUntilFound && hidden) {
      panel.setAttribute("hidden", "until-found");
      if (animationTypeRef.current === "css-transition") {
        panel.setAttribute(CollapsiblePanelDataAttributes.startingStyle, "");
      }
    }
  }, [hiddenUntilFound, hidden, animationTypeRef, panelRef]);
  React9.useEffect(function registerBeforeMatchListener() {
    const panel = panelRef.current;
    if (!panel) {
      return void 0;
    }
    function handleBeforeMatch(event) {
      isBeforeMatchRef.current = true;
      setOpen(true);
      onOpenChange(true, createChangeEventDetails("none", event));
    }
    panel.addEventListener("beforematch", handleBeforeMatch);
    return () => {
      panel.removeEventListener("beforematch", handleBeforeMatch);
    };
  }, [onOpenChange, panelRef, setOpen]);
  return React9.useMemo(() => ({
    props: {
      hidden,
      id: idParam,
      ref: mergedPanelRef
    }
  }), [hidden, idParam, mergedPanelRef]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/panel/AccordionPanelCssVars.js
var AccordionPanelCssVars = (function(AccordionPanelCssVars2) {
  AccordionPanelCssVars2["accordionPanelHeight"] = "--accordion-panel-height";
  AccordionPanelCssVars2["accordionPanelWidth"] = "--accordion-panel-width";
  return AccordionPanelCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/accordion/panel/AccordionPanel.js
var AccordionPanel = React10.forwardRef(function AccordionPanel2(componentProps, forwardedRef) {
  const {
    className,
    hiddenUntilFound: hiddenUntilFoundProp,
    keepMounted: keepMountedProp,
    id: idProp,
    render,
    ...elementProps
  } = componentProps;
  const {
    hiddenUntilFound: contextHiddenUntilFound,
    keepMounted: contextKeepMounted
  } = useAccordionRootContext();
  const {
    abortControllerRef,
    animationTypeRef,
    height,
    mounted,
    onOpenChange,
    open,
    panelId,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setHiddenUntilFound,
    setKeepMounted,
    setMounted,
    setOpen,
    setVisible,
    transitionDimensionRef,
    visible,
    width,
    setPanelIdState,
    transitionStatus
  } = useCollapsibleRootContext();
  const hiddenUntilFound = hiddenUntilFoundProp ?? contextHiddenUntilFound;
  const keepMounted = keepMountedProp ?? contextKeepMounted;
  if (true) {
    useIsoLayoutEffect(() => {
      if (keepMountedProp === false && hiddenUntilFound) {
        warn("The `keepMounted={false}` prop on a Accordion.Panel will be ignored when using `contextHiddenUntilFound` on the Panel or the Root since it requires the panel to remain mounted when closed.");
      }
    }, [hiddenUntilFound, keepMountedProp]);
  }
  useIsoLayoutEffect(() => {
    if (idProp) {
      setPanelIdState(idProp);
      return () => {
        setPanelIdState(void 0);
      };
    }
    return void 0;
  }, [idProp, setPanelIdState]);
  useIsoLayoutEffect(() => {
    setHiddenUntilFound(hiddenUntilFound);
  }, [setHiddenUntilFound, hiddenUntilFound]);
  useIsoLayoutEffect(() => {
    setKeepMounted(keepMounted);
  }, [setKeepMounted, keepMounted]);
  useOpenChangeComplete({
    open: open && transitionStatus === "idle",
    ref: panelRef,
    onComplete() {
      if (!open) {
        return;
      }
      setDimensions({
        width: void 0,
        height: void 0
      });
    }
  });
  const {
    props
  } = useCollapsiblePanel({
    abortControllerRef,
    animationTypeRef,
    externalRef: forwardedRef,
    height,
    hiddenUntilFound,
    id: idProp ?? panelId,
    keepMounted,
    mounted,
    onOpenChange,
    open,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setMounted,
    setOpen,
    setVisible,
    transitionDimensionRef,
    visible,
    width
  });
  const {
    state,
    triggerId
  } = useAccordionItemContext();
  const panelState = React10.useMemo(() => ({
    ...state,
    transitionStatus
  }), [state, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    state: panelState,
    ref: [forwardedRef, panelRef],
    props: [props, {
      "aria-labelledby": triggerId,
      role: "region",
      style: {
        [AccordionPanelCssVars.accordionPanelHeight]: height === void 0 ? "auto" : `${height}px`,
        [AccordionPanelCssVars.accordionPanelWidth]: width === void 0 ? "auto" : `${width}px`
      }
    }, elementProps],
    stateAttributesMapping: accordionStateAttributesMapping
  });
  const shouldRender = keepMounted || hiddenUntilFound || !keepMounted && mounted;
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) AccordionPanel.displayName = "AccordionPanel";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/index.parts.js
var index_parts_exports10 = {};
__export(index_parts_exports10, {
  Backdrop: () => AlertDialogBackdrop,
  Close: () => AlertDialogClose,
  Description: () => AlertDialogDescription,
  Popup: () => AlertDialogPopup,
  Portal: () => AlertDialogPortal,
  Root: () => AlertDialogRoot,
  Title: () => AlertDialogTitle,
  Trigger: () => AlertDialogTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/backdrop/AlertDialogBackdrop.js
var React12 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/root/DialogRootContext.js
var React11 = __toESM(require_react(), 1);
var DialogRootContext = React11.createContext(void 0);
if (true) DialogRootContext.displayName = "DialogRootContext";
function useDialogRootContext(optional) {
  const dialogRootContext = React11.useContext(DialogRootContext);
  if (optional === false && dialogRootContext === void 0) {
    throw new Error("Base UI: DialogRootContext is missing. Dialog parts must be placed within <Dialog.Root>.");
  }
  return dialogRootContext;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/backdrop/AlertDialogBackdrop.js
var stateAttributesMapping = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var AlertDialogBackdrop = React12.forwardRef(function AlertDialogBackdrop2(componentProps, forwardedRef) {
  const {
    render,
    className,
    forceRender = false,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const open = store.useState("open");
  const nested = store.useState("nested");
  const mounted = store.useState("mounted");
  const transitionStatus = store.useState("transitionStatus");
  const state = React12.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  return useRenderElement("div", componentProps, {
    state,
    ref: [store.context.backdropRef, forwardedRef],
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps],
    stateAttributesMapping,
    enabled: forceRender || !nested
  });
});
if (true) AlertDialogBackdrop.displayName = "AlertDialogBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/close/AlertDialogClose.js
var React13 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/close/useDialogClose.js
function useDialogClose(params) {
  const {
    open,
    setOpen,
    disabled,
    nativeButton
  } = params;
  const handleClick = useEventCallback((event) => {
    if (open) {
      setOpen(false, createChangeEventDetails("close-press", event.nativeEvent));
    }
  });
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const getRootProps = (externalProps) => mergeProps({
    onClick: handleClick
  }, externalProps, getButtonProps);
  return {
    getRootProps,
    ref: buttonRef
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/close/AlertDialogClose.js
var AlertDialogClose = React13.forwardRef(function AlertDialogClose2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const open = store.useState("open");
  const {
    getRootProps,
    ref
  } = useDialogClose({
    disabled,
    open,
    setOpen: store.setOpen,
    nativeButton
  });
  const state = React13.useMemo(() => ({
    disabled
  }), [disabled]);
  return useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, ref],
    props: [elementProps, getRootProps]
  });
});
if (true) AlertDialogClose.displayName = "AlertDialogClose";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/description/AlertDialogDescription.js
var React14 = __toESM(require_react(), 1);
var AlertDialogDescription = React14.forwardRef(function AlertDialogDescription2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const id = useBaseUiId(idProp);
  store.useSyncedValueWithCleanup("descriptionElementId", id);
  return useRenderElement("p", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
});
if (true) AlertDialogDescription.displayName = "AlertDialogDescription";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/popup/AlertDialogPopup.js
var React16 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/popup/AlertDialogPopupCssVars.js
var AlertDialogPopupCssVars = (function(AlertDialogPopupCssVars2) {
  AlertDialogPopupCssVars2["nestedDialogs"] = "--nested-dialogs";
  return AlertDialogPopupCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/popup/AlertDialogPopupDataAttributes.js
var AlertDialogPopupDataAttributes = (function(AlertDialogPopupDataAttributes2) {
  AlertDialogPopupDataAttributes2[AlertDialogPopupDataAttributes2["open"] = CommonPopupDataAttributes.open] = "open";
  AlertDialogPopupDataAttributes2[AlertDialogPopupDataAttributes2["closed"] = CommonPopupDataAttributes.closed] = "closed";
  AlertDialogPopupDataAttributes2[AlertDialogPopupDataAttributes2["startingStyle"] = CommonPopupDataAttributes.startingStyle] = "startingStyle";
  AlertDialogPopupDataAttributes2[AlertDialogPopupDataAttributes2["endingStyle"] = CommonPopupDataAttributes.endingStyle] = "endingStyle";
  AlertDialogPopupDataAttributes2["nested"] = "data-nested";
  AlertDialogPopupDataAttributes2["nestedDialogOpen"] = "data-nested-dialog-open";
  return AlertDialogPopupDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/portal/AlertDialogPortalContext.js
var React15 = __toESM(require_react(), 1);
var AlertDialogPortalContext = React15.createContext(void 0);
if (true) AlertDialogPortalContext.displayName = "AlertDialogPortalContext";
function useAlertDialogPortalContext() {
  const value = React15.useContext(AlertDialogPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <AlertDialog.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/popup/AlertDialogPopup.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping2 = {
  ...popupStateMapping,
  ...transitionStatusMapping,
  nestedDialogOpen(value) {
    return value ? {
      [AlertDialogPopupDataAttributes.nestedDialogOpen]: ""
    } : null;
  }
};
var AlertDialogPopup = React16.forwardRef(function AlertDialogPopup2(componentProps, forwardedRef) {
  const {
    className,
    render,
    initialFocus,
    finalFocus,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const descriptionElementId = store.useState("descriptionElementId");
  const floatingRootContext = store.useState("floatingRootContext");
  const rootPopupProps = store.useState("popupProps");
  const mounted = store.useState("mounted");
  const nested = store.useState("nested");
  const nestedOpenDialogCount = store.useState("nestedOpenDialogCount");
  const open = store.useState("open");
  const titleElementId = store.useState("titleElementId");
  const transitionStatus = store.useState("transitionStatus");
  useAlertDialogPortalContext();
  useOpenChangeComplete({
    open,
    ref: store.context.popupRef,
    onComplete() {
      var _a, _b;
      if (open) {
        (_b = (_a = store.context).openChangeComplete) == null ? void 0 : _b.call(_a, true);
      }
    }
  });
  const defaultInitialFocus = useEventCallback((interactionType) => {
    if (interactionType === "touch") {
      return store.context.popupRef.current;
    }
    return true;
  });
  const resolvedInitialFocus = initialFocus === void 0 ? defaultInitialFocus : initialFocus;
  const nestedDialogOpen = nestedOpenDialogCount > 0;
  const state = React16.useMemo(() => ({
    open,
    nested,
    transitionStatus,
    nestedDialogOpen
  }), [open, nested, transitionStatus, nestedDialogOpen]);
  const element = useRenderElement("div", componentProps, {
    state,
    props: [rootPopupProps, {
      "aria-labelledby": titleElementId ?? void 0,
      "aria-describedby": descriptionElementId ?? void 0,
      role: "alertdialog",
      tabIndex: -1,
      hidden: !mounted,
      onKeyDown(event) {
        if (COMPOSITE_KEYS.has(event.key)) {
          event.stopPropagation();
        }
      },
      style: {
        [AlertDialogPopupCssVars.nestedDialogs]: nestedOpenDialogCount
      }
    }, elementProps],
    ref: [forwardedRef, store.context.popupRef, store.getElementSetter("popupElement")],
    stateAttributesMapping: stateAttributesMapping2
  });
  return (0, import_jsx_runtime3.jsxs)(React16.Fragment, {
    children: [mounted && (0, import_jsx_runtime3.jsx)(InternalBackdrop, {
      ref: store.context.internalBackdropRef,
      inert: inertValue(!open)
    }), (0, import_jsx_runtime3.jsx)(FloatingFocusManager, {
      context: floatingRootContext,
      disabled: !mounted,
      initialFocus: resolvedInitialFocus,
      returnFocus: finalFocus,
      children: element
    })]
  });
});
if (true) AlertDialogPopup.displayName = "AlertDialogPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/portal/AlertDialogPortal.js
var React17 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function AlertDialogPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    store
  } = useDialogRootContext();
  const mounted = store.useState("mounted");
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime4.jsx)(AlertDialogPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime4.jsx)(FloatingPortal, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/root/AlertDialogRoot.js
var React20 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/root/useDialogRoot.js
var React18 = __toESM(require_react(), 1);
function useDialogRoot(params) {
  const {
    store,
    parentContext
  } = params;
  const open = store.useState("open");
  const dismissible = store.useState("dismissible");
  const modal = store.useState("modal");
  const triggerElement = store.useState("triggerElement");
  const popupElement = store.useState("popupElement");
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  const {
    openMethod,
    triggerProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(open);
  const handleUnmount = useEventCallback(() => {
    var _a, _b;
    setMounted(false);
    (_b = (_a = store.context).openChangeComplete) == null ? void 0 : _b.call(_a, false);
    resetOpenInteractionType();
  });
  useOpenChangeComplete({
    enabled: !params.actionsRef,
    open,
    ref: store.context.popupRef,
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  React18.useImperativeHandle(params.actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  const context = useFloatingRootContext({
    elements: {
      reference: triggerElement,
      floating: popupElement
    },
    open,
    onOpenChange: store.setOpen,
    noEmit: true
  });
  const [ownNestedOpenDialogs, setOwnNestedOpenDialogs] = React18.useState(0);
  const isTopmost = ownNestedOpenDialogs === 0;
  const role = useRole(context);
  const click = useClick(context);
  const dismiss = useDismiss(context, {
    outsidePressEvent() {
      if (store.context.internalBackdropRef.current || store.context.backdropRef.current) {
        return "intentional";
      }
      return {
        mouse: modal === "trap-focus" ? "sloppy" : "intentional",
        touch: "sloppy"
      };
    },
    outsidePress(event) {
      if (event.button !== 0) {
        return false;
      }
      const target = getTarget(event);
      if (isTopmost && dismissible) {
        const eventTarget = target;
        if (modal) {
          return store.context.internalBackdropRef.current || store.context.backdropRef.current ? store.context.internalBackdropRef.current === eventTarget || store.context.backdropRef.current === eventTarget : true;
        }
        return true;
      }
      return false;
    },
    escapeKey: isTopmost
  });
  useScrollLock({
    enabled: open && modal === true,
    mounted,
    open,
    referenceElement: popupElement
  });
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([role, click, dismiss]);
  store.useContextCallback("nestedDialogOpen", (ownChildrenCount) => {
    setOwnNestedOpenDialogs(ownChildrenCount + 1);
  });
  store.useContextCallback("nestedDialogClose", () => {
    setOwnNestedOpenDialogs(0);
  });
  React18.useEffect(() => {
    if ((parentContext == null ? void 0 : parentContext.nestedDialogOpen) && open) {
      parentContext.nestedDialogOpen(ownNestedOpenDialogs);
    }
    if ((parentContext == null ? void 0 : parentContext.nestedDialogClose) && !open) {
      parentContext.nestedDialogClose();
    }
    return () => {
      if ((parentContext == null ? void 0 : parentContext.nestedDialogClose) && open) {
        parentContext.nestedDialogClose();
      }
    };
  }, [open, parentContext, ownNestedOpenDialogs]);
  const dialogTriggerProps = React18.useMemo(() => getReferenceProps(triggerProps), [getReferenceProps, triggerProps]);
  store.useSyncedValues({
    openMethod,
    mounted,
    transitionStatus,
    triggerProps: dialogTriggerProps,
    popupProps: getFloatingProps(),
    floatingRootContext: context,
    nestedOpenDialogCount: ownNestedOpenDialogs
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/store.js
var React19 = __toESM(require_react(), 1);
var selectors = {
  open: createSelector((state) => state.open),
  modal: createSelector((state) => state.modal),
  nested: createSelector((state) => state.nested),
  nestedOpenDialogCount: createSelector((state) => state.nestedOpenDialogCount),
  dismissible: createSelector((state) => state.dismissible),
  openMethod: createSelector((state) => state.openMethod),
  descriptionElementId: createSelector((state) => state.descriptionElementId),
  titleElementId: createSelector((state) => state.titleElementId),
  mounted: createSelector((state) => state.mounted),
  transitionStatus: createSelector((state) => state.transitionStatus),
  triggerProps: createSelector((state) => state.triggerProps),
  popupProps: createSelector((state) => state.popupProps),
  floatingRootContext: createSelector((state) => state.floatingRootContext),
  popupElement: createSelector((state) => state.popupElement),
  triggerElement: createSelector((state) => state.triggerElement)
};
var DialogStore = class _DialogStore extends ReactStore {
  constructor() {
    super(...arguments);
    __publicField(this, "setOpen", (nextOpen, eventDetails) => {
      var _a, _b, _c;
      (_b = (_a = this.context).openChange) == null ? void 0 : _b.call(_a, nextOpen, eventDetails);
      if (eventDetails.isCanceled) {
        return;
      }
      const details = {
        open: nextOpen,
        nativeEvent: eventDetails.event,
        reason: eventDetails.reason,
        nested: this.state.nested
      };
      (_c = this.state.floatingRootContext.events) == null ? void 0 : _c.emit("openchange", details);
      this.set("open", nextOpen);
    });
  }
  static create(initialState) {
    const context = {
      popupRef: React19.createRef(),
      backdropRef: React19.createRef(),
      internalBackdropRef: React19.createRef()
    };
    return new _DialogStore(initialState, context, selectors);
  }
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/root/AlertDialogRoot.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var INITIAL_STATE = {
  open: false,
  dismissible: false,
  nested: false,
  popupElement: null,
  triggerElement: null,
  modal: true,
  descriptionElementId: void 0,
  titleElementId: void 0,
  openMethod: null,
  mounted: false,
  transitionStatus: "idle",
  nestedOpenDialogCount: 0,
  triggerProps: EMPTY_OBJECT,
  popupProps: EMPTY_OBJECT,
  floatingRootContext: getEmptyContext()
};
var AlertDialogRoot = function AlertDialogRoot2(props) {
  const {
    children,
    defaultOpen = false,
    onOpenChange,
    onOpenChangeComplete,
    open: openProp,
    actionsRef
  } = props;
  const parentDialogRootContext = useDialogRootContext();
  const nested = Boolean(parentDialogRootContext);
  const store = useRefWithInit(DialogStore.create, INITIAL_STATE).current;
  store.useControlledProp("open", openProp, defaultOpen);
  store.useSyncedValue("nested", nested);
  store.useContextCallback("openChange", onOpenChange);
  store.useContextCallback("openChangeComplete", onOpenChangeComplete);
  useDialogRoot({
    store,
    actionsRef,
    parentContext: parentDialogRootContext == null ? void 0 : parentDialogRootContext.store.context,
    onOpenChange
  });
  const contextValue = React20.useMemo(() => ({
    store
  }), [store]);
  return (0, import_jsx_runtime5.jsx)(DialogRootContext.Provider, {
    value: contextValue,
    children
  });
};
if (true) AlertDialogRoot.displayName = "AlertDialogRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/title/AlertDialogTitle.js
var React21 = __toESM(require_react(), 1);
var AlertDialogTitle = React21.forwardRef(function AlertDialogTitle2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const id = useBaseUiId(idProp);
  store.useSyncedValueWithCleanup("titleElementId", id);
  return useRenderElement("h2", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
});
if (true) AlertDialogTitle.displayName = "AlertDialogTitle";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/alert-dialog/trigger/AlertDialogTrigger.js
var React22 = __toESM(require_react(), 1);
var AlertDialogTrigger = React22.forwardRef(function AlertDialogTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const open = store.useState("open");
  const triggerProps = store.useState("triggerProps");
  const state = React22.useMemo(() => ({
    disabled,
    open
  }), [disabled, open]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  return useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, buttonRef, store.getElementSetter("triggerElement")],
    stateAttributesMapping: triggerOpenStateMapping,
    props: [triggerProps, elementProps, getButtonProps]
  });
});
if (true) AlertDialogTrigger.displayName = "AlertDialogTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/autocomplete/index.parts.js
var index_parts_exports11 = {};
__export(index_parts_exports11, {
  Arrow: () => ComboboxArrow,
  Backdrop: () => ComboboxBackdrop,
  Clear: () => ComboboxClear,
  Collection: () => ComboboxCollection,
  Empty: () => ComboboxEmpty,
  Group: () => ComboboxGroup,
  GroupLabel: () => ComboboxGroupLabel,
  Icon: () => ComboboxIcon,
  Input: () => ComboboxInput,
  Item: () => ComboboxItem,
  List: () => ComboboxList,
  Popup: () => ComboboxPopup,
  Portal: () => ComboboxPortal,
  Positioner: () => ComboboxPositioner,
  Root: () => AutocompleteRoot,
  Row: () => ComboboxRow,
  Separator: () => Separator,
  Status: () => ComboboxStatus,
  Trigger: () => ComboboxTrigger,
  Value: () => AutocompleteValue,
  useFilter: () => useCoreFilter
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/autocomplete/root/AutocompleteRoot.js
var React26 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/ComboboxRootInternal.js
var React25 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/ComboboxRootContext.js
var React23 = __toESM(require_react(), 1);
var ComboboxRootContext = React23.createContext(void 0);
if (true) ComboboxRootContext.displayName = "ComboboxRootContext";
var ComboboxFloatingContext = React23.createContext(void 0);
if (true) ComboboxFloatingContext.displayName = "ComboboxFloatingContext";
var ComboboxDerivedItemsContext = React23.createContext(void 0);
if (true) ComboboxDerivedItemsContext.displayName = "ComboboxDerivedItemsContext";
var ComboboxInputValueContext = React23.createContext("");
if (true) ComboboxInputValueContext.displayName = "ComboboxInputValueContext";
function useComboboxRootContext() {
  const context = React23.useContext(ComboboxRootContext);
  if (!context) {
    throw new Error("Base UI: ComboboxRootContext is missing. Combobox parts must be placed within <Combobox.Root>.");
  }
  return context;
}
function useComboboxFloatingContext() {
  const context = React23.useContext(ComboboxFloatingContext);
  if (!context) {
    throw new Error("Base UI: ComboboxFloatingContext is missing. Combobox parts must be placed within <Combobox.Root>.");
  }
  return context;
}
function useComboboxDerivedItemsContext() {
  const context = React23.useContext(ComboboxDerivedItemsContext);
  if (!context) {
    throw new Error("Base UI: ComboboxItemsContext is missing. Combobox parts must be placed within <Combobox.Root>.");
  }
  return context;
}
function useComboboxInputValueContext() {
  return React23.useContext(ComboboxInputValueContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/store.js
var selectors2 = {
  id: createSelector((state) => state.id),
  query: createSelector((state) => state.query),
  items: createSelector((state) => state.items),
  selectedValue: createSelector((state) => state.selectedValue),
  inputValue: createSelector((state) => state.inputValue),
  open: createSelector((state) => state.open),
  mounted: createSelector((state) => state.mounted),
  forceMounted: createSelector((state) => state.forceMounted),
  inline: createSelector((state) => state.inline),
  activeIndex: createSelector((state) => state.activeIndex),
  selectedIndex: createSelector((state) => state.selectedIndex),
  isActive: createSelector((state, index) => state.activeIndex === index),
  isSelected: createSelector((state, candidate) => {
    const comparer = state.isItemEqualToValue;
    const selectedValue = state.selectedValue;
    if (Array.isArray(selectedValue)) {
      return selectedValue.some((value) => compareItemEquality(value, candidate, comparer));
    }
    return compareItemEquality(selectedValue, candidate, comparer);
  }),
  transitionStatus: createSelector((state) => state.transitionStatus),
  popupProps: createSelector((state) => state.popupProps),
  inputProps: createSelector((state) => state.inputProps),
  triggerProps: createSelector((state) => state.triggerProps),
  typeaheadTriggerProps: createSelector((state) => state.typeaheadTriggerProps),
  getItemProps: createSelector((state) => state.getItemProps),
  positionerElement: createSelector((state) => state.positionerElement),
  listElement: createSelector((state) => state.listElement),
  triggerElement: createSelector((state) => state.triggerElement),
  inputElement: createSelector((state) => state.inputElement),
  openMethod: createSelector((state) => state.openMethod),
  inputInsidePopup: createSelector((state) => state.inputInsidePopup),
  selectionMode: createSelector((state) => state.selectionMode),
  listRef: createSelector((state) => state.listRef),
  popupRef: createSelector((state) => state.popupRef),
  inputRef: createSelector((state) => state.inputRef),
  keyboardActiveRef: createSelector((state) => state.keyboardActiveRef),
  chipsContainerRef: createSelector((state) => state.chipsContainerRef),
  clearRef: createSelector((state) => state.clearRef),
  valuesRef: createSelector((state) => state.valuesRef),
  allValuesRef: createSelector((state) => state.allValuesRef),
  name: createSelector((state) => state.name),
  disabled: createSelector((state) => state.disabled),
  readOnly: createSelector((state) => state.readOnly),
  required: createSelector((state) => state.required),
  fieldControlValidation: createSelector((state) => state.fieldControlValidation),
  grid: createSelector((state) => state.grid),
  isGrouped: createSelector((state) => state.isGrouped),
  virtualized: createSelector((state) => state.virtualized),
  onOpenChangeComplete: createSelector((state) => state.onOpenChangeComplete),
  openOnInputClick: createSelector((state) => state.openOnInputClick),
  itemToStringLabel: createSelector((state) => state.itemToStringLabel),
  isItemEqualToValue: createSelector((state) => state.isItemEqualToValue),
  modal: createSelector((state) => state.modal),
  autoHighlight: createSelector((state) => state.autoHighlight),
  alwaysSubmitOnEnter: createSelector((state) => state.alwaysSubmitOnEnter)
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/utils/index.js
function createCollatorItemFilter(collatorFilter, itemToStringLabel) {
  return (item, query) => {
    if (item == null) {
      return false;
    }
    const itemString = stringifyAsLabel(item, itemToStringLabel);
    return collatorFilter.contains(itemString, query);
  };
}
function createSingleSelectionCollatorFilter(collatorFilter, itemToStringLabel, selectedValue) {
  return (item, query) => {
    if (item == null) {
      return false;
    }
    if (!query) {
      return true;
    }
    const itemString = stringifyAsLabel(item, itemToStringLabel);
    const selectedString = selectedValue != null ? stringifyAsLabel(selectedValue, itemToStringLabel) : "";
    if (selectedString && collatorFilter.contains(selectedString, query) && selectedString.length === query.length) {
      return true;
    }
    return collatorFilter.contains(itemString, query);
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/utils/useFilter.js
var React24 = __toESM(require_react(), 1);
var filterCache = /* @__PURE__ */ new Map();
function getFilter(options = {}) {
  const mergedOptions = {
    usage: "search",
    sensitivity: "base",
    ignorePunctuation: true,
    ...options
  };
  const optionsString = JSON.stringify(mergedOptions);
  const cachedFilter = filterCache.get(optionsString);
  if (cachedFilter) {
    return cachedFilter;
  }
  const collator = new Intl.Collator(options.locale, mergedOptions);
  const filter = {
    contains(item, query) {
      if (!query) {
        return true;
      }
      for (let i = 0; i <= item.length - query.length; i += 1) {
        if (collator.compare(item.slice(i, i + query.length), query) === 0) {
          return true;
        }
      }
      return false;
    },
    startsWith(item, query) {
      if (!query) {
        return true;
      }
      return collator.compare(item.slice(0, query.length), query) === 0;
    },
    endsWith(item, query) {
      if (!query) {
        return true;
      }
      const queryLength = query.length;
      return item.length >= queryLength && collator.compare(item.slice(item.length - queryLength), query) === 0;
    }
  };
  filterCache.set(optionsString, filter);
  return filter;
}
var useCoreFilter = getFilter;
function useComboboxFilter(options = {}) {
  const {
    multiple = false,
    value,
    ...collatorOptions
  } = options;
  const coreFilter = getFilter(collatorOptions);
  const contains2 = React24.useCallback((item, query, itemToStringLabel) => {
    if (multiple) {
      return createCollatorItemFilter(coreFilter, itemToStringLabel)(item, query);
    }
    return createSingleSelectionCollatorFilter(coreFilter, itemToStringLabel, value)(item, query);
  }, [coreFilter, value, multiple]);
  return React24.useMemo(() => ({
    contains: contains2,
    startsWith: coreFilter.startsWith,
    endsWith: coreFilter.endsWith
  }), [contains2, coreFilter]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/utils/useValueChanged.js
function useValueChanged(valueRef, value, onChangeParam) {
  const onChange = useEventCallback(onChangeParam);
  useIsoLayoutEffect(() => {
    if (valueRef.current === value) {
      return;
    }
    onChange(valueRef.current);
  }, [valueRef, value, onChange]);
  useIsoLayoutEffect(() => {
    valueRef.current = value;
  }, [valueRef, value]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/ComboboxRootInternal.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function ComboboxRootInternal(props) {
  const {
    id: idProp,
    onOpenChangeComplete: onOpenChangeCompleteProp,
    defaultSelectedValue = null,
    selectedValue: selectedValueProp,
    onSelectedValueChange,
    defaultInputValue: defaultInputValueProp,
    inputValue: inputValueProp,
    selectionMode = "none",
    onItemHighlighted: onItemHighlightedProp,
    name: nameProp,
    disabled: disabledProp = false,
    readOnly = false,
    required = false,
    inputRef: inputRefProp,
    grid = false,
    items,
    filter: filterProp,
    openOnInputClick = true,
    autoHighlight = false,
    itemToStringLabel,
    itemToStringValue,
    isItemEqualToValue = defaultItemEquality,
    virtualized = false,
    fillInputOnItemPress = true,
    modal = false,
    limit = -1,
    autoComplete = "list",
    locale,
    alwaysSubmitOnEnter = false
  } = props;
  const {
    clearErrors
  } = useFormContext();
  const {
    setDirty,
    validityData,
    validationMode,
    setControlId,
    setFilled,
    name: fieldName,
    disabled: fieldDisabled
  } = useFieldRootContext();
  const fieldControlValidation = useFieldControlValidation();
  const id = useBaseUiId(idProp);
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const multiple = selectionMode === "multiple";
  const hasInputValue = inputValueProp !== void 0 || defaultInputValueProp !== void 0;
  const commitValidation = fieldControlValidation.commitValidation;
  useIsoLayoutEffect(() => {
    setControlId(id);
    return () => {
      setControlId(void 0);
    };
  }, [id, setControlId]);
  const [selectedValue, setSelectedValueUnwrapped] = useControlled({
    controlled: selectedValueProp,
    default: multiple ? defaultSelectedValue ?? EMPTY_ARRAY : defaultSelectedValue,
    name: "Combobox",
    state: "selectedValue"
  });
  const [queryChangedAfterOpen, setQueryChangedAfterOpen] = React25.useState(false);
  const collatorFilter = useCoreFilter({
    locale
  });
  const filter = React25.useMemo(() => {
    if (filterProp === null) {
      return () => true;
    }
    if (filterProp !== void 0) {
      return filterProp;
    }
    if (selectionMode === "single" && !queryChangedAfterOpen) {
      return createSingleSelectionCollatorFilter(collatorFilter, itemToStringLabel, selectedValue);
    }
    return createCollatorItemFilter(collatorFilter, itemToStringLabel);
  }, [filterProp, selectionMode, selectedValue, queryChangedAfterOpen, collatorFilter, itemToStringLabel]);
  const initialDefaultInputValue = useRefWithInit(() => {
    if (hasInputValue) {
      return defaultInputValueProp ?? "";
    }
    if (selectionMode === "single") {
      return stringifyAsLabel(selectedValue, itemToStringLabel);
    }
    return "";
  }).current;
  const [inputValue, setInputValueUnwrapped] = useControlled({
    controlled: inputValueProp,
    default: initialDefaultInputValue,
    name: "Combobox",
    state: "value"
  });
  const [open, setOpenUnwrapped] = useControlled({
    controlled: props.open,
    default: props.defaultOpen,
    name: "Combobox",
    state: "open"
  });
  const [closeQuery, setCloseQuery] = React25.useState(null);
  const query = closeQuery ?? (inputValue === "" ? "" : String(inputValue).trim());
  const isGrouped = isGroupedItems(items);
  const flatItems = React25.useMemo(() => {
    if (!items) {
      return EMPTY_ARRAY;
    }
    if (isGrouped) {
      return items.flatMap((group) => group.items);
    }
    return items;
  }, [items, isGrouped]);
  const filteredItems = React25.useMemo(() => {
    if (!items) {
      return [];
    }
    if (isGrouped) {
      const groupedItems = items;
      const resultingGroups = [];
      let currentCount = 0;
      for (const group of groupedItems) {
        if (limit > -1 && currentCount >= limit) {
          break;
        }
        const candidateItems = query === "" ? group.items : group.items.filter((item) => filter(item, query, itemToStringLabel));
        if (candidateItems.length === 0) {
          continue;
        }
        const remainingLimit = limit > -1 ? limit - currentCount : Infinity;
        const itemsToTake = candidateItems.slice(0, remainingLimit);
        if (itemsToTake.length > 0) {
          const newGroup = {
            ...group,
            items: itemsToTake
          };
          resultingGroups.push(newGroup);
          currentCount += itemsToTake.length;
        }
      }
      return resultingGroups;
    }
    if (query === "") {
      return limit > -1 ? flatItems.slice(0, limit) : (
        // The cast here is done as `flatItems` is readonly.
        // valuesRef.current, a mutable ref, can be set to `flatFilteredItems`, which may
        // reference this exact readonly value, creating a mutation risk.
        // However, <Combobox.Item> can never mutate this value as the mutating effect
        // bails early when `items` is provided, and this is only ever returned
        // when `items` is provided due to the early return at the top of this hook.
        flatItems
      );
    }
    const limitedItems = [];
    for (const item of flatItems) {
      if (limit > -1 && limitedItems.length >= limit) {
        break;
      }
      if (filter(item, query, itemToStringLabel)) {
        limitedItems.push(item);
      }
    }
    return limitedItems;
  }, [items, flatItems, query, filter, isGrouped, itemToStringLabel, limit]);
  const flatFilteredItems = React25.useMemo(() => {
    if (isGrouped) {
      const groups = filteredItems;
      return groups.flatMap((g) => g.items);
    }
    return filteredItems;
  }, [filteredItems, isGrouped]);
  const hasItems = items !== void 0;
  const listRef = React25.useRef([]);
  const labelsRef = React25.useRef([]);
  const popupRef = React25.useRef(null);
  const inputRef = React25.useRef(null);
  const keyboardActiveRef = React25.useRef(true);
  const hadInputClearRef = React25.useRef(false);
  const chipsContainerRef = React25.useRef(null);
  const clearRef = React25.useRef(null);
  const selectionEventRef = React25.useRef(null);
  const valuesRef = React25.useRef([]);
  const allValuesRef = React25.useRef([]);
  const store = useRefWithInit(() => new Store({
    id,
    selectedValue,
    inputValue,
    open,
    filter,
    query,
    items,
    selectionMode,
    listRef,
    popupRef,
    inputRef,
    keyboardActiveRef,
    chipsContainerRef,
    clearRef,
    valuesRef,
    allValuesRef,
    selectionEventRef,
    name,
    disabled,
    readOnly,
    required,
    fieldControlValidation,
    grid,
    isGrouped,
    virtualized,
    openOnInputClick,
    itemToStringLabel,
    isItemEqualToValue,
    modal,
    autoHighlight,
    alwaysSubmitOnEnter,
    hasInputValue,
    mounted: false,
    forceMounted: false,
    transitionStatus: "idle",
    inline: false,
    activeIndex: null,
    selectedIndex: null,
    popupProps: {},
    inputProps: {},
    triggerProps: {},
    typeaheadTriggerProps: {},
    positionerElement: null,
    listElement: null,
    triggerElement: null,
    inputElement: null,
    openMethod: null,
    inputInsidePopup: true,
    onOpenChangeComplete: onOpenChangeCompleteProp || NOOP,
    // Placeholder callbacks replaced on first render
    setOpen: NOOP,
    setInputValue: NOOP,
    setSelectedValue: NOOP,
    setIndices: NOOP,
    onItemHighlighted: NOOP,
    handleSelection: NOOP,
    getItemProps() {
      return {};
    },
    forceMount: NOOP
  })).current;
  const onItemHighlighted = useEventCallback(onItemHighlightedProp);
  const onOpenChangeComplete = useEventCallback(onOpenChangeCompleteProp);
  const activeIndex = useStore(store, selectors2.activeIndex);
  const selectedIndex = useStore(store, selectors2.selectedIndex);
  const positionerElement = useStore(store, selectors2.positionerElement);
  const listElement = useStore(store, selectors2.listElement);
  const triggerElement = useStore(store, selectors2.triggerElement);
  const inputElement = useStore(store, selectors2.inputElement);
  const inline = useStore(store, selectors2.inline);
  const inputInsidePopup = useStore(store, selectors2.inputInsidePopup);
  const queryRef = React25.useRef(query);
  const selectedValueRef = React25.useRef(selectedValue);
  const inputValueRef = React25.useRef(inputValue);
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  const {
    openMethod,
    triggerProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(open);
  const forceMount = useEventCallback(() => {
    if (items) {
      labelsRef.current = flatFilteredItems.map((item) => stringifyAsLabel(item, itemToStringLabel));
    } else {
      store.set("forceMounted", true);
    }
  });
  const initialSelectedValueRef = React25.useRef(selectedValue);
  useIsoLayoutEffect(() => {
    if (selectedValue !== initialSelectedValueRef.current) {
      forceMount();
    }
  }, [forceMount, selectedValue, initialSelectedValueRef]);
  const updateValue = useEventCallback((nextValue) => {
    clearErrors(name);
    setDirty(nextValue !== validityData.initialValue);
  });
  const formValue = selectionMode === "none" ? inputValue : selectedValue;
  useField({
    id,
    commitValidation,
    value: formValue,
    controlRef: inputRef,
    name,
    getValue: () => formValue
  });
  useIsoLayoutEffect(() => {
    if (items) {
      valuesRef.current = flatFilteredItems;
      listRef.current.length = flatFilteredItems.length;
    }
  }, [items, flatFilteredItems]);
  useIsoLayoutEffect(() => {
    if (!items || selectionMode === "none") {
      return;
    }
    const registry = flatItems;
    if (multiple) {
      const current = Array.isArray(selectedValue) ? selectedValue : EMPTY_ARRAY;
      const next = current.filter((v) => itemIncludes(registry, v, store.state.isItemEqualToValue));
      if (next.length !== current.length) {
        setSelectedValueUnwrapped(next);
      }
      return;
    }
    const isStillPresent = selectedValue == null ? true : itemIncludes(registry, selectedValue, store.state.isItemEqualToValue);
    if (isStillPresent) {
      return;
    }
    let fallback = null;
    if (defaultSelectedValue != null && itemIncludes(registry, defaultSelectedValue, store.state.isItemEqualToValue)) {
      fallback = defaultSelectedValue;
    }
    setSelectedValueUnwrapped(fallback);
    if (!store.state.inputInsidePopup) {
      const stringVal = stringifyAsLabel(fallback, itemToStringLabel);
      if (inputRef.current && inputRef.current.value !== stringVal) {
        setInputValueUnwrapped(stringVal);
      }
    }
  }, [items, flatItems, multiple, selectionMode, selectedValue, defaultSelectedValue, setSelectedValueUnwrapped, setInputValueUnwrapped, itemToStringLabel, store]);
  useValueChanged(queryRef, query, () => {
    if (!open || query === "" || query === String(initialDefaultInputValue)) {
      return;
    }
    setQueryChangedAfterOpen(true);
  });
  useValueChanged(selectedValueRef, selectedValue, () => {
    if (selectionMode === "none") {
      return;
    }
    clearErrors(name);
    commitValidation == null ? void 0 : commitValidation(selectedValue, true);
    if (validationMode === "onChange") {
      commitValidation == null ? void 0 : commitValidation(selectedValue);
    }
    updateValue(selectedValue);
  });
  useValueChanged(inputValueRef, inputValue, () => {
    if (selectionMode !== "none") {
      return;
    }
    clearErrors(name);
    commitValidation == null ? void 0 : commitValidation(inputValue, true);
    if (validationMode === "onChange") {
      commitValidation == null ? void 0 : commitValidation(inputValue);
    }
    updateValue(inputValue);
  });
  useIsoLayoutEffect(() => {
    if (selectionMode === "none") {
      setFilled(String(inputValue) !== "");
    } else {
      setFilled(multiple ? Array.isArray(selectedValue) && selectedValue.length > 0 : selectedValue != null);
    }
  }, [setFilled, selectionMode, inputValue, selectedValue, multiple]);
  const setIndices = useEventCallback((options) => {
    store.apply(options);
    const type = options.type || "none";
    if (options.activeIndex === void 0) {
      return;
    }
    if (options.activeIndex === null) {
      onItemHighlighted(void 0, createGenericEventDetails(type, void 0, {
        index: -1
      }));
    } else {
      const activeValue = valuesRef.current[options.activeIndex];
      onItemHighlighted(activeValue, createGenericEventDetails(type, void 0, {
        index: options.activeIndex
      }));
    }
  });
  const setInputValue = useEventCallback((next, eventDetails) => {
    var _a;
    hadInputClearRef.current = eventDetails.reason === "input-clear";
    (_a = props.onInputValueChange) == null ? void 0 : _a.call(props, next, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    if (eventDetails.reason === "input-change") {
      const hasQuery = next.trim() !== "";
      if (hasQuery) {
        setQueryChangedAfterOpen(true);
      }
      if (hasQuery) {
        if (autoHighlight) {
          setIndices({
            activeIndex: 0,
            selectedIndex: null
          });
        } else {
          setIndices({
            selectedIndex: null
          });
        }
      } else if (autoHighlight) {
        setIndices({
          activeIndex: null
        });
      }
    }
    setInputValueUnwrapped(next);
  });
  const setOpen = useEventCallback((nextOpen, eventDetails) => {
    var _a;
    if (open === nextOpen) {
      return;
    }
    (_a = props.onOpenChange) == null ? void 0 : _a.call(props, nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    if (!nextOpen && queryChangedAfterOpen) {
      if (selectionMode === "single") {
        setCloseQuery(query);
        if (query === "") {
          setQueryChangedAfterOpen(false);
        }
      } else if (selectionMode === "multiple") {
        if (inline || inputInsidePopup) {
          setIndices({
            activeIndex: null
          });
        } else {
          setCloseQuery(query);
        }
        setInputValue("", createChangeEventDetails("input-clear", eventDetails.event));
      }
    }
    setOpenUnwrapped(nextOpen);
  });
  const setSelectedValue = useEventCallback((nextValue, eventDetails) => {
    onSelectedValueChange == null ? void 0 : onSelectedValueChange(nextValue, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setSelectedValueUnwrapped(nextValue);
    const shouldFillInput = selectionMode === "none" && popupRef.current && fillInputOnItemPress || selectionMode === "single" && !store.state.inputInsidePopup;
    if (shouldFillInput) {
      setInputValue(stringifyAsLabel(nextValue, itemToStringLabel), createChangeEventDetails(eventDetails.reason, eventDetails.event));
    }
    if (selectionMode === "single" && nextValue != null && eventDetails.reason !== "input-change" && queryChangedAfterOpen) {
      setCloseQuery(query);
    }
  });
  const syncSelectedIndex = useEventCallback(() => {
    if (selectionMode === "none") {
      return;
    }
    const registry = items ? flatItems : allValuesRef.current;
    if (multiple) {
      const currentValue = Array.isArray(selectedValue) ? selectedValue : [];
      const lastValue = currentValue[currentValue.length - 1];
      const lastIndex = findItemIndex(registry, lastValue, isItemEqualToValue);
      setIndices({
        selectedIndex: lastIndex === -1 ? null : lastIndex
      });
    } else {
      const index = findItemIndex(registry, selectedValue, isItemEqualToValue);
      setIndices({
        selectedIndex: index === -1 ? null : index
      });
    }
  });
  useIsoLayoutEffect(() => {
    if (!open) {
      syncSelectedIndex();
    }
  }, [open, selectedValue, syncSelectedIndex]);
  const handleSelection = useEventCallback((event, passedValue) => {
    var _a;
    let value = passedValue;
    if (value === void 0) {
      if (activeIndex === null) {
        return;
      }
      value = valuesRef.current[activeIndex];
    }
    const targetEl = getTarget(event);
    const overrideEvent = selectionEventRef.current ?? event;
    selectionEventRef.current = null;
    const eventDetails = createChangeEventDetails("item-press", overrideEvent);
    const href = (_a = targetEl == null ? void 0 : targetEl.closest("a")) == null ? void 0 : _a.getAttribute("href");
    if (href) {
      if (href.startsWith("#")) {
        setOpen(false, eventDetails);
      }
      return;
    }
    if (multiple) {
      const currentSelectedValue = Array.isArray(selectedValue) ? selectedValue : [];
      const isCurrentlySelected = currentSelectedValue.includes(value);
      const nextValue = isCurrentlySelected ? currentSelectedValue.filter((v) => v !== value) : [...currentSelectedValue, value];
      setSelectedValue(nextValue, eventDetails);
      const wasFiltering = inputRef.current ? inputRef.current.value.trim() !== "" : false;
      if (!wasFiltering) {
        return;
      }
      if (store.state.inputInsidePopup) {
        setInputValue("", createChangeEventDetails("input-clear", eventDetails.event));
      } else {
        setOpen(false, eventDetails);
      }
    } else {
      setSelectedValue(value, eventDetails);
      setOpen(false, eventDetails);
    }
  });
  const handleUnmount = useEventCallback(() => {
    setMounted(false);
    onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(false);
    setQueryChangedAfterOpen(false);
    resetOpenInteractionType();
    setCloseQuery(null);
    if (selectionMode === "none") {
      setIndices({
        activeIndex: null,
        selectedIndex: null
      });
    } else {
      setIndices({
        activeIndex: null
      });
    }
    if (selectionMode === "multiple" && inputRef.current && inputRef.current.value !== "" && !hadInputClearRef.current) {
      setInputValue("", createChangeEventDetails("input-clear"));
    }
    if (selectionMode === "single") {
      if (store.state.inputInsidePopup) {
        if (inputRef.current && inputRef.current.value !== "") {
          setInputValue("", createChangeEventDetails("input-clear"));
        }
      } else {
        const stringVal = stringifyAsLabel(selectedValue, itemToStringLabel);
        if (inputRef.current && inputRef.current.value !== stringVal) {
          const reason = stringVal === "" ? "input-clear" : "none";
          setInputValue(stringVal, createChangeEventDetails(reason));
        }
      }
    }
  });
  useOpenChangeComplete({
    enabled: !props.actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  React25.useImperativeHandle(props.actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  React25.useEffect(() => {
    if (hasItems && autoHighlight && flatFilteredItems.length === 0) {
      setIndices({
        activeIndex: null
      });
    }
  }, [hasItems, autoHighlight, flatFilteredItems.length, setIndices]);
  const floatingRootContext = useFloatingRootContext({
    open: inline ? true : open,
    onOpenChange: setOpen,
    elements: {
      reference: inputInsidePopup ? triggerElement : inputElement,
      floating: positionerElement
    }
  });
  let ariaHasPopup;
  let ariaExpanded;
  if (!inline) {
    ariaHasPopup = grid ? "grid" : "listbox";
    ariaExpanded = open ? "true" : "false";
  }
  const role = React25.useMemo(() => {
    const isPlainInput = (inputElement == null ? void 0 : inputElement.tagName) === "INPUT";
    const shouldApplyAria = isPlainInput || open;
    const reference = isPlainInput ? {
      autoComplete: "off",
      spellCheck: "false",
      autoCorrect: "off",
      autoCapitalize: "none"
    } : {};
    if (shouldApplyAria) {
      reference.role = "combobox";
      reference["aria-expanded"] = ariaExpanded;
      reference["aria-haspopup"] = ariaHasPopup;
      reference["aria-controls"] = open ? listElement == null ? void 0 : listElement.id : void 0;
      reference["aria-autocomplete"] = autoComplete;
    }
    return {
      reference,
      floating: {
        role: "presentation"
      }
    };
  }, [inputElement, open, ariaExpanded, ariaHasPopup, listElement == null ? void 0 : listElement.id, autoComplete]);
  const click = useClick(floatingRootContext, {
    enabled: !readOnly && !disabled && openOnInputClick,
    event: "mousedown-only",
    toggle: false,
    // Apply a small delay for touch to let iOS viewport centering settle.
    // This avoids top-bottom flip flickers if the preferred position is "top" when first tapping.
    touchOpenDelay: inputInsidePopup ? 0 : 50
  });
  const dismiss = useDismiss(floatingRootContext, {
    enabled: !readOnly && !disabled,
    outsidePressEvent: {
      mouse: "sloppy",
      // The visual viewport (affected by the mobile software keyboard) can be
      // somewhat small. The user may want to scroll the screen to see more of
      // the popup.
      touch: "intentional"
    },
    // Without a popup, let the Escape key bubble the event up to other popups' handlers.
    bubbles: inline ? true : void 0,
    outsidePress(event) {
      const target = getTarget(event);
      return !contains(triggerElement, target) && !contains(clearRef.current, target) && !contains(chipsContainerRef.current, target);
    }
  });
  const listNavigation = useListNavigation(floatingRootContext, {
    enabled: !readOnly && !disabled,
    id,
    listRef,
    activeIndex,
    selectedIndex,
    virtual: true,
    loop: true,
    allowEscape: !autoHighlight,
    focusItemOnOpen: queryChangedAfterOpen || selectionMode === "none" ? false : "auto",
    // `cols` > 1 enables grid navigation.
    // Since <Combobox.Row> infers column sizes (and is required when building a grid),
    // it works correctly even with a value of `2`.
    // Floating UI tests don't require `role="row"` wrappers, so retains the number API.
    cols: grid ? 2 : 1,
    orientation: grid ? "horizontal" : void 0,
    disabledIndices: virtualized ? (index) => index < 0 || index >= flatFilteredItems.length : EMPTY_ARRAY,
    onNavigate(nextActiveIndex, event) {
      const isClosing = !open || transitionStatus === "ending";
      if (nextActiveIndex === null && !inline && isClosing) {
        return;
      }
      if (!event) {
        setIndices({
          activeIndex: nextActiveIndex
        });
      } else {
        setIndices({
          activeIndex: nextActiveIndex,
          type: keyboardActiveRef.current ? "keyboard" : "pointer"
        });
      }
    }
  });
  const {
    reference: typeaheadTriggerProps
  } = useTypeahead(floatingRootContext, {
    enabled: !open && !readOnly && !disabled && selectionMode === "single",
    listRef: labelsRef,
    activeIndex,
    selectedIndex,
    onMatch(index) {
      const nextSelectedValue = valuesRef.current[index];
      if (nextSelectedValue !== void 0) {
        setSelectedValue(nextSelectedValue, createChangeEventDetails("none"));
      }
    }
  });
  const {
    getReferenceProps,
    getFloatingProps,
    getItemProps
  } = useInteractions([role, click, dismiss, listNavigation]);
  useOnFirstRender(() => {
    store.apply({
      popupProps: getFloatingProps(),
      inputProps: getReferenceProps(),
      triggerProps,
      typeaheadTriggerProps,
      getItemProps,
      setOpen,
      setInputValue,
      setSelectedValue,
      setIndices,
      onItemHighlighted,
      handleSelection,
      forceMount
    });
  });
  useIsoLayoutEffect(() => {
    store.apply({
      id,
      selectedValue,
      inputValue,
      open,
      mounted,
      transitionStatus,
      items,
      popupProps: getFloatingProps(),
      inputProps: getReferenceProps(),
      triggerProps,
      typeaheadTriggerProps,
      openMethod,
      getItemProps,
      selectionMode,
      name,
      disabled,
      readOnly,
      required,
      fieldControlValidation,
      grid,
      isGrouped,
      virtualized,
      onOpenChangeComplete,
      openOnInputClick,
      itemToStringLabel,
      modal,
      autoHighlight,
      isItemEqualToValue,
      alwaysSubmitOnEnter,
      hasInputValue
    });
  }, [store, id, selectedValue, inputValue, open, mounted, transitionStatus, items, getFloatingProps, getReferenceProps, getItemProps, openMethod, triggerProps, typeaheadTriggerProps, selectionMode, name, disabled, readOnly, required, fieldControlValidation, grid, isGrouped, virtualized, onOpenChangeComplete, openOnInputClick, itemToStringLabel, modal, autoHighlight, isItemEqualToValue, alwaysSubmitOnEnter, hasInputValue]);
  const hiddenInputRef = useMergedRefs(inputRefProp, fieldControlValidation.inputRef);
  const itemsContextValue = React25.useMemo(() => ({
    query,
    filteredItems,
    flatFilteredItems
  }), [query, filteredItems, flatFilteredItems]);
  const serializedValue = React25.useMemo(() => {
    if (Array.isArray(formValue)) {
      return "";
    }
    return stringifyAsValue(formValue, itemToStringValue);
  }, [formValue, itemToStringValue]);
  const hiddenInputs = React25.useMemo(() => {
    if (!multiple || !Array.isArray(selectedValue) || !name) {
      return null;
    }
    return selectedValue.map((value) => {
      const currentSerializedValue = stringifyAsValue(value, itemToStringValue);
      return (0, import_jsx_runtime6.jsx)("input", {
        type: "hidden",
        name,
        value: currentSerializedValue
      }, currentSerializedValue);
    });
  }, [multiple, selectedValue, name, itemToStringValue]);
  const children = (0, import_jsx_runtime6.jsxs)(React25.Fragment, {
    children: [props.children, (0, import_jsx_runtime6.jsx)("input", {
      ...fieldControlValidation.getInputValidationProps({
        // Move focus when the hidden input is focused.
        onFocus() {
          var _a;
          if (inputInsidePopup) {
            triggerElement == null ? void 0 : triggerElement.focus();
          }
          (_a = inputRef.current || triggerElement) == null ? void 0 : _a.focus();
        },
        // Handle browser autofill.
        onChange(event) {
          if (event.nativeEvent.defaultPrevented) {
            return;
          }
          const nextValue = event.target.value;
          const details = createChangeEventDetails("input-change", event.nativeEvent);
          function handleChange() {
            if (multiple) {
              return;
            }
            if (selectionMode === "none") {
              setDirty(nextValue !== validityData.initialValue);
              setInputValue(nextValue, details);
              if (validationMode === "onChange") {
                fieldControlValidation.commitValidation(nextValue);
              }
              return;
            }
            const matchingValue = valuesRef.current.find((v) => {
              const candidate = stringifyAsValue(v, itemToStringValue);
              if (candidate.toLowerCase() === nextValue.toLowerCase()) {
                return true;
              }
              return false;
            });
            if (matchingValue != null) {
              setDirty(matchingValue !== validityData.initialValue);
              setSelectedValue == null ? void 0 : setSelectedValue(matchingValue, details);
              if (validationMode === "onChange") {
                fieldControlValidation.commitValidation(matchingValue);
              }
            }
          }
          if (items) {
            handleChange();
          } else {
            forceMount();
            queueMicrotask(handleChange);
          }
        },
        id,
        name: multiple || selectionMode === "none" ? void 0 : name,
        disabled,
        required,
        readOnly,
        value: serializedValue,
        ref: hiddenInputRef,
        style: visuallyHidden,
        tabIndex: -1,
        "aria-hidden": true
      })
    }), hiddenInputs]
  });
  return (0, import_jsx_runtime6.jsx)(ComboboxRootContext.Provider, {
    value: store,
    children: (0, import_jsx_runtime6.jsx)(ComboboxFloatingContext.Provider, {
      value: floatingRootContext,
      children: (0, import_jsx_runtime6.jsx)(ComboboxDerivedItemsContext.Provider, {
        value: itemsContextValue,
        children: (0, import_jsx_runtime6.jsx)(ComboboxInputValueContext.Provider, {
          value: inputValue,
          children: virtualized ? children : (0, import_jsx_runtime6.jsx)(CompositeList, {
            elementsRef: listRef,
            labelsRef: items ? void 0 : labelsRef,
            children
          })
        })
      })
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/autocomplete/root/AutocompleteRoot.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function AutocompleteRoot(props) {
  const {
    openOnInputClick = false,
    value,
    defaultValue,
    onValueChange,
    mode = "list",
    autoHighlight = false,
    itemToStringValue,
    items,
    alwaysSubmitOnEnter = false,
    ...other
  } = props;
  const enableInline = mode === "inline" || mode === "both";
  const staticItems = mode === "inline" || mode === "none";
  const isControlled = value !== void 0;
  const [internalValue, setInternalValue] = React26.useState(defaultValue ?? "");
  const [inlineOverlay, setInlineOverlay] = React26.useState("");
  React26.useEffect(() => {
    if (isControlled) {
      setInlineOverlay("");
    }
  }, [value, isControlled]);
  let composedValue;
  if (enableInline && inlineOverlay !== "") {
    composedValue = inlineOverlay;
  } else if (isControlled) {
    composedValue = value ?? "";
  } else {
    composedValue = internalValue;
  }
  const handleValueChange = useEventCallback((nextValue, eventDetails) => {
    setInlineOverlay("");
    if (!isControlled) {
      setInternalValue(nextValue);
    }
    onValueChange == null ? void 0 : onValueChange(nextValue, eventDetails);
  });
  const collator = useCoreFilter();
  const baseFilter = React26.useMemo(() => {
    if (other.filter) {
      return other.filter;
    }
    return (item, query2, toString) => {
      return collator.contains(stringifyAsLabel(item, toString), query2);
    };
  }, [other, collator]);
  const query = String(isControlled ? value : internalValue).trim();
  let effectiveFilter;
  if (mode !== "both") {
    effectiveFilter = staticItems ? null : other.filter;
  } else {
    effectiveFilter = (item, _query, toString) => {
      return baseFilter(item, query, toString);
    };
  }
  const handleItemHighlighted = useEventCallback((highlightedValue, eventDetails) => {
    var _a;
    (_a = props.onItemHighlighted) == null ? void 0 : _a.call(props, highlightedValue, eventDetails);
    if (eventDetails.reason === "pointer") {
      return;
    }
    if (enableInline) {
      if (highlightedValue == null) {
        setInlineOverlay("");
      } else {
        setInlineOverlay(stringifyAsLabel(highlightedValue, itemToStringValue));
      }
    } else {
      setInlineOverlay("");
    }
  });
  return (0, import_jsx_runtime7.jsx)(ComboboxRootInternal, {
    ...other,
    items,
    itemToStringLabel: itemToStringValue,
    openOnInputClick,
    selectionMode: "none",
    fillInputOnItemPress: true,
    autoHighlight,
    filter: effectiveFilter,
    inputValue: composedValue,
    defaultInputValue: defaultValue,
    onInputValueChange: handleValueChange,
    onItemHighlighted: handleItemHighlighted,
    autoComplete: mode,
    alwaysSubmitOnEnter
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/autocomplete/value/AutocompleteValue.js
function AutocompleteValue(props) {
  const {
    children
  } = props;
  const inputValue = useComboboxInputValueContext();
  if (typeof children === "function") {
    return children(String(inputValue));
  }
  if (children != null) {
    return children;
  }
  return inputValue;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/trigger/ComboboxTrigger.js
var React27 = __toESM(require_react(), 1);
var stateAttributesMapping3 = {
  ...pressableTriggerOpenStateMapping,
  ...fieldValidityMapping
};
var ComboboxTrigger = React27.forwardRef(function ComboboxTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    nativeButton = true,
    disabled: disabledProp = false,
    ...elementProps
  } = componentProps;
  const {
    state: fieldState,
    disabled: fieldDisabled,
    labelId,
    setTouched,
    setFocused,
    validationMode
  } = useFieldRootContext();
  const store = useComboboxRootContext();
  const selectionMode = useStore(store, selectors2.selectionMode);
  const fieldControlValidation = useStore(store, selectors2.fieldControlValidation);
  const comboboxDisabled = useStore(store, selectors2.disabled);
  const readOnly = useStore(store, selectors2.readOnly);
  const listElement = useStore(store, selectors2.listElement);
  const triggerProps = useStore(store, selectors2.triggerProps);
  const typeaheadTriggerProps = useStore(store, selectors2.typeaheadTriggerProps);
  const inputInsidePopup = useStore(store, selectors2.inputInsidePopup);
  const open = useStore(store, selectors2.open);
  const selectedValue = useStore(store, selectors2.selectedValue);
  const inputValue = useComboboxInputValueContext();
  const disabled = fieldDisabled || comboboxDisabled || disabledProp;
  const focusTimeout = useTimeout();
  const currentPointerTypeRef = React27.useRef("");
  const trackPointerType = useEventCallback((event) => {
    currentPointerTypeRef.current = event.pointerType;
  });
  const {
    buttonRef,
    getButtonProps
  } = useButton({
    native: nativeButton,
    disabled
  });
  const state = React27.useMemo(() => ({
    ...fieldState,
    open,
    disabled
  }), [fieldState, open, disabled]);
  const setTriggerElement = useEventCallback((element2) => {
    store.set("triggerElement", element2);
  });
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef, setTriggerElement],
    state,
    props: [triggerProps, typeaheadTriggerProps, {
      tabIndex: inputInsidePopup ? 0 : -1,
      disabled,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": inputInsidePopup ? "dialog" : "listbox",
      "aria-controls": open ? listElement == null ? void 0 : listElement.id : void 0,
      "aria-readonly": readOnly || void 0,
      "aria-labelledby": labelId,
      onPointerDown: trackPointerType,
      onPointerEnter: trackPointerType,
      onFocus() {
        setFocused(true);
        if (disabled || readOnly) {
          return;
        }
        focusTimeout.start(0, store.state.forceMount);
      },
      onBlur() {
        setTouched(true);
        setFocused(false);
        if (validationMode === "onBlur") {
          const valueToValidate = selectionMode === "none" ? inputValue : selectedValue;
          fieldControlValidation.commitValidation(valueToValidate);
        }
      },
      onMouseDown(event) {
        if (disabled || readOnly) {
          return;
        }
        store.state.forceMount();
        if (!store.state.inputInsidePopup) {
          event.preventDefault();
        }
      },
      onClick(event) {
        var _a;
        if (disabled || readOnly) {
          return;
        }
        const nextOpen = !open;
        store.state.setOpen(nextOpen, createChangeEventDetails("trigger-press", event.nativeEvent));
        if (nextOpen && currentPointerTypeRef.current !== "touch") {
          (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
        }
      },
      onKeyDown(event) {
        var _a;
        if (disabled || readOnly) {
          return;
        }
        if (event.key === "ArrowDown" || event.key === "ArrowUp") {
          stopEvent(event);
          store.state.setOpen(true, createChangeEventDetails("list-navigation", event.nativeEvent));
          (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
        }
      }
    }, fieldControlValidation ? fieldControlValidation.getValidationProps(elementProps) : elementProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping3
  });
  return element;
});
if (true) ComboboxTrigger.displayName = "ComboboxTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/input/ComboboxInput.js
var React30 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/chips/ComboboxChipsContext.js
var React28 = __toESM(require_react(), 1);
var ComboboxChipsContext = React28.createContext(void 0);
if (true) ComboboxChipsContext.displayName = "ComboboxChipsContext";
function useComboboxChipsContext() {
  return React28.useContext(ComboboxChipsContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/positioner/ComboboxPositionerContext.js
var React29 = __toESM(require_react(), 1);
var ComboboxPositionerContext = React29.createContext(void 0);
if (true) ComboboxPositionerContext.displayName = "ComboboxPositionerContext";
function useComboboxPositionerContext(optional) {
  const context = React29.useContext(ComboboxPositionerContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: <Combobox.Popup> and <Combobox.Arrow> must be used within the <Combobox.Positioner> component");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/input/ComboboxInput.js
var stateAttributesMapping4 = {
  ...pressableTriggerOpenStateMapping,
  ...fieldValidityMapping
};
var ComboboxInput = React30.forwardRef(function ComboboxInput2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    ...elementProps
  } = componentProps;
  const {
    state: fieldState,
    disabled: fieldDisabled,
    labelId,
    setTouched,
    setFocused,
    validationMode
  } = useFieldRootContext();
  const comboboxChipsContext = useComboboxChipsContext();
  const hasPositionerParent = Boolean(useComboboxPositionerContext(true));
  const store = useComboboxRootContext();
  const comboboxDisabled = useStore(store, selectors2.disabled);
  const readOnly = useStore(store, selectors2.readOnly);
  const fieldControlValidation = useStore(store, selectors2.fieldControlValidation);
  const openOnInputClick = useStore(store, selectors2.openOnInputClick);
  const name = useStore(store, selectors2.name);
  const selectionMode = useStore(store, selectors2.selectionMode);
  const autoHighlight = useStore(store, selectors2.autoHighlight);
  const inputProps = useStore(store, selectors2.inputProps);
  const triggerProps = useStore(store, selectors2.triggerProps);
  const open = useStore(store, selectors2.open);
  const selectedValue = useStore(store, selectors2.selectedValue);
  const inputValue = useComboboxInputValueContext();
  const disabled = fieldDisabled || comboboxDisabled || disabledProp;
  const [composingValue, setComposingValue] = React30.useState(null);
  const isComposingRef = React30.useRef(false);
  const setInputElement = useEventCallback((element2) => {
    if (hasPositionerParent && !store.state.hasInputValue) {
      store.state.setInputValue("", createChangeEventDetails("none"));
    }
    store.apply({
      inputElement: element2,
      inputInsidePopup: hasPositionerParent
    });
  });
  const state = React30.useMemo(() => ({
    ...fieldState,
    open,
    disabled,
    readOnly
  }), [fieldState, open, disabled, readOnly]);
  function handleKeyDown(event) {
    if (!comboboxChipsContext) {
      return void 0;
    }
    let nextIndex;
    const {
      highlightedChipIndex
    } = comboboxChipsContext;
    if (highlightedChipIndex !== void 0) {
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        if (highlightedChipIndex > 0) {
          nextIndex = highlightedChipIndex - 1;
        } else {
          nextIndex = void 0;
        }
      } else if (event.key === "ArrowRight") {
        event.preventDefault();
        if (highlightedChipIndex < selectedValue.length - 1) {
          nextIndex = highlightedChipIndex + 1;
        } else {
          nextIndex = void 0;
        }
      } else if (event.key === "Backspace" || event.key === "Delete") {
        event.preventDefault();
        const computedNextIndex = highlightedChipIndex >= selectedValue.length - 1 ? selectedValue.length - 2 : highlightedChipIndex;
        nextIndex = computedNextIndex >= 0 ? computedNextIndex : void 0;
        store.state.setIndices({
          activeIndex: null,
          selectedIndex: null,
          type: "keyboard"
        });
      }
      return nextIndex;
    }
    if (event.key === "ArrowLeft" && (event.currentTarget.selectionStart ?? 0) === 0 && selectedValue.length > 0) {
      event.preventDefault();
      const lastChipIndex = Math.max(selectedValue.length - 1, 0);
      nextIndex = lastChipIndex;
    } else if (event.key === "Backspace" && event.currentTarget.value === "" && selectedValue.length > 0) {
      store.state.setIndices({
        activeIndex: null,
        selectedIndex: null,
        type: "keyboard"
      });
      event.preventDefault();
    }
    return nextIndex;
  }
  const element = useRenderElement("input", componentProps, {
    state,
    ref: [forwardedRef, store.state.inputRef, setInputElement],
    props: [inputProps, triggerProps, {
      type: "text",
      value: componentProps.value ?? composingValue ?? inputValue,
      "aria-readonly": readOnly || void 0,
      "aria-labelledby": labelId,
      disabled,
      readOnly,
      ...selectionMode === "none" && name && {
        name
      },
      onFocus() {
        setFocused(true);
      },
      onBlur() {
        setTouched(true);
        setFocused(false);
        if (validationMode === "onBlur") {
          const valueToValidate = selectionMode === "none" ? inputValue : selectedValue;
          fieldControlValidation == null ? void 0 : fieldControlValidation.commitValidation(valueToValidate);
        }
      },
      onCompositionStart(event) {
        isComposingRef.current = true;
        setComposingValue(event.currentTarget.value);
      },
      onCompositionEnd(event) {
        isComposingRef.current = false;
        const next = event.currentTarget.value;
        setComposingValue(null);
        store.state.setInputValue(next, createChangeEventDetails("input-change", event.nativeEvent));
      },
      onChange(event) {
        if (isComposingRef.current) {
          const nextVal = event.currentTarget.value;
          setComposingValue(nextVal);
          if (nextVal === "" && !openOnInputClick && !hasPositionerParent) {
            store.state.setOpen(false, createChangeEventDetails("input-clear", event.nativeEvent));
          }
          if (!readOnly && !disabled) {
            const trimmed = nextVal.trim();
            if (trimmed !== "") {
              store.state.setOpen(true, createChangeEventDetails("input-change", event.nativeEvent));
              if (!autoHighlight) {
                store.state.setIndices({
                  activeIndex: null,
                  selectedIndex: null,
                  type: store.state.keyboardActiveRef.current ? "keyboard" : "pointer"
                });
              }
            }
          }
          if (open && store.state.activeIndex !== null && !(autoHighlight && nextVal.trim() !== "")) {
            store.state.setIndices({
              activeIndex: null,
              selectedIndex: null,
              type: store.state.keyboardActiveRef.current ? "keyboard" : "pointer"
            });
          }
          return;
        }
        store.state.setInputValue(event.currentTarget.value, createChangeEventDetails("input-change", event.nativeEvent));
        const empty = event.currentTarget.value === "";
        const clearDetails = createChangeEventDetails("input-clear", event.nativeEvent);
        if (empty && !hasPositionerParent) {
          if (selectionMode === "single") {
            store.state.setSelectedValue(null, clearDetails);
          }
          if (!openOnInputClick) {
            store.state.setOpen(false, clearDetails);
          }
        }
        if (!readOnly && !disabled) {
          const trimmed = event.currentTarget.value.trim();
          if (trimmed !== "") {
            store.state.setOpen(true, createChangeEventDetails("input-change", event.nativeEvent));
            if (!autoHighlight) {
              store.state.setIndices({
                activeIndex: null,
                selectedIndex: null,
                type: store.state.keyboardActiveRef.current ? "keyboard" : "pointer"
              });
            }
          }
        }
        if (open && store.state.activeIndex !== null && !(autoHighlight && event.currentTarget.value.trim() !== "")) {
          store.state.setIndices({
            activeIndex: null,
            selectedIndex: null,
            type: store.state.keyboardActiveRef.current ? "keyboard" : "pointer"
          });
        }
      },
      onKeyDown(event) {
        var _a, _b;
        if (disabled || readOnly) {
          return;
        }
        if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) {
          return;
        }
        store.state.keyboardActiveRef.current = true;
        if (event.key === "Home") {
          stopEvent(event);
          event.currentTarget.setSelectionRange(0, 0);
          return;
        }
        if (event.key === "End") {
          stopEvent(event);
          const length = event.currentTarget.value.length;
          event.currentTarget.setSelectionRange(length, length);
          return;
        }
        if (!open && event.key === "Escape") {
          const isClear = selectionMode === "multiple" && Array.isArray(selectedValue) ? selectedValue.length === 0 : selectedValue === null;
          const details = createChangeEventDetails("escape-key", event.nativeEvent);
          const value = selectionMode === "multiple" ? [] : null;
          store.state.setInputValue("", details);
          store.state.setSelectedValue(value, details);
          if (!isClear && !store.state.inline && !details.isPropagationAllowed) {
            event.stopPropagation();
          }
          return;
        }
        if (comboboxChipsContext && event.key === "Backspace" && event.currentTarget.value === "" && comboboxChipsContext.highlightedChipIndex === void 0 && Array.isArray(selectedValue) && selectedValue.length > 0) {
          const newValue = selectedValue.slice(0, -1);
          store.state.setIndices({
            activeIndex: null,
            selectedIndex: null,
            type: store.state.keyboardActiveRef.current ? "keyboard" : "pointer"
          });
          store.state.setSelectedValue(newValue, createChangeEventDetails("none", event.nativeEvent));
          return;
        }
        const nextIndex = handleKeyDown(event);
        comboboxChipsContext == null ? void 0 : comboboxChipsContext.setHighlightedChipIndex(nextIndex);
        if (nextIndex !== void 0) {
          (_a = comboboxChipsContext == null ? void 0 : comboboxChipsContext.chipsRef.current[nextIndex]) == null ? void 0 : _a.focus();
        } else {
          (_b = store.state.inputRef.current) == null ? void 0 : _b.focus();
        }
        if (event.which === 229) {
          return;
        }
        if (event.key === "Enter" && open) {
          const activeIndex = store.state.activeIndex;
          const nativeEvent = event.nativeEvent;
          if (activeIndex === null) {
            store.state.setOpen(false, createChangeEventDetails("none", nativeEvent));
            return;
          }
          const selectActiveItem = () => {
            const listItem = store.state.listRef.current[activeIndex];
            if (listItem) {
              store.state.selectionEventRef.current = nativeEvent;
              listItem.click();
              store.state.selectionEventRef.current = null;
              return;
            }
            store.state.handleSelection(nativeEvent);
          };
          if (store.state.alwaysSubmitOnEnter) {
            ReactDOM.flushSync(selectActiveItem);
            return;
          }
          stopEvent(event);
          selectActiveItem();
        }
      },
      onPointerMove() {
        store.state.keyboardActiveRef.current = false;
      },
      onPointerDown() {
        store.state.keyboardActiveRef.current = false;
      }
    }, fieldControlValidation ? fieldControlValidation.getValidationProps(elementProps) : elementProps],
    stateAttributesMapping: stateAttributesMapping4
  });
  return element;
});
if (true) ComboboxInput.displayName = "ComboboxInput";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/icon/ComboboxIcon.js
var React31 = __toESM(require_react(), 1);
var ComboboxIcon = React31.forwardRef(function ComboboxIcon2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const element = useRenderElement("span", componentProps, {
    ref: forwardedRef,
    props: [{
      "aria-hidden": true,
      children: ""
    }, elementProps]
  });
  return element;
});
if (true) ComboboxIcon.displayName = "ComboboxIcon";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/clear/ComboboxClear.js
var React32 = __toESM(require_react(), 1);
var stateAttributesMapping5 = {
  ...transitionStatusMapping,
  ...triggerOpenStateMapping
};
var ComboboxClear = React32.forwardRef(function ComboboxClear2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const {
    disabled: fieldDisabled
  } = useFieldRootContext();
  const store = useComboboxRootContext();
  const selectionMode = useStore(store, selectors2.selectionMode);
  const comboboxDisabled = useStore(store, selectors2.disabled);
  const readOnly = useStore(store, selectors2.readOnly);
  const clearRef = useStore(store, selectors2.clearRef);
  const open = useStore(store, selectors2.open);
  const selectedValue = useStore(store, selectors2.selectedValue);
  const inputValue = useComboboxInputValueContext();
  let visible = false;
  if (selectionMode === "none") {
    visible = inputValue !== "";
  } else if (selectionMode === "single") {
    visible = selectedValue != null;
  } else {
    visible = Array.isArray(selectedValue) && selectedValue.length > 0;
  }
  const disabled = fieldDisabled || comboboxDisabled || disabledProp;
  const {
    buttonRef,
    getButtonProps
  } = useButton({
    native: nativeButton,
    disabled
  });
  const {
    mounted,
    transitionStatus,
    setMounted
  } = useTransitionStatus(visible);
  const state = React32.useMemo(() => ({
    disabled,
    open,
    transitionStatus
  }), [disabled, open, transitionStatus]);
  useOpenChangeComplete({
    open: visible,
    ref: clearRef,
    onComplete() {
      if (!visible) {
        setMounted(false);
      }
    }
  });
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, buttonRef, clearRef],
    props: [{
      tabIndex: -1,
      hidden: !mounted,
      children: "x",
      disabled,
      "aria-readonly": readOnly || void 0,
      // Avoid stealing focus from the input.
      onMouseDown(event) {
        event.preventDefault();
      },
      onClick(event) {
        var _a;
        if (disabled || readOnly) {
          return;
        }
        const keyboardActiveRef = store.state.keyboardActiveRef;
        store.state.setInputValue("", createChangeEventDetails("clear-press", event.nativeEvent));
        if (selectionMode !== "none") {
          store.state.setSelectedValue(Array.isArray(selectedValue) ? [] : null, createChangeEventDetails("clear-press", event.nativeEvent));
          store.state.setIndices({
            activeIndex: null,
            selectedIndex: null,
            type: keyboardActiveRef.current ? "keyboard" : "pointer"
          });
        } else {
          store.state.setIndices({
            activeIndex: null,
            type: keyboardActiveRef.current ? "keyboard" : "pointer"
          });
        }
        (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
      }
    }, elementProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping5
  });
  const shouldRender = keepMounted || mounted;
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) ComboboxClear.displayName = "ComboboxClear";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/list/ComboboxList.js
var React35 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/collection/ComboboxCollection.js
var React34 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/collection/GroupCollectionContext.js
var React33 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var GroupCollectionContext = React33.createContext(null);
if (true) GroupCollectionContext.displayName = "GroupCollectionContext";
function useGroupCollectionContext() {
  return React33.useContext(GroupCollectionContext);
}
function GroupCollectionProvider(props) {
  const {
    children,
    items
  } = props;
  const contextValue = React33.useMemo(() => ({
    items
  }), [items]);
  return (0, import_jsx_runtime8.jsx)(GroupCollectionContext.Provider, {
    value: contextValue,
    children
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/collection/ComboboxCollection.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
function ComboboxCollection(props) {
  const {
    children
  } = props;
  const {
    filteredItems
  } = useComboboxDerivedItemsContext();
  const groupContext = useGroupCollectionContext();
  const itemsToRender = groupContext ? groupContext.items : filteredItems;
  if (!itemsToRender) {
    return null;
  }
  return (0, import_jsx_runtime9.jsx)(React34.Fragment, {
    children: itemsToRender.map(children)
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/list/ComboboxList.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var ComboboxList = React35.forwardRef(function ComboboxList2(componentProps, forwardedRef) {
  var _ComboboxCollection;
  const {
    render,
    className,
    children,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const floatingRootContext = useComboboxFloatingContext();
  const hasPositionerContext = Boolean(useComboboxPositionerContext(true));
  const selectionMode = useStore(store, selectors2.selectionMode);
  const grid = useStore(store, selectors2.grid);
  const popupRef = useStore(store, selectors2.popupRef);
  const popupProps = useStore(store, selectors2.popupProps);
  const disabled = useStore(store, selectors2.disabled);
  const readOnly = useStore(store, selectors2.readOnly);
  const multiple = selectionMode === "multiple";
  const setPositionerElement = useEventCallback((element) => {
    store.set("positionerElement", element);
  });
  const setListElement = useEventCallback((element) => {
    store.set("listElement", element);
  });
  useIsoLayoutEffect(() => {
    if (hasPositionerContext || popupRef.current) {
      return void 0;
    }
    store.set("inline", true);
    return () => {
      store.set("inline", false);
    };
  }, [hasPositionerContext, store, popupRef]);
  const resolvedChildren = React35.useMemo(() => {
    if (typeof children === "function") {
      return _ComboboxCollection || (_ComboboxCollection = (0, import_jsx_runtime10.jsx)(ComboboxCollection, {
        children
      }));
    }
    return children;
  }, [children]);
  return useRenderElement("div", componentProps, {
    ref: [forwardedRef, setListElement, hasPositionerContext ? null : setPositionerElement],
    props: [popupProps, {
      children: resolvedChildren,
      tabIndex: -1,
      id: floatingRootContext.floatingId,
      role: grid ? "grid" : "listbox",
      "aria-multiselectable": multiple ? "true" : void 0,
      onKeyDown(event) {
        if (disabled || readOnly) {
          return;
        }
        if (event.key === "Enter") {
          const activeIndex = store.state.activeIndex;
          if (activeIndex == null) {
            return;
          }
          stopEvent(event);
          const nativeEvent = event.nativeEvent;
          const listItem = store.state.listRef.current[activeIndex];
          if (listItem) {
            store.state.selectionEventRef.current = nativeEvent;
            listItem.click();
            store.state.selectionEventRef.current = null;
            return;
          }
          store.state.handleSelection(nativeEvent);
        }
      },
      onKeyDownCapture() {
        store.state.keyboardActiveRef.current = true;
      },
      onPointerMoveCapture() {
        store.state.keyboardActiveRef.current = false;
      }
    }, elementProps]
  });
});
if (true) ComboboxList.displayName = "ComboboxList";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/status/ComboboxStatus.js
var React36 = __toESM(require_react(), 1);
var ComboboxStatus = React36.forwardRef(function ComboboxStatus2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  return useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: [{
      role: "status",
      "aria-live": "polite",
      "aria-atomic": true
    }, elementProps]
  });
});
if (true) ComboboxStatus.displayName = "ComboboxStatus";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/portal/ComboboxPortal.js
var React38 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/portal/ComboboxPortalContext.js
var React37 = __toESM(require_react(), 1);
var ComboboxPortalContext = React37.createContext(void 0);
if (true) ComboboxPortalContext.displayName = "ComboboxPortalContext";
function useComboboxPortalContext() {
  const context = React37.useContext(ComboboxPortalContext);
  if (context === void 0) {
    throw new Error("Base UI: <Combobox.Portal> is missing.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/portal/ComboboxPortal.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function ComboboxPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const store = useComboboxRootContext();
  const mounted = useStore(store, selectors2.mounted);
  const forceMounted = useStore(store, selectors2.forceMounted);
  const shouldRender = mounted || keepMounted || forceMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(ComboboxPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime11.jsx)(FloatingPortal, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/backdrop/ComboboxBackdrop.js
var React39 = __toESM(require_react(), 1);
var stateAttributesMapping6 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var ComboboxBackdrop = React39.forwardRef(function ComboboxBackdrop2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const open = useStore(store, selectors2.open);
  const mounted = useStore(store, selectors2.mounted);
  const transitionStatus = useStore(store, selectors2.transitionStatus);
  const state = React39.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  return useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    stateAttributesMapping: stateAttributesMapping6,
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps]
  });
});
if (true) ComboboxBackdrop.displayName = "ComboboxBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/positioner/ComboboxPositioner.js
var React40 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var ComboboxPositioner = React40.forwardRef(function ComboboxPositioner2(componentProps, forwardedRef) {
  const {
    render,
    className,
    anchor,
    positionMethod = "absolute",
    side = "bottom",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = false,
    trackAnchor = true,
    collisionAvoidance = DROPDOWN_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const {
    filteredItems
  } = useComboboxDerivedItemsContext();
  const floatingRootContext = useComboboxFloatingContext();
  const keepMounted = useComboboxPortalContext();
  const modal = useStore(store, selectors2.modal);
  const open = useStore(store, selectors2.open);
  const mounted = useStore(store, selectors2.mounted);
  const openMethod = useStore(store, selectors2.openMethod);
  const triggerElement = useStore(store, selectors2.triggerElement);
  const inputElement = useStore(store, selectors2.inputElement);
  const inputInsidePopup = useStore(store, selectors2.inputInsidePopup);
  const empty = filteredItems.length === 0;
  const resolvedAnchor = anchor ?? (inputInsidePopup ? triggerElement : inputElement);
  const positioning = useAnchorPositioning({
    anchor: resolvedAnchor,
    floatingRootContext,
    positionMethod,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    trackAnchor,
    keepMounted,
    collisionAvoidance,
    lazyFlip: true
  });
  useScrollLock({
    enabled: open && modal && openMethod !== "touch",
    mounted,
    open,
    referenceElement: triggerElement
  });
  const defaultProps = React40.useMemo(() => {
    const style = {
      ...positioning.positionerStyles
    };
    if (!open) {
      style.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style
    };
  }, [open, mounted, positioning.positionerStyles]);
  const state = React40.useMemo(() => ({
    open,
    side: positioning.side,
    align: positioning.align,
    anchorHidden: positioning.anchorHidden,
    empty
  }), [open, positioning.side, positioning.align, positioning.anchorHidden, empty]);
  const contextValue = React40.useMemo(() => ({
    side: positioning.side,
    align: positioning.align,
    arrowRef: positioning.arrowRef,
    arrowUncentered: positioning.arrowUncentered,
    arrowStyles: positioning.arrowStyles,
    anchorHidden: positioning.anchorHidden,
    isPositioned: positioning.isPositioned
  }), [positioning.side, positioning.align, positioning.arrowRef, positioning.arrowUncentered, positioning.arrowStyles, positioning.anchorHidden, positioning.isPositioned]);
  const setPositionerElement = useEventCallback((element2) => {
    store.set("positionerElement", element2);
  });
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, setPositionerElement],
    props: [defaultProps, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return (0, import_jsx_runtime12.jsxs)(ComboboxPositionerContext.Provider, {
    value: contextValue,
    children: [mounted && modal && (0, import_jsx_runtime12.jsx)(InternalBackdrop, {
      inert: inertValue(!open),
      cutout: inputElement ?? triggerElement
    }), element]
  });
});
if (true) ComboboxPositioner.displayName = "ComboboxPositioner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/popup/ComboboxPopup.js
var React41 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping7 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var ComboboxPopup = React41.forwardRef(function ComboboxPopup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    initialFocus,
    finalFocus,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const positioning = useComboboxPositionerContext();
  const floatingRootContext = useComboboxFloatingContext();
  const {
    filteredItems
  } = useComboboxDerivedItemsContext();
  const mounted = useStore(store, selectors2.mounted);
  const open = useStore(store, selectors2.open);
  const openMethod = useStore(store, selectors2.openMethod);
  const transitionStatus = useStore(store, selectors2.transitionStatus);
  const inputInsidePopup = useStore(store, selectors2.inputInsidePopup);
  const inputElement = useStore(store, selectors2.inputElement);
  const listElement = useStore(store, selectors2.listElement);
  const empty = filteredItems.length === 0;
  useOpenChangeComplete({
    open,
    ref: store.state.popupRef,
    onComplete() {
      if (open) {
        store.state.onOpenChangeComplete(true);
      }
    }
  });
  const state = React41.useMemo(() => ({
    open,
    side: positioning.side,
    align: positioning.align,
    anchorHidden: positioning.anchorHidden,
    transitionStatus,
    empty
  }), [open, positioning.side, positioning.align, positioning.anchorHidden, transitionStatus, empty]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, store.state.popupRef],
    props: [{
      tabIndex: -1,
      onFocus(event) {
        var _a;
        const target = getTarget(event.nativeEvent);
        if (openMethod !== "touch" && !contains(listElement, target)) {
          (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
        }
      }
    }, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps],
    stateAttributesMapping: stateAttributesMapping7
  });
  const computedDefaultInitialFocus = inputInsidePopup ? (interactionType) => interactionType === "touch" ? store.state.popupRef.current : inputElement : false;
  const resolvedInitialFocus = initialFocus === void 0 ? computedDefaultInitialFocus : initialFocus;
  let resolvedFinalFocus;
  if (finalFocus != null) {
    resolvedFinalFocus = finalFocus;
  } else {
    resolvedFinalFocus = inputInsidePopup ? void 0 : false;
  }
  return (0, import_jsx_runtime13.jsx)(FloatingFocusManager, {
    context: floatingRootContext,
    disabled: !mounted,
    modal: !inputInsidePopup,
    openInteractionType: openMethod,
    initialFocus: resolvedInitialFocus,
    returnFocus: resolvedFinalFocus,
    children: element
  });
});
if (true) ComboboxPopup.displayName = "ComboboxPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/arrow/ComboboxArrow.js
var React42 = __toESM(require_react(), 1);
var ComboboxArrow = React42.forwardRef(function ComboboxArrow2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const {
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = useComboboxPositionerContext();
  const open = useStore(store, selectors2.open);
  const state = React42.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  return useRenderElement("div", componentProps, {
    ref: [arrowRef, forwardedRef],
    stateAttributesMapping: popupStateMapping,
    state,
    props: {
      style: arrowStyles,
      "aria-hidden": true,
      ...elementProps
    }
  });
});
if (true) ComboboxArrow.displayName = "ComboboxArrow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/group/ComboboxGroup.js
var React44 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/group/ComboboxGroupContext.js
var React43 = __toESM(require_react(), 1);
var ComboboxGroupContext = React43.createContext(void 0);
if (true) ComboboxGroupContext.displayName = "ComboboxGroupContext";
function useComboboxGroupContext() {
  const context = React43.useContext(ComboboxGroupContext);
  if (context === void 0) {
    throw new Error("Base UI: ComboboxGroupContext is missing. ComboboxGroup parts must be placed within <Combobox.Group>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/group/ComboboxGroup.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var ComboboxGroup = React44.forwardRef(function ComboboxGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    items,
    ...elementProps
  } = componentProps;
  const [labelId, setLabelId] = React44.useState();
  const contextValue = React44.useMemo(() => ({
    labelId,
    setLabelId,
    items
  }), [labelId, setLabelId, items]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: [{
      role: "group",
      "aria-labelledby": labelId
    }, elementProps]
  });
  const wrappedElement = (0, import_jsx_runtime14.jsx)(ComboboxGroupContext.Provider, {
    value: contextValue,
    children: element
  });
  if (items) {
    return (0, import_jsx_runtime14.jsx)(GroupCollectionProvider, {
      items,
      children: wrappedElement
    });
  }
  return wrappedElement;
});
if (true) ComboboxGroup.displayName = "ComboboxGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/group-label/ComboboxGroupLabel.js
var React45 = __toESM(require_react(), 1);
var ComboboxGroupLabel = React45.forwardRef(function ComboboxGroupLabel2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    setLabelId
  } = useComboboxGroupContext();
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    setLabelId(id);
    return () => {
      setLabelId(void 0);
    };
  }, [id, setLabelId]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
  return element;
});
if (true) ComboboxGroupLabel.displayName = "ComboboxGroupLabel";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/item/ComboboxItem.js
var React48 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/item/ComboboxItemContext.js
var React46 = __toESM(require_react(), 1);
var ComboboxItemContext = React46.createContext(void 0);
if (true) ComboboxItemContext.displayName = "ComboboxItemContext";
function useComboboxItemContext() {
  const context = React46.useContext(ComboboxItemContext);
  if (!context) {
    throw new Error("Base UI: ComboboxItemContext is missing. ComboboxItem parts must be placed within <Combobox.Item>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/row/ComboboxRowContext.js
var React47 = __toESM(require_react(), 1);
var ComboboxRowContext = React47.createContext(false);
if (true) ComboboxRowContext.displayName = "ComboboxRowContext";
function useComboboxRowContext() {
  return React47.useContext(ComboboxRowContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/item/ComboboxItem.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var ComboboxItem = React48.memo(React48.forwardRef(function ComboboxItem2(componentProps, forwardedRef) {
  const {
    render,
    className,
    value = null,
    index: indexProp,
    disabled = false,
    nativeButton = false,
    ...elementProps
  } = componentProps;
  const textRef = React48.useRef(null);
  const listItem = useCompositeListItem({
    index: indexProp,
    textRef,
    indexGuessBehavior: IndexGuessBehavior.GuessFromOrder
  });
  const store = useComboboxRootContext();
  const isRow = useComboboxRowContext();
  const {
    flatFilteredItems
  } = useComboboxDerivedItemsContext();
  const selectionMode = useStore(store, selectors2.selectionMode);
  const readOnly = useStore(store, selectors2.readOnly);
  const virtualized = useStore(store, selectors2.virtualized);
  const listRef = useStore(store, selectors2.listRef);
  const valuesRef = useStore(store, selectors2.valuesRef);
  const allValuesRef = useStore(store, selectors2.allValuesRef);
  const isItemEqualToValue = useStore(store, selectors2.isItemEqualToValue);
  const selectable = selectionMode !== "none";
  const index = indexProp ?? (virtualized ? findItemIndex(flatFilteredItems, value, isItemEqualToValue) : listItem.index);
  const rootId = useStore(store, selectors2.id);
  const highlighted = useStore(store, selectors2.isActive, index);
  const matchesSelectedValue = useStore(store, selectors2.isSelected, value);
  const rootSelectedValue = useStore(store, selectors2.selectedValue);
  const items = useStore(store, selectors2.items);
  const getItemProps = useStore(store, selectors2.getItemProps);
  const itemRef = React48.useRef(null);
  const indexRef = useLatestRef(index);
  const hasRegistered = listItem.index !== -1;
  const id = rootId != null && hasRegistered ? `${rootId}-${index}` : void 0;
  const selected = matchesSelectedValue && selectable;
  useIsoLayoutEffect(() => {
    const shouldRun = hasRegistered && (virtualized || indexProp != null);
    if (!shouldRun) {
      return void 0;
    }
    const list = listRef.current;
    list[index] = itemRef.current;
    return () => {
      delete list[index];
    };
  }, [hasRegistered, virtualized, index, listRef, indexProp]);
  useIsoLayoutEffect(() => {
    if (!hasRegistered || items) {
      return void 0;
    }
    const visibleMap = valuesRef.current;
    visibleMap[index] = value;
    if (selectionMode !== "none") {
      allValuesRef.current.push(value);
    }
    return () => {
      delete visibleMap[index];
    };
  }, [hasRegistered, items, index, value, valuesRef, allValuesRef, selectionMode]);
  useIsoLayoutEffect(() => {
    if (!hasRegistered || items) {
      return;
    }
    const lastSelectedValue = Array.isArray(rootSelectedValue) ? rootSelectedValue[rootSelectedValue.length - 1] : rootSelectedValue;
    if (compareItemEquality(lastSelectedValue, value, isItemEqualToValue)) {
      store.set("selectedIndex", index);
    }
  }, [hasRegistered, items, store, index, value, rootSelectedValue, isItemEqualToValue]);
  const state = React48.useMemo(() => ({
    disabled,
    selected,
    highlighted
  }), [disabled, selected, highlighted]);
  const rootProps = getItemProps({
    active: highlighted,
    selected
  });
  delete rootProps.id;
  delete rootProps.onFocus;
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    native: nativeButton
  });
  const defaultProps = {
    id,
    role: isRow ? "gridcell" : "option",
    "aria-disabled": disabled || void 0,
    "aria-selected": selectable ? selected : void 0,
    // Focusable items steal focus from the input upon mouseup.
    // Warn if the user renders a natively focusable element like `<button>`,
    // as it should be a `<div>` instead.
    tabIndex: void 0,
    onPointerDown(event) {
      event.preventDefault();
    },
    onClick(event) {
      if (disabled || readOnly) {
        return;
      }
      store.state.handleSelection(event.nativeEvent, value);
    }
  };
  const element = useRenderElement("div", componentProps, {
    ref: [buttonRef, forwardedRef, listItem.ref, itemRef],
    state,
    props: [rootProps, defaultProps, elementProps, getButtonProps]
  });
  const contextValue = React48.useMemo(() => ({
    selected,
    indexRef,
    textRef
  }), [selected, indexRef, textRef]);
  return (0, import_jsx_runtime15.jsx)(ComboboxItemContext.Provider, {
    value: contextValue,
    children: element
  });
}));
if (true) ComboboxItem.displayName = "ComboboxItem";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/row/ComboboxRow.js
var React49 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var ComboboxRow = React49.forwardRef(function ComboboxRow2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: [{
      role: "row"
    }, elementProps]
  });
  return (0, import_jsx_runtime16.jsx)(ComboboxRowContext.Provider, {
    value: true,
    children: element
  });
});
if (true) ComboboxRow.displayName = "ComboboxRow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/empty/ComboboxEmpty.js
var React50 = __toESM(require_react(), 1);
var ComboboxEmpty = React50.forwardRef(function ComboboxEmpty2(componentProps, forwardedRef) {
  const {
    render,
    className,
    children: childrenProp,
    ...elementProps
  } = componentProps;
  const {
    filteredItems
  } = useComboboxDerivedItemsContext();
  const children = filteredItems.length === 0 ? childrenProp : null;
  return useRenderElement("div", componentProps, {
    ref: forwardedRef,
    props: [{
      children,
      role: "status",
      "aria-live": "polite",
      "aria-atomic": true
    }, elementProps]
  });
});
if (true) ComboboxEmpty.displayName = "ComboboxEmpty";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/index.parts.js
var index_parts_exports12 = {};
__export(index_parts_exports12, {
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/root/AvatarRoot.js
var React52 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/root/AvatarRootContext.js
var React51 = __toESM(require_react(), 1);
var AvatarRootContext = React51.createContext(void 0);
if (true) AvatarRootContext.displayName = "AvatarRootContext";
function useAvatarRootContext() {
  const context = React51.useContext(AvatarRootContext);
  if (context === void 0) {
    throw new Error("Base UI: AvatarRootContext is missing. Avatar parts must be placed within <Avatar.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/root/stateAttributesMapping.js
var avatarStateAttributesMapping = {
  imageLoadingStatus: () => null
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/root/AvatarRoot.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var AvatarRoot = React52.forwardRef(function AvatarRoot2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const [imageLoadingStatus, setImageLoadingStatus] = React52.useState("idle");
  const state = React52.useMemo(() => ({
    imageLoadingStatus
  }), [imageLoadingStatus]);
  const contextValue = React52.useMemo(() => ({
    imageLoadingStatus,
    setImageLoadingStatus
  }), [imageLoadingStatus, setImageLoadingStatus]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: avatarStateAttributesMapping
  });
  return (0, import_jsx_runtime17.jsx)(AvatarRootContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) AvatarRoot.displayName = "AvatarRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/image/AvatarImage.js
var React54 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/image/useImageLoadingStatus.js
var React53 = __toESM(require_react(), 1);
function useImageLoadingStatus(src, {
  referrerPolicy,
  crossOrigin
}) {
  const [loadingStatus, setLoadingStatus] = React53.useState("idle");
  useIsoLayoutEffect(() => {
    if (!src) {
      setLoadingStatus("error");
      return NOOP;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = (status) => () => {
      if (!isMounted) {
        return;
      }
      setLoadingStatus(status);
    };
    setLoadingStatus("loading");
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    image.crossOrigin = crossOrigin ?? null;
    image.src = src;
    return () => {
      isMounted = false;
    };
  }, [src, crossOrigin, referrerPolicy]);
  return loadingStatus;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/image/AvatarImage.js
var AvatarImage = React54.forwardRef(function AvatarImage2(componentProps, forwardedRef) {
  const {
    className,
    render,
    onLoadingStatusChange: onLoadingStatusChangeProp,
    referrerPolicy,
    crossOrigin,
    ...elementProps
  } = componentProps;
  const context = useAvatarRootContext();
  const imageLoadingStatus = useImageLoadingStatus(componentProps.src, {
    referrerPolicy,
    crossOrigin
  });
  const handleLoadingStatusChange = useEventCallback((status) => {
    onLoadingStatusChangeProp == null ? void 0 : onLoadingStatusChangeProp(status);
    context.setImageLoadingStatus(status);
  });
  useIsoLayoutEffect(() => {
    if (imageLoadingStatus !== "idle") {
      handleLoadingStatusChange(imageLoadingStatus);
    }
  }, [imageLoadingStatus, handleLoadingStatusChange]);
  const state = React54.useMemo(() => ({
    imageLoadingStatus
  }), [imageLoadingStatus]);
  const element = useRenderElement("img", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: avatarStateAttributesMapping,
    enabled: imageLoadingStatus === "loaded"
  });
  return element;
});
if (true) AvatarImage.displayName = "AvatarImage";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/avatar/fallback/AvatarFallback.js
var React55 = __toESM(require_react(), 1);
var AvatarFallback = React55.forwardRef(function AvatarFallback2(componentProps, forwardedRef) {
  const {
    className,
    render,
    delay,
    ...elementProps
  } = componentProps;
  const {
    imageLoadingStatus
  } = useAvatarRootContext();
  const [delayPassed, setDelayPassed] = React55.useState(delay === void 0);
  const timeout = useTimeout();
  React55.useEffect(() => {
    if (delay !== void 0) {
      timeout.start(delay, () => setDelayPassed(true));
    }
    return timeout.clear;
  }, [timeout, delay]);
  const state = React55.useMemo(() => ({
    imageLoadingStatus
  }), [imageLoadingStatus]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: avatarStateAttributesMapping,
    enabled: imageLoadingStatus !== "loaded" && delayPassed
  });
  return element;
});
if (true) AvatarFallback.displayName = "AvatarFallback";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/index.parts.js
var index_parts_exports13 = {};
__export(index_parts_exports13, {
  Indicator: () => CheckboxIndicator,
  Root: () => CheckboxRoot
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/root/CheckboxRoot.js
var React59 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/utils/useStateAttributesMapping.js
var React56 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/root/CheckboxRootDataAttributes.js
var CheckboxRootDataAttributes = (function(CheckboxRootDataAttributes2) {
  CheckboxRootDataAttributes2["checked"] = "data-checked";
  CheckboxRootDataAttributes2["unchecked"] = "data-unchecked";
  CheckboxRootDataAttributes2["disabled"] = "data-disabled";
  CheckboxRootDataAttributes2["readonly"] = "data-readonly";
  CheckboxRootDataAttributes2["required"] = "data-required";
  CheckboxRootDataAttributes2["valid"] = "data-valid";
  CheckboxRootDataAttributes2["invalid"] = "data-invalid";
  CheckboxRootDataAttributes2["touched"] = "data-touched";
  CheckboxRootDataAttributes2["dirty"] = "data-dirty";
  CheckboxRootDataAttributes2["filled"] = "data-filled";
  CheckboxRootDataAttributes2["focused"] = "data-focused";
  return CheckboxRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/utils/useStateAttributesMapping.js
function useStateAttributesMapping(state) {
  return React56.useMemo(() => ({
    checked(value) {
      if (state.indeterminate) {
        return {};
      }
      if (value) {
        return {
          [CheckboxRootDataAttributes.checked]: ""
        };
      }
      return {
        [CheckboxRootDataAttributes.unchecked]: ""
      };
    },
    ...fieldValidityMapping
  }), [state.indeterminate]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox-group/CheckboxGroupContext.js
var React57 = __toESM(require_react(), 1);
var CheckboxGroupContext = React57.createContext(void 0);
if (true) CheckboxGroupContext.displayName = "CheckboxGroupContext";
function useCheckboxGroupContext(optional = true) {
  const context = React57.useContext(CheckboxGroupContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: CheckboxGroupContext is missing. CheckboxGroup parts must be placed within <CheckboxGroup>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/root/CheckboxRootContext.js
var React58 = __toESM(require_react(), 1);
var CheckboxRootContext = React58.createContext(void 0);
if (true) CheckboxRootContext.displayName = "CheckboxRootContext";
function useCheckboxRootContext() {
  const context = React58.useContext(CheckboxRootContext);
  if (context === void 0) {
    throw new Error("Base UI: CheckboxRootContext is missing. Checkbox parts must be placed within <Checkbox.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/root/CheckboxRoot.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var EMPTY = {};
var PARENT_CHECKBOX = "data-parent";
var CheckboxRoot = React59.forwardRef(function CheckboxRoot2(componentProps, forwardedRef) {
  const {
    checked: checkedProp,
    className,
    defaultChecked = false,
    disabled: disabledProp = false,
    id: idProp,
    indeterminate = false,
    inputRef: inputRefProp,
    name: nameProp,
    onCheckedChange: onCheckedChangeProp,
    parent = false,
    readOnly = false,
    render,
    required = false,
    value: valueProp,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    clearErrors
  } = useFormContext();
  const {
    disabled: fieldDisabled,
    labelId,
    name: fieldName,
    setControlId,
    setDirty,
    setFilled,
    setFocused,
    setTouched,
    state: fieldState,
    validationMode,
    validityData
  } = useFieldRootContext();
  const groupContext = useCheckboxGroupContext();
  const parentContext = groupContext == null ? void 0 : groupContext.parent;
  const isGrouped = parentContext && groupContext.allValues;
  const disabled = fieldDisabled || (groupContext == null ? void 0 : groupContext.disabled) || disabledProp;
  const name = fieldName ?? nameProp;
  const value = valueProp ?? name;
  let groupProps = {};
  if (isGrouped) {
    if (parent) {
      groupProps = groupContext.parent.getParentProps();
    } else if (value) {
      groupProps = groupContext.parent.getChildProps(value);
    }
  }
  const onCheckedChange = useEventCallback(onCheckedChangeProp);
  const {
    checked: groupChecked = checkedProp,
    indeterminate: groupIndeterminate = indeterminate,
    onCheckedChange: groupOnChange,
    ...otherGroupProps
  } = groupProps;
  const groupValue = groupContext == null ? void 0 : groupContext.value;
  const setGroupValue = groupContext == null ? void 0 : groupContext.setValue;
  const defaultGroupValue = groupContext == null ? void 0 : groupContext.defaultValue;
  const controlRef = React59.useRef(null);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const localFieldControlValidation = useFieldControlValidation();
  const fieldControlValidation = (groupContext == null ? void 0 : groupContext.fieldControlValidation) ?? localFieldControlValidation;
  const [checked, setCheckedState] = useControlled({
    controlled: value && groupValue && !parent ? groupValue.includes(value) : groupChecked,
    default: value && defaultGroupValue && !parent ? defaultGroupValue.includes(value) : defaultChecked,
    name: "Checkbox",
    state: "checked"
  });
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    const element2 = controlRef == null ? void 0 : controlRef.current;
    if (!element2) {
      return void 0;
    }
    if (groupContext) {
      setControlId(idProp ?? null);
    } else if (element2.closest("label") == null) {
      setControlId(id);
    }
    return () => {
      setControlId(void 0);
    };
  }, [groupContext, id, idProp, setControlId]);
  useField({
    enabled: !groupContext,
    id,
    commitValidation: fieldControlValidation.commitValidation,
    value: checked,
    controlRef,
    name,
    getValue: () => checked
  });
  const inputRef = React59.useRef(null);
  const mergedInputRef = useMergedRefs(inputRefProp, inputRef, fieldControlValidation.inputRef);
  useIsoLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = groupIndeterminate;
      if (checked) {
        setFilled(true);
      }
    }
  }, [checked, groupIndeterminate, setFilled]);
  const onFocus = useEventCallback(() => setFocused(true));
  const onBlur = useEventCallback(() => {
    const element2 = inputRef.current;
    if (!element2) {
      return;
    }
    setTouched(true);
    setFocused(false);
    if (validationMode === "onBlur") {
      fieldControlValidation.commitValidation(groupContext ? groupValue : element2.checked);
    }
  });
  const onClick = useEventCallback((event) => {
    var _a;
    if (event.defaultPrevented || readOnly) {
      return;
    }
    event.preventDefault();
    (_a = inputRef.current) == null ? void 0 : _a.click();
  });
  const inputProps = mergeProps(
    {
      checked,
      disabled,
      // parent checkboxes unset `name` to be excluded from form submission
      name: parent ? void 0 : name,
      // Set `id` to stop Chrome warning about an unassociated input
      id: `${id}-input`,
      required,
      ref: mergedInputRef,
      style: visuallyHidden,
      tabIndex: -1,
      type: "checkbox",
      "aria-hidden": true,
      onChange(event) {
        if (event.nativeEvent.defaultPrevented) {
          return;
        }
        const nextChecked = event.target.checked;
        const details = createChangeEventDetails("none", event.nativeEvent);
        groupOnChange == null ? void 0 : groupOnChange(nextChecked, details);
        onCheckedChange(nextChecked, details);
        if (details.isCanceled) {
          return;
        }
        clearErrors(name);
        setDirty(nextChecked !== validityData.initialValue);
        setCheckedState(nextChecked);
        if (!groupContext) {
          setFilled(nextChecked);
          if (validationMode === "onChange") {
            fieldControlValidation.commitValidation(nextChecked);
          } else {
            fieldControlValidation.commitValidation(nextChecked, true);
          }
        }
        if (value && groupValue && setGroupValue && !parent) {
          const nextGroupValue = nextChecked ? [...groupValue, value] : groupValue.filter((item) => item !== value);
          setGroupValue(nextGroupValue, details);
          setFilled(nextGroupValue.length > 0);
          if (validationMode === "onChange") {
            fieldControlValidation.commitValidation(nextGroupValue);
          } else {
            fieldControlValidation.commitValidation(nextGroupValue, true);
          }
        }
      },
      onFocus() {
        var _a;
        (_a = controlRef.current) == null ? void 0 : _a.focus();
      }
    },
    // React <19 sets an empty value if `undefined` is passed explicitly
    // To avoid this, we only set the value if it's defined
    valueProp !== void 0 ? {
      value: (groupContext ? checked && valueProp : valueProp) || ""
    } : EMPTY,
    groupContext ? fieldControlValidation.getValidationProps : fieldControlValidation.getInputValidationProps
  );
  const computedChecked = isGrouped ? Boolean(groupChecked) : checked;
  const computedIndeterminate = isGrouped ? groupIndeterminate || indeterminate : indeterminate;
  React59.useEffect(() => {
    if (parentContext && value) {
      parentContext.disabledStatesRef.current.set(value, disabled);
    }
  }, [parentContext, disabled, value]);
  const state = React59.useMemo(() => ({
    ...fieldState,
    checked: computedChecked,
    disabled,
    readOnly,
    required,
    indeterminate: computedIndeterminate
  }), [fieldState, computedChecked, disabled, readOnly, required, computedIndeterminate]);
  const stateAttributesMapping22 = useStateAttributesMapping(state);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [buttonRef, controlRef, forwardedRef, groupContext == null ? void 0 : groupContext.registerControlRef],
    props: [{
      id,
      role: "checkbox",
      disabled,
      "aria-checked": groupIndeterminate ? "mixed" : checked,
      "aria-readonly": readOnly || void 0,
      "aria-required": required || void 0,
      "aria-labelledby": labelId,
      [PARENT_CHECKBOX]: parent ? "" : void 0,
      onFocus,
      onBlur,
      onClick
    }, fieldControlValidation.getValidationProps, elementProps, otherGroupProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping22
  });
  return (0, import_jsx_runtime18.jsxs)(CheckboxRootContext.Provider, {
    value: state,
    children: [element, !checked && !groupContext && componentProps.name && !parent && (0, import_jsx_runtime18.jsx)("input", {
      type: "hidden",
      name: componentProps.name,
      value: "off"
    }), (0, import_jsx_runtime18.jsx)("input", {
      ...inputProps
    })]
  });
});
if (true) CheckboxRoot.displayName = "CheckboxRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox/indicator/CheckboxIndicator.js
var React60 = __toESM(require_react(), 1);
var CheckboxIndicator = React60.forwardRef(function CheckboxIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const rootState = useCheckboxRootContext();
  const rendered = rootState.checked || rootState.indeterminate;
  const {
    transitionStatus,
    setMounted
  } = useTransitionStatus(rendered);
  const indicatorRef = React60.useRef(null);
  const state = React60.useMemo(() => ({
    ...rootState,
    transitionStatus
  }), [rootState, transitionStatus]);
  useOpenChangeComplete({
    open: rendered,
    ref: indicatorRef,
    onComplete() {
      if (!rendered) {
        setMounted(false);
      }
    }
  });
  const baseStateAttributesMapping = useStateAttributesMapping(rootState);
  const stateAttributesMapping22 = React60.useMemo(() => ({
    ...baseStateAttributesMapping,
    ...transitionStatusMapping,
    ...fieldValidityMapping
  }), [baseStateAttributesMapping]);
  const shouldRender = keepMounted || rendered;
  const element = useRenderElement("span", componentProps, {
    enabled: shouldRender,
    ref: [forwardedRef, indicatorRef],
    state,
    stateAttributesMapping: stateAttributesMapping22,
    props: elementProps
  });
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) CheckboxIndicator.displayName = "CheckboxIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox-group/CheckboxGroup.js
var React62 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox-group/useCheckboxGroupParent.js
var React61 = __toESM(require_react(), 1);
var EMPTY2 = [];
function useCheckboxGroupParent(params) {
  const {
    allValues = EMPTY2,
    value = EMPTY2,
    onValueChange: onValueChangeProp
  } = params;
  const uncontrolledStateRef = React61.useRef(value);
  const disabledStatesRef = React61.useRef(/* @__PURE__ */ new Map());
  const [status, setStatus] = React61.useState("mixed");
  const id = useBaseUiId();
  const checked = value.length === allValues.length;
  const indeterminate = value.length !== allValues.length && value.length > 0;
  const onValueChange = useEventCallback(onValueChangeProp);
  const getParentProps = React61.useCallback(() => ({
    id,
    indeterminate,
    checked,
    "aria-controls": allValues.map((v) => `${id}-${v}`).join(" "),
    onCheckedChange(_, eventDetails) {
      const uncontrolledState = uncontrolledStateRef.current;
      const none = allValues.filter((v) => disabledStatesRef.current.get(v) && uncontrolledState.includes(v));
      const all = allValues.filter((v) => !disabledStatesRef.current.get(v) || disabledStatesRef.current.get(v) && uncontrolledState.includes(v));
      const allOnOrOff = uncontrolledState.length === all.length || uncontrolledState.length === 0;
      if (allOnOrOff) {
        if (value.length === all.length) {
          onValueChange(none, eventDetails);
        } else {
          onValueChange(all, eventDetails);
        }
        return;
      }
      if (status === "mixed") {
        onValueChange(all, eventDetails);
        setStatus("on");
      } else if (status === "on") {
        onValueChange(none, eventDetails);
        setStatus("off");
      } else if (status === "off") {
        onValueChange(uncontrolledState, eventDetails);
        setStatus("mixed");
      }
    }
  }), [allValues, checked, id, indeterminate, onValueChange, status, value.length]);
  const getChildProps = React61.useCallback((name) => ({
    name,
    id: `${id}-${name}`,
    checked: value.includes(name),
    onCheckedChange(nextChecked, eventDetails) {
      const newValue = value.slice();
      if (nextChecked) {
        newValue.push(name);
      } else {
        newValue.splice(newValue.indexOf(name), 1);
      }
      uncontrolledStateRef.current = newValue;
      onValueChange(newValue, eventDetails);
      setStatus("mixed");
    }
  }), [id, onValueChange, value]);
  return React61.useMemo(() => ({
    id,
    indeterminate,
    getParentProps,
    getChildProps,
    disabledStatesRef
  }), [id, indeterminate, getParentProps, getChildProps]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/checkbox-group/CheckboxGroup.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var CheckboxGroup = React62.forwardRef(function CheckboxGroup2(componentProps, forwardedRef) {
  const {
    allValues,
    className,
    defaultValue,
    disabled: disabledProp = false,
    id: idProp,
    onValueChange,
    render,
    value: externalValue,
    ...elementProps
  } = componentProps;
  const {
    disabled: fieldDisabled,
    labelId,
    name: fieldName,
    state: fieldState
  } = useFieldRootContext();
  const disabled = fieldDisabled || disabledProp;
  const fieldControlValidation = useFieldControlValidation();
  const [value, setValueUnwrapped] = useControlled({
    controlled: externalValue,
    default: defaultValue,
    name: "CheckboxGroup",
    state: "value"
  });
  const setValue = useEventCallback((v, eventDetails) => {
    onValueChange == null ? void 0 : onValueChange(v, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setValueUnwrapped(v);
  });
  const parent = useCheckboxGroupParent({
    allValues,
    value: externalValue,
    onValueChange
  });
  const id = useBaseUiId(idProp);
  const controlRef = React62.useRef(null);
  const registerControlRef = useEventCallback((element2) => {
    if (controlRef.current == null && element2 != null && !element2.hasAttribute(PARENT_CHECKBOX)) {
      controlRef.current = element2;
    }
  });
  useField({
    enabled: !!fieldName,
    id,
    commitValidation: fieldControlValidation.commitValidation,
    value,
    controlRef,
    name: fieldName,
    getValue: () => value
  });
  const state = React62.useMemo(() => ({
    ...fieldState,
    disabled
  }), [fieldState, disabled]);
  const contextValue = React62.useMemo(() => ({
    allValues,
    value,
    defaultValue,
    setValue,
    parent,
    disabled,
    fieldControlValidation,
    registerControlRef
  }), [allValues, value, defaultValue, setValue, parent, disabled, fieldControlValidation, registerControlRef]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      role: "group",
      "aria-labelledby": labelId
    }, elementProps],
    stateAttributesMapping: fieldValidityMapping
  });
  return (0, import_jsx_runtime19.jsx)(CheckboxGroupContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) CheckboxGroup.displayName = "CheckboxGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/index.parts.js
var index_parts_exports14 = {};
__export(index_parts_exports14, {
  Panel: () => CollapsiblePanel,
  Root: () => CollapsibleRoot,
  Trigger: () => CollapsibleTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/root/CollapsibleRoot.js
var React63 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/root/stateAttributesMapping.js
var collapsibleStateAttributesMapping = {
  ...collapsibleOpenStateMapping,
  ...transitionStatusMapping
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/root/CollapsibleRoot.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var CollapsibleRoot = React63.forwardRef(function CollapsibleRoot2(componentProps, forwardedRef) {
  const {
    render,
    className,
    defaultOpen = false,
    disabled = false,
    onOpenChange: onOpenChangeProp,
    open,
    ...elementProps
  } = componentProps;
  const onOpenChange = useEventCallback(onOpenChangeProp);
  const collapsible = useCollapsibleRoot({
    open,
    defaultOpen,
    onOpenChange,
    disabled
  });
  const state = React63.useMemo(() => ({
    open: collapsible.open,
    disabled: collapsible.disabled,
    transitionStatus: collapsible.transitionStatus
  }), [collapsible.open, collapsible.disabled, collapsible.transitionStatus]);
  const contextValue = React63.useMemo(() => ({
    ...collapsible,
    onOpenChange,
    state
  }), [collapsible, onOpenChange, state]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: collapsibleStateAttributesMapping
  });
  if (componentProps.render !== null) {
    return (0, import_jsx_runtime20.jsx)(CollapsibleRootContext.Provider, {
      value: contextValue,
      children: element
    });
  }
  return (0, import_jsx_runtime20.jsx)(CollapsibleRootContext.Provider, {
    value: contextValue,
    children: elementProps.children
  });
});
if (true) CollapsibleRoot.displayName = "CollapsibleRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/trigger/CollapsibleTrigger.js
var React64 = __toESM(require_react(), 1);
var stateAttributesMapping8 = {
  ...triggerOpenStateMapping2,
  ...transitionStatusMapping
};
var CollapsibleTrigger = React64.forwardRef(function CollapsibleTrigger2(componentProps, forwardedRef) {
  const {
    panelId,
    open,
    handleTrigger,
    state,
    disabled: contextDisabled
  } = useCollapsibleRootContext();
  const {
    className,
    disabled = contextDisabled,
    id,
    render,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    native: nativeButton
  });
  const props = React64.useMemo(() => ({
    "aria-controls": open ? panelId : void 0,
    "aria-expanded": open,
    disabled,
    onClick: handleTrigger
  }), [panelId, disabled, open, handleTrigger]);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, buttonRef],
    props: [props, elementProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping8
  });
  return element;
});
if (true) CollapsibleTrigger.displayName = "CollapsibleTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/panel/CollapsiblePanel.js
var React65 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/panel/CollapsiblePanelCssVars.js
var CollapsiblePanelCssVars = (function(CollapsiblePanelCssVars2) {
  CollapsiblePanelCssVars2["collapsiblePanelHeight"] = "--collapsible-panel-height";
  CollapsiblePanelCssVars2["collapsiblePanelWidth"] = "--collapsible-panel-width";
  return CollapsiblePanelCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/collapsible/panel/CollapsiblePanel.js
var CollapsiblePanel = React65.forwardRef(function CollapsiblePanel2(componentProps, forwardedRef) {
  const {
    className,
    hiddenUntilFound: hiddenUntilFoundProp,
    keepMounted: keepMountedProp,
    render,
    id: idProp,
    ...elementProps
  } = componentProps;
  if (true) {
    useIsoLayoutEffect(() => {
      if (hiddenUntilFoundProp && keepMountedProp === false) {
        warn("The `keepMounted={false}` prop on a Collapsible will be ignored when using `hiddenUntilFound` since it requires the Panel to remain mounted even when closed.");
      }
    }, [hiddenUntilFoundProp, keepMountedProp]);
  }
  const {
    abortControllerRef,
    animationTypeRef,
    height,
    mounted,
    onOpenChange,
    open,
    panelId,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setHiddenUntilFound,
    setKeepMounted,
    setMounted,
    setPanelIdState,
    setOpen,
    setVisible,
    state,
    transitionDimensionRef,
    visible,
    width,
    transitionStatus
  } = useCollapsibleRootContext();
  const hiddenUntilFound = hiddenUntilFoundProp ?? false;
  const keepMounted = keepMountedProp ?? false;
  useIsoLayoutEffect(() => {
    if (idProp) {
      setPanelIdState(idProp);
      return () => {
        setPanelIdState(void 0);
      };
    }
    return void 0;
  }, [idProp, setPanelIdState]);
  useIsoLayoutEffect(() => {
    setHiddenUntilFound(hiddenUntilFound);
  }, [setHiddenUntilFound, hiddenUntilFound]);
  useIsoLayoutEffect(() => {
    setKeepMounted(keepMounted);
  }, [setKeepMounted, keepMounted]);
  const {
    props
  } = useCollapsiblePanel({
    abortControllerRef,
    animationTypeRef,
    externalRef: forwardedRef,
    height,
    hiddenUntilFound,
    id: panelId,
    keepMounted,
    mounted,
    onOpenChange,
    open,
    panelRef,
    runOnceAnimationsFinish,
    setDimensions,
    setMounted,
    setOpen,
    setVisible,
    transitionDimensionRef,
    visible,
    width
  });
  useOpenChangeComplete({
    open: open && transitionStatus === "idle",
    ref: panelRef,
    onComplete() {
      if (!open) {
        return;
      }
      setDimensions({
        height: void 0,
        width: void 0
      });
    }
  });
  const panelState = React65.useMemo(() => ({
    ...state,
    transitionStatus
  }), [state, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    state: panelState,
    ref: [forwardedRef, panelRef],
    props: [props, {
      style: {
        [CollapsiblePanelCssVars.collapsiblePanelHeight]: height === void 0 ? "auto" : `${height}px`,
        [CollapsiblePanelCssVars.collapsiblePanelWidth]: width === void 0 ? "auto" : `${width}px`
      }
    }, elementProps],
    stateAttributesMapping: collapsibleStateAttributesMapping
  });
  const shouldRender = keepMounted || hiddenUntilFound || !keepMounted && mounted;
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) CollapsiblePanel.displayName = "CollapsiblePanel";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/index.parts.js
var index_parts_exports15 = {};
__export(index_parts_exports15, {
  Arrow: () => ComboboxArrow,
  Backdrop: () => ComboboxBackdrop,
  Chip: () => ComboboxChip,
  ChipRemove: () => ComboboxChipRemove,
  Chips: () => ComboboxChips,
  Clear: () => ComboboxClear,
  Collection: () => ComboboxCollection,
  Empty: () => ComboboxEmpty,
  Group: () => ComboboxGroup,
  GroupLabel: () => ComboboxGroupLabel,
  Icon: () => ComboboxIcon,
  Input: () => ComboboxInput,
  Item: () => ComboboxItem,
  ItemIndicator: () => ComboboxItemIndicator,
  List: () => ComboboxList,
  Popup: () => ComboboxPopup,
  Portal: () => ComboboxPortal,
  Positioner: () => ComboboxPositioner,
  Root: () => ComboboxRoot,
  Row: () => ComboboxRow,
  Separator: () => Separator,
  Status: () => ComboboxStatus,
  Trigger: () => ComboboxTrigger,
  Value: () => ComboboxValue,
  useFilter: () => useComboboxFilter
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/root/ComboboxRoot.js
var React66 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function ComboboxRoot(props) {
  const {
    multiple = false,
    defaultValue,
    value,
    onValueChange,
    ...other
  } = props;
  return (0, import_jsx_runtime21.jsx)(ComboboxRootInternal, {
    ...other,
    selectionMode: multiple ? "multiple" : "single",
    selectedValue: value,
    defaultSelectedValue: defaultValue,
    onSelectedValueChange: onValueChange
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/value/ComboboxValue.js
function ComboboxValue(props) {
  const {
    children: childrenProp
  } = props;
  const store = useComboboxRootContext();
  const itemToStringLabel = useStore(store, selectors2.itemToStringLabel);
  const selectedValue = useStore(store, selectors2.selectedValue);
  const items = useStore(store, selectors2.items);
  if (typeof childrenProp === "function") {
    return childrenProp(selectedValue);
  }
  if (childrenProp != null) {
    return childrenProp;
  }
  return resolveSelectedLabel(selectedValue, items, itemToStringLabel);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/item-indicator/ComboboxItemIndicator.js
var React67 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var ComboboxItemIndicator = React67.forwardRef(function ComboboxItemIndicator2(componentProps, forwardedRef) {
  const keepMounted = componentProps.keepMounted ?? false;
  const {
    selected
  } = useComboboxItemContext();
  const shouldRender = keepMounted || selected;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime22.jsx)(Inner, {
    ...componentProps,
    ref: forwardedRef
  });
});
if (true) ComboboxItemIndicator.displayName = "ComboboxItemIndicator";
var Inner = React67.memo(React67.forwardRef((componentProps, forwardedRef) => {
  const {
    render,
    className,
    keepMounted,
    ...elementProps
  } = componentProps;
  const {
    selected
  } = useComboboxItemContext();
  const indicatorRef = React67.useRef(null);
  const {
    mounted,
    transitionStatus,
    setMounted
  } = useTransitionStatus(selected);
  const state = React67.useMemo(() => ({
    selected,
    transitionStatus
  }), [selected, transitionStatus]);
  const element = useRenderElement("span", componentProps, {
    ref: [forwardedRef, indicatorRef],
    state,
    props: [{
      hidden: !mounted,
      "aria-hidden": true,
      children: ""
    }, elementProps],
    stateAttributesMapping: transitionStatusMapping
  });
  useOpenChangeComplete({
    open: selected,
    ref: indicatorRef,
    onComplete() {
      if (!selected) {
        setMounted(false);
      }
    }
  });
  return element;
}));
if (true) Inner.displayName = "Inner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/chips/ComboboxChips.js
var React68 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var ComboboxChips = React68.forwardRef(function ComboboxChips2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const chipsContainerRef = useStore(store, selectors2.chipsContainerRef);
  const open = useStore(store, selectors2.open);
  const [highlightedChipIndex, setHighlightedChipIndex] = React68.useState(void 0);
  if (open && highlightedChipIndex !== void 0) {
    setHighlightedChipIndex(void 0);
  }
  const chipsRef = React68.useRef([]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, chipsContainerRef],
    props: elementProps
  });
  const contextValue = React68.useMemo(() => ({
    highlightedChipIndex,
    setHighlightedChipIndex,
    chipsRef
  }), [highlightedChipIndex, setHighlightedChipIndex, chipsRef]);
  return (0, import_jsx_runtime23.jsx)(ComboboxChipsContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime23.jsx)(CompositeList, {
      elementsRef: chipsRef,
      children: element
    })
  });
});
if (true) ComboboxChips.displayName = "ComboboxChips";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/chip/ComboboxChip.js
var React70 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/chip/ComboboxChipContext.js
var React69 = __toESM(require_react(), 1);
var ComboboxChipContext = React69.createContext(void 0);
if (true) ComboboxChipContext.displayName = "ComboboxChipContext";
function useComboboxChipContext() {
  const context = React69.useContext(ComboboxChipContext);
  if (!context) {
    throw new Error("useComboboxChipContext must be used within a ComboboxChip");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/chip/ComboboxChip.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var ComboboxChip = React70.forwardRef(function ComboboxChip2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const {
    setHighlightedChipIndex,
    chipsRef
  } = useComboboxChipsContext();
  const disabled = useStore(store, selectors2.disabled);
  const readOnly = useStore(store, selectors2.readOnly);
  const selectedValue = useStore(store, selectors2.selectedValue);
  const {
    ref,
    index
  } = useCompositeListItem();
  function handleKeyDown(event) {
    let nextIndex = index;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      if (index > 0) {
        nextIndex = index - 1;
      } else {
        nextIndex = void 0;
      }
    } else if (event.key === "ArrowRight") {
      event.preventDefault();
      if (index < selectedValue.length - 1) {
        nextIndex = index + 1;
      } else {
        nextIndex = void 0;
      }
    } else if (event.key === "Backspace" || event.key === "Delete") {
      const computedNextIndex = index >= selectedValue.length - 1 ? selectedValue.length - 2 : index;
      nextIndex = computedNextIndex >= 0 ? computedNextIndex : void 0;
      stopEvent(event);
      store.state.setIndices({
        activeIndex: null,
        selectedIndex: null,
        type: "keyboard"
      });
      store.state.setSelectedValue(selectedValue.filter((_, i) => i !== index), createChangeEventDetails("none", event.nativeEvent));
    } else if (event.key === "Enter" || event.key === " ") {
      stopEvent(event);
      nextIndex = void 0;
    } else if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      stopEvent(event);
      store.state.setOpen(true, createChangeEventDetails("list-navigation", event.nativeEvent));
      nextIndex = void 0;
    } else if (
      // Check for printable characters (letters, numbers, symbols)
      event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey
    ) {
      nextIndex = void 0;
    }
    return nextIndex;
  }
  const state = React70.useMemo(() => ({
    disabled
  }), [disabled]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, ref],
    state,
    props: [{
      tabIndex: -1,
      "aria-disabled": disabled || void 0,
      "aria-readonly": readOnly || void 0,
      onKeyDown(event) {
        var _a, _b;
        if (disabled || readOnly) {
          return;
        }
        const nextIndex = handleKeyDown(event);
        ReactDOM2.flushSync(() => {
          setHighlightedChipIndex(nextIndex);
        });
        if (nextIndex === void 0) {
          (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
        } else {
          (_b = chipsRef.current[nextIndex]) == null ? void 0 : _b.focus();
        }
      },
      onMouseDown(event) {
        var _a;
        if (disabled || readOnly) {
          return;
        }
        event.preventDefault();
        (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
      }
    }, elementProps]
  });
  const contextValue = React70.useMemo(() => ({
    index
  }), [index]);
  return (0, import_jsx_runtime24.jsx)(ComboboxChipContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) ComboboxChip.displayName = "ComboboxChip";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/combobox/chip-remove/ComboboxChipRemove.js
var React71 = __toESM(require_react(), 1);
var ComboboxChipRemove = React71.forwardRef(function ComboboxChipRemove2(componentProps, forwardedRef) {
  const {
    render,
    className,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const store = useComboboxRootContext();
  const {
    index
  } = useComboboxChipContext();
  const disabled = useStore(store, selectors2.disabled);
  const readOnly = useStore(store, selectors2.readOnly);
  const valuesRef = useStore(store, selectors2.valuesRef);
  const selectedValue = useStore(store, selectors2.selectedValue);
  const isItemEqualToValue = useStore(store, selectors2.isItemEqualToValue);
  const {
    buttonRef,
    getButtonProps
  } = useButton({
    native: nativeButton,
    disabled: disabled || readOnly,
    focusableWhenDisabled: true
  });
  const state = React71.useMemo(() => ({
    disabled
  }), [disabled]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state,
    props: [{
      tabIndex: -1,
      disabled,
      "aria-readonly": readOnly || void 0,
      onClick(event) {
        var _a;
        if (disabled || readOnly) {
          return;
        }
        const eventDetails = createChangeEventDetails("chip-remove-press", event.nativeEvent);
        const activeIndex = store.state.activeIndex;
        const removedItem = selectedValue[index];
        const removedIndex = findItemIndex(valuesRef.current, removedItem, isItemEqualToValue);
        if (removedIndex !== -1 && activeIndex === removedIndex) {
          store.state.setIndices({
            activeIndex: null,
            type: store.state.keyboardActiveRef.current ? "pointer" : "keyboard"
          });
        }
        store.state.setSelectedValue(selectedValue.filter((_, i) => i !== index), eventDetails);
        if (!eventDetails.isPropagationAllowed) {
          event.stopPropagation();
        }
        (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
      },
      onKeyDown(event) {
        var _a;
        if (disabled || readOnly) {
          return;
        }
        const eventDetails = createChangeEventDetails("chip-remove-press", event.nativeEvent);
        if (event.key === "Enter" || event.key === " ") {
          const activeIndex = store.state.activeIndex;
          const removedItem = selectedValue[index];
          const removedIndex = findItemIndex(valuesRef.current, removedItem, isItemEqualToValue);
          if (removedIndex !== -1 && activeIndex === removedIndex) {
            store.state.setIndices({
              activeIndex: null,
              type: store.state.keyboardActiveRef.current ? "pointer" : "keyboard"
            });
          }
          store.state.setSelectedValue(selectedValue.filter((_, i) => i !== index), eventDetails);
          if (!eventDetails.isPropagationAllowed) {
            stopEvent(event);
          }
          (_a = store.state.inputRef.current) == null ? void 0 : _a.focus();
        }
      }
    }, elementProps, getButtonProps]
  });
  return element;
});
if (true) ComboboxChipRemove.displayName = "ComboboxChipRemove";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/context-menu/index.parts.js
var index_parts_exports16 = {};
__export(index_parts_exports16, {
  Arrow: () => MenuArrow,
  Backdrop: () => MenuBackdrop,
  CheckboxItem: () => MenuCheckboxItem,
  CheckboxItemIndicator: () => MenuCheckboxItemIndicator,
  Group: () => MenuGroup,
  GroupLabel: () => MenuGroupLabel,
  Item: () => MenuItem,
  Popup: () => MenuPopup,
  Portal: () => MenuPortal,
  Positioner: () => MenuPositioner,
  RadioGroup: () => MenuRadioGroup,
  RadioItem: () => MenuRadioItem,
  RadioItemIndicator: () => MenuRadioItemIndicator,
  Root: () => ContextMenuRoot,
  Separator: () => Separator,
  SubmenuRoot: () => MenuSubmenuRoot,
  SubmenuTrigger: () => MenuSubmenuTrigger,
  Trigger: () => ContextMenuTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/context-menu/root/ContextMenuRoot.js
var React72 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function ContextMenuRoot(props) {
  const [anchor, setAnchor] = React72.useState({
    getBoundingClientRect() {
      return DOMRect.fromRect({
        width: 0,
        height: 0,
        x: 0,
        y: 0
      });
    }
  });
  const backdropRef = React72.useRef(null);
  const internalBackdropRef = React72.useRef(null);
  const actionsRef = React72.useRef(null);
  const positionerRef = React72.useRef(null);
  const allowMouseUpTriggerRef = React72.useRef(true);
  const id = useId();
  const contextValue = React72.useMemo(() => ({
    anchor,
    setAnchor,
    actionsRef,
    backdropRef,
    internalBackdropRef,
    positionerRef,
    allowMouseUpTriggerRef,
    rootId: id
  }), [anchor, id]);
  return (0, import_jsx_runtime25.jsx)(ContextMenuRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime25.jsx)(MenuRootContext.Provider, {
      value: void 0,
      children: (0, import_jsx_runtime25.jsx)(index_parts_exports.Root, {
        ...props
      })
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/context-menu/trigger/ContextMenuTrigger.js
var React73 = __toESM(require_react(), 1);
var LONG_PRESS_DELAY = 500;
var ContextMenuTrigger = React73.forwardRef(function ContextMenuTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    setAnchor,
    actionsRef,
    internalBackdropRef,
    backdropRef,
    positionerRef,
    allowMouseUpTriggerRef,
    rootId
  } = useContextMenuRootContext(false);
  const triggerRef = React73.useRef(null);
  const touchPositionRef = React73.useRef(null);
  const longPressTimeout = useTimeout();
  const allowMouseUpTimeout = useTimeout();
  const allowMouseUpRef = React73.useRef(false);
  const handleLongPress = useEventCallback((x, y, event) => {
    var _a;
    const isTouchEvent = event.type.startsWith("touch");
    setAnchor({
      getBoundingClientRect() {
        return DOMRect.fromRect({
          width: isTouchEvent ? 10 : 0,
          height: isTouchEvent ? 10 : 0,
          x,
          y
        });
      }
    });
    allowMouseUpRef.current = false;
    (_a = actionsRef.current) == null ? void 0 : _a.setOpen(true, createChangeEventDetails("trigger-press", event));
    allowMouseUpTimeout.start(LONG_PRESS_DELAY, () => {
      allowMouseUpRef.current = true;
    });
  });
  const handleContextMenu = useEventCallback((event) => {
    allowMouseUpTriggerRef.current = true;
    stopEvent(event);
    handleLongPress(event.clientX, event.clientY, event.nativeEvent);
    const doc = ownerDocument(triggerRef.current);
    doc.addEventListener("mouseup", (mouseEvent) => {
      var _a;
      allowMouseUpTriggerRef.current = false;
      if (!allowMouseUpRef.current) {
        return;
      }
      allowMouseUpTimeout.clear();
      allowMouseUpRef.current = false;
      const mouseUpTarget = getTarget(mouseEvent);
      if (contains(positionerRef.current, mouseUpTarget)) {
        return;
      }
      if (rootId && mouseUpTarget && findRootOwnerId(mouseUpTarget) === rootId) {
        return;
      }
      (_a = actionsRef.current) == null ? void 0 : _a.setOpen(false, createChangeEventDetails("cancel-open", mouseEvent));
    }, {
      once: true
    });
  });
  const handleTouchStart = useEventCallback((event) => {
    allowMouseUpTriggerRef.current = false;
    if (event.touches.length === 1) {
      event.stopPropagation();
      const touch = event.touches[0];
      touchPositionRef.current = {
        x: touch.clientX,
        y: touch.clientY
      };
      longPressTimeout.start(LONG_PRESS_DELAY, () => {
        if (touchPositionRef.current) {
          handleLongPress(touchPositionRef.current.x, touchPositionRef.current.y, event.nativeEvent);
        }
      });
    }
  });
  const handleTouchMove = useEventCallback((event) => {
    if (longPressTimeout.isStarted() && touchPositionRef.current && event.touches.length === 1) {
      const touch = event.touches[0];
      const moveThreshold = 10;
      const deltaX = Math.abs(touch.clientX - touchPositionRef.current.x);
      const deltaY = Math.abs(touch.clientY - touchPositionRef.current.y);
      if (deltaX > moveThreshold || deltaY > moveThreshold) {
        longPressTimeout.clear();
      }
    }
  });
  const handleTouchEnd = useEventCallback(() => {
    longPressTimeout.clear();
    touchPositionRef.current = null;
  });
  React73.useEffect(() => {
    function handleDocumentContextMenu(event) {
      const target = getTarget(event);
      const targetElement = target;
      if (contains(triggerRef.current, targetElement) || contains(internalBackdropRef.current, targetElement) || contains(backdropRef.current, targetElement)) {
        event.preventDefault();
      }
    }
    const doc = ownerDocument(triggerRef.current);
    doc.addEventListener("contextmenu", handleDocumentContextMenu);
    return () => {
      doc.removeEventListener("contextmenu", handleDocumentContextMenu);
    };
  }, [backdropRef, internalBackdropRef]);
  const element = useRenderElement("div", componentProps, {
    ref: [triggerRef, forwardedRef],
    props: [{
      onContextMenu: handleContextMenu,
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
      onTouchEnd: handleTouchEnd,
      onTouchCancel: handleTouchEnd,
      style: {
        WebkitTouchCallout: "none"
      }
    }, elementProps]
  });
  return element;
});
if (true) ContextMenuTrigger.displayName = "ContextMenuTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/index.parts.js
var index_parts_exports17 = {};
__export(index_parts_exports17, {
  Backdrop: () => DialogBackdrop,
  Close: () => DialogClose,
  Description: () => DialogDescription,
  Popup: () => DialogPopup,
  Portal: () => DialogPortal,
  Root: () => DialogRoot,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/backdrop/DialogBackdrop.js
var React74 = __toESM(require_react(), 1);
var stateAttributesMapping9 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var DialogBackdrop = React74.forwardRef(function DialogBackdrop2(componentProps, forwardedRef) {
  const {
    render,
    className,
    forceRender = false,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const open = store.useState("open");
  const nested = store.useState("nested");
  const mounted = store.useState("mounted");
  const transitionStatus = store.useState("transitionStatus");
  const state = React74.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  return useRenderElement("div", componentProps, {
    state,
    ref: [store.context.backdropRef, forwardedRef],
    stateAttributesMapping: stateAttributesMapping9,
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps],
    enabled: forceRender || !nested
  });
});
if (true) DialogBackdrop.displayName = "DialogBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/close/DialogClose.js
var React75 = __toESM(require_react(), 1);
var DialogClose = React75.forwardRef(function DialogClose2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const open = store.useState("open");
  const {
    getRootProps,
    ref
  } = useDialogClose({
    disabled,
    open,
    setOpen: store.setOpen,
    nativeButton
  });
  const state = React75.useMemo(() => ({
    disabled
  }), [disabled]);
  return useRenderElement("button", componentProps, {
    state,
    ref: [forwardedRef, ref],
    props: [elementProps, getRootProps]
  });
});
if (true) DialogClose.displayName = "DialogClose";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/description/DialogDescription.js
var React76 = __toESM(require_react(), 1);
var DialogDescription = React76.forwardRef(function DialogDescription2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const id = useBaseUiId(idProp);
  store.useSyncedValueWithCleanup("descriptionElementId", id);
  return useRenderElement("p", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
});
if (true) DialogDescription.displayName = "DialogDescription";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/popup/DialogPopup.js
var React78 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/popup/DialogPopupCssVars.js
var DialogPopupCssVars = (function(DialogPopupCssVars2) {
  DialogPopupCssVars2["nestedDialogs"] = "--nested-dialogs";
  return DialogPopupCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/popup/DialogPopupDataAttributes.js
var DialogPopupDataAttributes = (function(DialogPopupDataAttributes2) {
  DialogPopupDataAttributes2[DialogPopupDataAttributes2["open"] = CommonPopupDataAttributes.open] = "open";
  DialogPopupDataAttributes2[DialogPopupDataAttributes2["closed"] = CommonPopupDataAttributes.closed] = "closed";
  DialogPopupDataAttributes2[DialogPopupDataAttributes2["startingStyle"] = CommonPopupDataAttributes.startingStyle] = "startingStyle";
  DialogPopupDataAttributes2[DialogPopupDataAttributes2["endingStyle"] = CommonPopupDataAttributes.endingStyle] = "endingStyle";
  DialogPopupDataAttributes2["nested"] = "data-nested";
  DialogPopupDataAttributes2["nestedDialogOpen"] = "data-nested-dialog-open";
  return DialogPopupDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/portal/DialogPortalContext.js
var React77 = __toESM(require_react(), 1);
var DialogPortalContext = React77.createContext(void 0);
if (true) DialogPortalContext.displayName = "DialogPortalContext";
function useDialogPortalContext() {
  const value = React77.useContext(DialogPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <Dialog.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/popup/DialogPopup.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping10 = {
  ...popupStateMapping,
  ...transitionStatusMapping,
  nestedDialogOpen(value) {
    return value ? {
      [DialogPopupDataAttributes.nestedDialogOpen]: ""
    } : null;
  }
};
var DialogPopup = React78.forwardRef(function DialogPopup2(componentProps, forwardedRef) {
  const {
    className,
    finalFocus,
    initialFocus,
    render,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const descriptionElementId = store.useState("descriptionElementId");
  const dismissible = store.useState("dismissible");
  const floatingRootContext = store.useState("floatingRootContext");
  const rootPopupProps = store.useState("popupProps");
  const modal = store.useState("modal");
  const mounted = store.useState("mounted");
  const nested = store.useState("nested");
  const nestedOpenDialogCount = store.useState("nestedOpenDialogCount");
  const open = store.useState("open");
  const openMethod = store.useState("openMethod");
  const titleElementId = store.useState("titleElementId");
  const transitionStatus = store.useState("transitionStatus");
  useDialogPortalContext();
  useOpenChangeComplete({
    open,
    ref: store.context.popupRef,
    onComplete() {
      var _a, _b;
      if (open) {
        (_b = (_a = store.context).openChangeComplete) == null ? void 0 : _b.call(_a, true);
      }
    }
  });
  const defaultInitialFocus = useEventCallback((interactionType) => {
    if (interactionType === "touch") {
      return store.context.popupRef.current;
    }
    return true;
  });
  const resolvedInitialFocus = initialFocus === void 0 ? defaultInitialFocus : initialFocus;
  const nestedDialogOpen = nestedOpenDialogCount > 0;
  const state = React78.useMemo(() => ({
    open,
    nested,
    transitionStatus,
    nestedDialogOpen
  }), [open, nested, transitionStatus, nestedDialogOpen]);
  const element = useRenderElement("div", componentProps, {
    state,
    props: [rootPopupProps, {
      "aria-labelledby": titleElementId ?? void 0,
      "aria-describedby": descriptionElementId ?? void 0,
      role: "dialog",
      tabIndex: -1,
      hidden: !mounted,
      onKeyDown(event) {
        if (COMPOSITE_KEYS.has(event.key)) {
          event.stopPropagation();
        }
      },
      style: {
        [DialogPopupCssVars.nestedDialogs]: nestedOpenDialogCount
      }
    }, elementProps],
    ref: [forwardedRef, store.context.popupRef, store.getElementSetter("popupElement")],
    stateAttributesMapping: stateAttributesMapping10
  });
  return (0, import_jsx_runtime26.jsxs)(React78.Fragment, {
    children: [mounted && modal === true && (0, import_jsx_runtime26.jsx)(InternalBackdrop, {
      ref: store.context.internalBackdropRef,
      inert: inertValue(!open)
    }), (0, import_jsx_runtime26.jsx)(FloatingFocusManager, {
      context: floatingRootContext,
      openInteractionType: openMethod,
      disabled: !mounted,
      closeOnFocusOut: dismissible,
      initialFocus: resolvedInitialFocus,
      returnFocus: finalFocus,
      modal: modal !== false,
      restoreFocus: "popup",
      children: element
    })]
  });
});
if (true) DialogPopup.displayName = "DialogPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/portal/DialogPortal.js
var React79 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
function DialogPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    store
  } = useDialogRootContext();
  const mounted = store.useState("mounted");
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime27.jsx)(DialogPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime27.jsx)(FloatingPortal, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/root/DialogRoot.js
var React80 = __toESM(require_react(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var INITIAL_STATE2 = {
  open: false,
  dismissible: true,
  nested: false,
  popupElement: null,
  triggerElement: null,
  modal: true,
  descriptionElementId: void 0,
  titleElementId: void 0,
  openMethod: null,
  mounted: false,
  transitionStatus: "idle",
  nestedOpenDialogCount: 0,
  triggerProps: EMPTY_OBJECT,
  popupProps: EMPTY_OBJECT,
  floatingRootContext: getEmptyContext()
};
var DialogRoot = function DialogRoot2(props) {
  const {
    children,
    open: openProp,
    defaultOpen: defaultOpenProp = false,
    onOpenChange,
    onOpenChangeComplete,
    dismissible = true,
    modal = true,
    actionsRef
  } = props;
  const parentDialogRootContext = useDialogRootContext(true);
  const nested = Boolean(parentDialogRootContext);
  const store = useRefWithInit(DialogStore.create, INITIAL_STATE2).current;
  store.useControlledProp("open", openProp, defaultOpenProp);
  store.useSyncedValues({
    dismissible,
    nested,
    modal
  });
  store.useContextCallback("openChange", onOpenChange);
  store.useContextCallback("openChangeComplete", onOpenChangeComplete);
  useDialogRoot({
    store,
    actionsRef,
    parentContext: parentDialogRootContext == null ? void 0 : parentDialogRootContext.store.context,
    onOpenChange
  });
  const contextValue = React80.useMemo(() => ({
    store
  }), [store]);
  return (0, import_jsx_runtime28.jsx)(DialogRootContext.Provider, {
    value: contextValue,
    children
  });
};
if (true) DialogRoot.displayName = "DialogRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/title/DialogTitle.js
var React81 = __toESM(require_react(), 1);
var DialogTitle = React81.forwardRef(function DialogTitle2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const id = useBaseUiId(idProp);
  store.useSyncedValueWithCleanup("titleElementId", id);
  return useRenderElement("h2", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
});
if (true) DialogTitle.displayName = "DialogTitle";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/dialog/trigger/DialogTrigger.js
var React82 = __toESM(require_react(), 1);
var DialogTrigger = React82.forwardRef(function DialogTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    store
  } = useDialogRootContext();
  const open = store.useState("open");
  const triggerProps = store.useState("triggerProps");
  const state = React82.useMemo(() => ({
    disabled,
    open
  }), [disabled, open]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  return useRenderElement("button", componentProps, {
    state,
    ref: [buttonRef, forwardedRef, store.getElementSetter("triggerElement")],
    props: [triggerProps, {
      [CLICK_TRIGGER_IDENTIFIER]: ""
    }, elementProps, getButtonProps],
    stateAttributesMapping: triggerOpenStateMapping
  });
});
if (true) DialogTrigger.displayName = "DialogTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/direction-provider/DirectionProvider.js
var React83 = __toESM(require_react(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var DirectionProvider = function DirectionProvider2(props) {
  const {
    direction = "ltr"
  } = props;
  const contextValue = React83.useMemo(() => ({
    direction
  }), [direction]);
  return (0, import_jsx_runtime29.jsx)(DirectionContext.Provider, {
    value: contextValue,
    children: props.children
  });
};
if (true) DirectionProvider.displayName = "DirectionProvider";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/fieldset/index.parts.js
var index_parts_exports18 = {};
__export(index_parts_exports18, {
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/fieldset/root/FieldsetRoot.js
var React84 = __toESM(require_react(), 1);
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var FieldsetRoot = React84.forwardRef(function FieldsetRoot2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    ...elementProps
  } = componentProps;
  const [legendId, setLegendId] = React84.useState(void 0);
  const state = React84.useMemo(() => ({
    disabled
  }), [disabled]);
  const element = useRenderElement("fieldset", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      "aria-labelledby": legendId
    }, elementProps]
  });
  const contextValue = React84.useMemo(() => ({
    legendId,
    setLegendId,
    disabled
  }), [legendId, setLegendId, disabled]);
  return (0, import_jsx_runtime30.jsx)(FieldsetRootContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) FieldsetRoot.displayName = "FieldsetRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/fieldset/legend/FieldsetLegend.js
var React85 = __toESM(require_react(), 1);
var FieldsetLegend = React85.forwardRef(function FieldsetLegend2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    disabled,
    setLegendId
  } = useFieldsetRootContext();
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    setLegendId(id);
    return () => {
      setLegendId(void 0);
    };
  }, [setLegendId, id]);
  const state = React85.useMemo(() => ({
    disabled: disabled ?? false
  }), [disabled]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
  return element;
});
if (true) FieldsetLegend.displayName = "FieldsetLegend";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/form/Form.js
var React86 = __toESM(require_react(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var EMPTY3 = {};
var Form = React86.forwardRef(function Form2(componentProps, forwardedRef) {
  const {
    render,
    className,
    errors,
    onClearErrors: onClearErrorsProp,
    onSubmit: onSubmitProp,
    ...elementProps
  } = componentProps;
  const formRef = React86.useRef({
    fields: /* @__PURE__ */ new Map()
  });
  const submittedRef = React86.useRef(false);
  const onSubmit = useEventCallback(onSubmitProp);
  const onClearErrors = useEventCallback(onClearErrorsProp);
  const focusControl = useEventCallback((control) => {
    control.focus();
    if (control.tagName === "INPUT") {
      control.select();
    }
  });
  React86.useEffect(() => {
    if (!submittedRef.current) {
      return;
    }
    submittedRef.current = false;
    const invalidFields = Array.from(formRef.current.fields.values()).filter((field) => field.validityData.state.valid === false);
    if (invalidFields.length) {
      focusControl(invalidFields[0].controlRef.current);
    }
  }, [errors, focusControl]);
  const element = useRenderElement("form", componentProps, {
    state: EMPTY3,
    ref: forwardedRef,
    props: [{
      noValidate: true,
      onSubmit(event) {
        let values = Array.from(formRef.current.fields.values());
        values.forEach((field) => {
          field.validate();
        });
        values = Array.from(formRef.current.fields.values());
        const invalidFields = values.filter((field) => !field.validityData.state.valid);
        if (invalidFields.length) {
          event.preventDefault();
          focusControl(invalidFields[0].controlRef.current);
        } else {
          submittedRef.current = true;
          onSubmit(event);
        }
      }
    }, elementProps]
  });
  const clearErrors = useEventCallback((name) => {
    if (name && errors && EMPTY3.hasOwnProperty.call(errors, name)) {
      const nextErrors = {
        ...errors
      };
      delete nextErrors[name];
      onClearErrors(nextErrors);
    }
  });
  const contextValue = React86.useMemo(() => ({
    formRef,
    errors: errors ?? {},
    clearErrors
  }), [formRef, errors, clearErrors]);
  return (0, import_jsx_runtime31.jsx)(FormContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) Form.displayName = "Form";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/menubar/Menubar.js
var React87 = __toESM(require_react(), 1);
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var Menubar = React87.forwardRef(function Menubar2(props, forwardedRef) {
  const {
    orientation = "horizontal",
    loop = true,
    render,
    className,
    modal = true,
    disabled = false,
    id: idProp,
    ...elementProps
  } = props;
  const [contentElement, setContentElement] = React87.useState(null);
  const [hasSubmenuOpen, setHasSubmenuOpen] = React87.useState(false);
  const {
    openMethod,
    triggerProps: interactionTypeProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(hasSubmenuOpen);
  React87.useEffect(() => {
    if (!hasSubmenuOpen) {
      resetOpenInteractionType();
    }
  }, [hasSubmenuOpen, resetOpenInteractionType]);
  useScrollLock({
    enabled: modal && hasSubmenuOpen && openMethod !== "touch",
    open: hasSubmenuOpen,
    mounted: hasSubmenuOpen,
    referenceElement: contentElement
  });
  const id = useBaseUiId(idProp);
  const state = React87.useMemo(() => ({
    orientation,
    modal
  }), [orientation, modal]);
  const contentRef = React87.useRef(null);
  const allowMouseUpTriggerRef = React87.useRef(false);
  const context = React87.useMemo(() => ({
    contentElement,
    setContentElement,
    setHasSubmenuOpen,
    hasSubmenuOpen,
    modal,
    disabled,
    orientation,
    allowMouseUpTriggerRef,
    rootId: id
  }), [contentElement, hasSubmenuOpen, modal, disabled, orientation, id]);
  return (0, import_jsx_runtime32.jsx)(MenubarContext.Provider, {
    value: context,
    children: (0, import_jsx_runtime32.jsx)(FloatingTree, {
      children: (0, import_jsx_runtime32.jsx)(MenubarContent, {
        children: (0, import_jsx_runtime32.jsx)(CompositeRoot, {
          render,
          className,
          state,
          refs: [forwardedRef, setContentElement, contentRef],
          props: [{
            role: "menubar",
            id
          }, interactionTypeProps, elementProps],
          orientation,
          loop,
          highlightItemOnHover: hasSubmenuOpen
        })
      })
    })
  });
});
if (true) Menubar.displayName = "Menubar";
function MenubarContent(props) {
  const nodeId = useFloatingNodeId();
  const {
    events: menuEvents
  } = useFloatingTree();
  const openSubmenusRef = React87.useRef(/* @__PURE__ */ new Set());
  const rootContext = useMenubarContext();
  React87.useEffect(() => {
    function onSubmenuOpenChange(details) {
      if (!details.nodeId || details.parentNodeId !== nodeId) {
        return;
      }
      if (details.open) {
        openSubmenusRef.current.add(details.nodeId);
      } else {
        openSubmenusRef.current.delete(details.nodeId);
      }
      const isAnyOpen = openSubmenusRef.current.size > 0;
      if (isAnyOpen) {
        rootContext.setHasSubmenuOpen(true);
      } else if (rootContext.hasSubmenuOpen) {
        AnimationFrame.request(() => {
          if (openSubmenusRef.current.size === 0) {
            rootContext.setHasSubmenuOpen(false);
          }
        });
      }
    }
    menuEvents.on("menuopenchange", onSubmenuOpenChange);
    return () => {
      menuEvents.off("menuopenchange", onSubmenuOpenChange);
    };
  }, [menuEvents, nodeId, rootContext]);
  return (0, import_jsx_runtime32.jsx)(FloatingNode, {
    id: nodeId,
    children: props.children
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/index.parts.js
var index_parts_exports19 = {};
__export(index_parts_exports19, {
  Arrow: () => NavigationMenuArrow,
  Backdrop: () => NavigationMenuBackdrop,
  Content: () => NavigationMenuContent,
  Icon: () => NavigationMenuIcon,
  Item: () => NavigationMenuItem,
  Link: () => NavigationMenuLink,
  List: () => NavigationMenuList,
  Popup: () => NavigationMenuPopup,
  Portal: () => NavigationMenuPortal,
  Positioner: () => NavigationMenuPositioner,
  Root: () => NavigationMenuRoot,
  Trigger: () => NavigationMenuTrigger,
  Viewport: () => NavigationMenuViewport
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/root/NavigationMenuRoot.js
var React89 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/root/NavigationMenuRootContext.js
var React88 = __toESM(require_react(), 1);
var NavigationMenuRootContext = React88.createContext(void 0);
if (true) NavigationMenuRootContext.displayName = "NavigationMenuRootContext";
if (true) {
  NavigationMenuRootContext.displayName = "NavigationMenuRootContext";
}
function useNavigationMenuRootContext(optional) {
  const context = React88.useContext(NavigationMenuRootContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: NavigationMenuRootContext is missing. Navigation Menu parts must be placed within <NavigationMenu.Root>.");
  }
  return context;
}
var NavigationMenuTreeContext = React88.createContext(void 0);
if (true) NavigationMenuTreeContext.displayName = "NavigationMenuTreeContext";
function useNavigationMenuTreeContext() {
  return React88.useContext(NavigationMenuTreeContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/getCssDimensions.js
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/popup/NavigationMenuPopupCssVars.js
var NavigationMenuPopupCssVars = (function(NavigationMenuPopupCssVars2) {
  NavigationMenuPopupCssVars2["popupWidth"] = "--popup-width";
  NavigationMenuPopupCssVars2["popupHeight"] = "--popup-height";
  return NavigationMenuPopupCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/positioner/NavigationMenuPositionerCssVars.js
var NavigationMenuPositionerCssVars = (function(NavigationMenuPositionerCssVars2) {
  NavigationMenuPositionerCssVars2["availableWidth"] = "--available-width";
  NavigationMenuPositionerCssVars2["availableHeight"] = "--available-height";
  NavigationMenuPositionerCssVars2["anchorWidth"] = "--anchor-width";
  NavigationMenuPositionerCssVars2["anchorHeight"] = "--anchor-height";
  NavigationMenuPositionerCssVars2["transformOrigin"] = "--transform-origin";
  NavigationMenuPositionerCssVars2["positionerWidth"] = "--positioner-width";
  NavigationMenuPositionerCssVars2["positionerHeight"] = "--positioner-height";
  return NavigationMenuPositionerCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/utils/setFixedSize.js
function setFixedSize(element, type) {
  const {
    width,
    height
  } = getCssDimensions(element);
  element.style.setProperty(type === "popup" ? NavigationMenuPopupCssVars.popupWidth : NavigationMenuPositionerCssVars.positionerWidth, `${width}px`);
  element.style.setProperty(type === "popup" ? NavigationMenuPopupCssVars.popupHeight : NavigationMenuPositionerCssVars.positionerHeight, `${height}px`);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/root/NavigationMenuRoot.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var blockedReturnFocusReasons = /* @__PURE__ */ new Set(["trigger-hover", "outside-press", "focus-out"]);
var NavigationMenuRoot = React89.forwardRef(function NavigationMenuRoot2(componentProps, forwardedRef) {
  const {
    defaultValue = null,
    value: valueParam,
    onValueChange,
    actionsRef,
    delay = 50,
    closeDelay = 50,
    orientation = "horizontal",
    onOpenChangeComplete
  } = componentProps;
  const nested = useFloatingParentNodeId() != null;
  const [value, setValueUnwrapped] = useControlled({
    controlled: valueParam,
    default: defaultValue,
    name: "NavigationMenu",
    state: "value"
  });
  const open = value != null;
  const closeReasonRef = React89.useRef(void 0);
  const rootRef = React89.useRef(null);
  const [positionerElement, setPositionerElement] = React89.useState(null);
  const [popupElement, setPopupElement] = React89.useState(null);
  const [viewportElement, setViewportElement] = React89.useState(null);
  const [viewportTargetElement, setViewportTargetElement] = React89.useState(null);
  const [activationDirection, setActivationDirection] = React89.useState(null);
  const [floatingRootContext, setFloatingRootContext] = React89.useState(void 0);
  const [viewportInert, setViewportInert] = React89.useState(false);
  const prevTriggerElementRef = React89.useRef(null);
  const currentContentRef = React89.useRef(null);
  const beforeInsideRef = React89.useRef(null);
  const afterInsideRef = React89.useRef(null);
  const beforeOutsideRef = React89.useRef(null);
  const afterOutsideRef = React89.useRef(null);
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  React89.useEffect(() => {
    setViewportInert(false);
  }, [value]);
  const setValue = useEventCallback((nextValue, eventDetails) => {
    if (!nextValue) {
      closeReasonRef.current = eventDetails.reason;
      setActivationDirection(null);
      setFloatingRootContext(void 0);
      if (positionerElement && popupElement) {
        setFixedSize(popupElement, "popup");
        setFixedSize(positionerElement, "positioner");
      }
    }
    if (nextValue !== value) {
      onValueChange == null ? void 0 : onValueChange(nextValue, eventDetails);
    }
    if (eventDetails.isCanceled) {
      return;
    }
    setValueUnwrapped(nextValue);
  });
  const handleUnmount = useEventCallback(() => {
    const doc = ownerDocument(rootRef.current);
    const activeEl = activeElement(doc);
    const isReturnFocusBlocked = closeReasonRef.current ? blockedReturnFocusReasons.has(closeReasonRef.current) : false;
    if (!isReturnFocusBlocked && isHTMLElement(prevTriggerElementRef.current) && (activeEl === ownerDocument(popupElement).body || contains(popupElement, activeEl)) && popupElement) {
      prevTriggerElementRef.current.focus({
        preventScroll: true
      });
      prevTriggerElementRef.current = void 0;
    }
    setMounted(false);
    onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(false);
    setActivationDirection(null);
    setFloatingRootContext(void 0);
    currentContentRef.current = null;
    closeReasonRef.current = void 0;
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: {
      current: popupElement
    },
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: {
      current: viewportTargetElement
    },
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  const contextValue = React89.useMemo(() => ({
    open,
    value,
    setValue,
    mounted,
    transitionStatus,
    positionerElement,
    setPositionerElement,
    popupElement,
    setPopupElement,
    viewportElement,
    setViewportElement,
    viewportTargetElement,
    setViewportTargetElement,
    activationDirection,
    setActivationDirection,
    floatingRootContext,
    setFloatingRootContext,
    currentContentRef,
    nested,
    rootRef,
    beforeInsideRef,
    afterInsideRef,
    beforeOutsideRef,
    afterOutsideRef,
    prevTriggerElementRef,
    delay,
    closeDelay,
    orientation,
    viewportInert,
    setViewportInert
  }), [open, value, setValue, mounted, transitionStatus, positionerElement, popupElement, viewportElement, viewportTargetElement, activationDirection, floatingRootContext, nested, delay, closeDelay, orientation, viewportInert]);
  const jsx = (0, import_jsx_runtime33.jsx)(NavigationMenuRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime33.jsx)(TreeContext, {
      componentProps,
      forwardedRef,
      children: componentProps.children
    })
  });
  if (!nested) {
    return (0, import_jsx_runtime33.jsx)(FloatingTree, {
      children: jsx
    });
  }
  return jsx;
});
if (true) NavigationMenuRoot.displayName = "NavigationMenuRoot";
function TreeContext(props) {
  const {
    className,
    render,
    defaultValue,
    value: valueParam,
    onValueChange,
    actionsRef,
    delay,
    closeDelay,
    orientation,
    onOpenChangeComplete,
    ...elementProps
  } = props.componentProps;
  const nodeId = useFloatingNodeId();
  const {
    rootRef,
    nested
  } = useNavigationMenuRootContext();
  const {
    open
  } = useNavigationMenuRootContext();
  const state = React89.useMemo(() => ({
    open,
    nested
  }), [open, nested]);
  const element = useRenderElement(nested ? "div" : "nav", props.componentProps, {
    state,
    ref: [props.forwardedRef, rootRef],
    props: [{
      "aria-orientation": orientation
    }, elementProps]
  });
  return (0, import_jsx_runtime33.jsx)(NavigationMenuTreeContext.Provider, {
    value: nodeId,
    children: element
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/list/NavigationMenuList.js
var React90 = __toESM(require_react(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var NavigationMenuList = React90.forwardRef(function NavigationMenuList2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    orientation,
    open
  } = useNavigationMenuRootContext();
  const state = React90.useMemo(() => ({
    open
  }), [open]);
  const defaultProps = {
    // `stopEventPropagation` won't stop the propagation if the end of the list is reached,
    // but we want to block it in this case.
    onKeyDown(event) {
      const shouldStop = orientation === "horizontal" && (event.key === "ArrowLeft" || event.key === "ArrowRight") || orientation === "vertical" && (event.key === "ArrowUp" || event.key === "ArrowDown");
      if (shouldStop) {
        event.stopPropagation();
      }
    }
  };
  return (0, import_jsx_runtime34.jsx)(CompositeRoot, {
    render,
    className,
    state,
    refs: [forwardedRef],
    props: [defaultProps, elementProps],
    loop: false,
    orientation,
    tag: "ul"
  });
});
if (true) NavigationMenuList.displayName = "NavigationMenuList";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/item/NavigationMenuItem.js
var React92 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/item/NavigationMenuItemContext.js
var React91 = __toESM(require_react(), 1);
var NavigationMenuItemContext = React91.createContext(void 0);
if (true) NavigationMenuItemContext.displayName = "NavigationMenuItemContext";
function useNavigationMenuItemContext() {
  const value = React91.useContext(NavigationMenuItemContext);
  if (value === void 0) {
    throw new Error("Base UI: NavigationMenuItem parts must be used within a <NavigationMenu.Item>.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/item/NavigationMenuItem.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var NavigationMenuItem = React92.forwardRef(function NavigationMenuItem2(componentProps, forwardedRef) {
  const {
    className,
    render,
    value: valueProp,
    ...elementProps
  } = componentProps;
  const fallbackValue = useBaseUiId();
  const value = valueProp ?? fallbackValue;
  const element = useRenderElement("li", componentProps, {
    ref: forwardedRef,
    props: elementProps
  });
  return (0, import_jsx_runtime35.jsx)(NavigationMenuItemContext.Provider, {
    value,
    children: element
  });
});
if (true) NavigationMenuItem.displayName = "NavigationMenuItem";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/content/NavigationMenuContent.js
var React93 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping11 = {
  ...popupStateMapping,
  ...transitionStatusMapping,
  activationDirection(value) {
    if (!value) {
      return null;
    }
    return {
      "data-activation-direction": value
    };
  }
};
var NavigationMenuContent = React93.forwardRef(function NavigationMenuContent2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    mounted: popupMounted,
    viewportElement,
    value,
    activationDirection,
    currentContentRef,
    viewportTargetElement
  } = useNavigationMenuRootContext();
  const itemValue = useNavigationMenuItemContext();
  const nodeId = useNavigationMenuTreeContext();
  const open = popupMounted && value === itemValue;
  const ref = React93.useRef(null);
  const [focusInside, setFocusInside] = React93.useState(false);
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  useOpenChangeComplete({
    ref,
    open,
    onComplete() {
      if (!open) {
        setMounted(false);
      }
    }
  });
  const state = React93.useMemo(() => ({
    open,
    transitionStatus,
    activationDirection
  }), [open, transitionStatus, activationDirection]);
  const handleCurrentContentRef = React93.useCallback((node) => {
    if (node) {
      currentContentRef.current = node;
    }
  }, [currentContentRef]);
  const commonProps = {
    onFocus() {
      setFocusInside(true);
    },
    onBlur(event) {
      if (!contains(event.currentTarget, event.relatedTarget)) {
        setFocusInside(false);
      }
    }
  };
  const defaultProps = !open && mounted ? {
    style: {
      position: "absolute",
      top: 0,
      left: 0
    },
    inert: inertValue(!focusInside),
    ...commonProps
  } : commonProps;
  const portalContainer = viewportTargetElement || viewportElement;
  const shouldRender = portalContainer !== null && mounted;
  if (!portalContainer || !shouldRender) {
    return null;
  }
  return ReactDOM3.createPortal((0, import_jsx_runtime36.jsx)(FloatingNode, {
    id: nodeId,
    children: (0, import_jsx_runtime36.jsx)(CompositeRoot, {
      render,
      className,
      state,
      refs: [forwardedRef, ref, handleCurrentContentRef],
      props: [defaultProps, elementProps],
      stateAttributesMapping: stateAttributesMapping11
    })
  }), portalContainer);
});
if (true) NavigationMenuContent.displayName = "NavigationMenuContent";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/trigger/NavigationMenuTrigger.js
var React94 = __toESM(require_react(), 1);
var ReactDOM4 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/utils/isOutsideMenuEvent.js
function isOutsideMenuEvent({
  currentTarget,
  relatedTarget
}, params) {
  const {
    popupElement,
    viewportElement,
    rootRef,
    tree,
    nodeId
  } = params;
  const nodeChildrenContains = tree ? getNodeChildren(tree.nodesRef.current, nodeId).some((node) => {
    var _a;
    return contains((_a = node.context) == null ? void 0 : _a.elements.floating, relatedTarget);
  }) : [];
  if (!popupElement) {
    return !contains(rootRef.current, relatedTarget) && !nodeChildrenContains;
  }
  const floatingElement = popupElement || viewportElement;
  return !contains(floatingElement, currentTarget) && !contains(floatingElement, relatedTarget) && !contains(rootRef.current, relatedTarget) && !nodeChildrenContains && !(contains(floatingElement, relatedTarget) && (relatedTarget == null ? void 0 : relatedTarget.hasAttribute("data-base-ui-focus-guard")));
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/trigger/NavigationMenuTrigger.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var TRIGGER_IDENTIFIER = "data-base-ui-navigation-menu-trigger";
var DEFAULT_SIZE = {
  width: 0,
  height: 0
};
var NavigationMenuTrigger = React94.forwardRef(function NavigationMenuTrigger2(componentProps, forwardedRef) {
  const {
    className,
    render,
    nativeButton = true,
    disabled,
    ...elementProps
  } = componentProps;
  const {
    value,
    setValue,
    mounted,
    open,
    positionerElement,
    setActivationDirection,
    setFloatingRootContext,
    popupElement,
    viewportElement,
    rootRef,
    beforeOutsideRef,
    afterOutsideRef,
    afterInsideRef,
    beforeInsideRef,
    prevTriggerElementRef,
    delay,
    closeDelay,
    orientation,
    setViewportInert
  } = useNavigationMenuRootContext();
  const itemValue = useNavigationMenuItemContext();
  const nodeId = useNavigationMenuTreeContext();
  const tree = useFloatingTree();
  const stickIfOpenTimeout = useTimeout();
  const focusFrame = useAnimationFrame();
  const sizeFrame1 = useAnimationFrame();
  const sizeFrame2 = useAnimationFrame();
  const [triggerElement, setTriggerElement] = React94.useState(null);
  const [stickIfOpen, setStickIfOpen] = React94.useState(true);
  const [pointerType, setPointerType] = React94.useState("");
  const allowFocusRef = React94.useRef(false);
  const prevSizeRef = React94.useRef(DEFAULT_SIZE);
  const animationAbortControllerRef = React94.useRef(null);
  const isActiveItem = open && value === itemValue;
  const isActiveItemRef = useLatestRef(isActiveItem);
  const interactionsEnabled = positionerElement ? true : !value;
  const runOnceAnimationsFinish = useAnimationsFinished(popupElement);
  React94.useEffect(() => {
    var _a;
    (_a = animationAbortControllerRef.current) == null ? void 0 : _a.abort();
  }, [isActiveItem]);
  const setAutoSizes = useEventCallback(() => {
    if (!popupElement) {
      return;
    }
    popupElement.style.setProperty(NavigationMenuPopupCssVars.popupWidth, "auto");
    popupElement.style.setProperty(NavigationMenuPopupCssVars.popupHeight, "auto");
  });
  const handleValueChange = useEventCallback((currentWidth, currentHeight) => {
    if (!popupElement || !positionerElement) {
      return;
    }
    popupElement.style.removeProperty(NavigationMenuPopupCssVars.popupWidth);
    popupElement.style.removeProperty(NavigationMenuPopupCssVars.popupHeight);
    positionerElement.style.removeProperty(NavigationMenuPositionerCssVars.positionerWidth);
    positionerElement.style.removeProperty(NavigationMenuPositionerCssVars.positionerHeight);
    const {
      width,
      height
    } = getCssDimensions(popupElement);
    if (currentHeight === 0 || currentWidth === 0) {
      currentWidth = width;
      currentHeight = height;
    }
    popupElement.style.setProperty(NavigationMenuPopupCssVars.popupWidth, `${currentWidth}px`);
    popupElement.style.setProperty(NavigationMenuPopupCssVars.popupHeight, `${currentHeight}px`);
    positionerElement.style.setProperty(NavigationMenuPositionerCssVars.positionerWidth, `${width}px`);
    positionerElement.style.setProperty(NavigationMenuPositionerCssVars.positionerHeight, `${height}px`);
    sizeFrame1.request(() => {
      popupElement.style.setProperty(NavigationMenuPopupCssVars.popupWidth, `${width}px`);
      popupElement.style.setProperty(NavigationMenuPopupCssVars.popupHeight, `${height}px`);
      sizeFrame2.request(() => {
        animationAbortControllerRef.current = new AbortController();
        runOnceAnimationsFinish(setAutoSizes, animationAbortControllerRef.current.signal);
      });
    });
  });
  React94.useEffect(() => {
    if (!open) {
      stickIfOpenTimeout.clear();
      sizeFrame1.cancel();
      sizeFrame2.cancel();
      prevSizeRef.current = DEFAULT_SIZE;
    }
  }, [stickIfOpenTimeout, open, sizeFrame1, sizeFrame2]);
  React94.useEffect(() => {
    if (!popupElement || typeof ResizeObserver !== "function") {
      return void 0;
    }
    const resizeObserver = new ResizeObserver(() => {
      prevSizeRef.current = {
        width: popupElement.offsetWidth,
        height: popupElement.offsetHeight
      };
    });
    resizeObserver.observe(popupElement);
    return () => {
      resizeObserver.disconnect();
    };
  }, [popupElement]);
  React94.useEffect(() => {
    if (!popupElement || !isActiveItem || typeof MutationObserver !== "function") {
      return void 0;
    }
    const mutationObserver = new MutationObserver(() => {
      var _a;
      (_a = animationAbortControllerRef.current) == null ? void 0 : _a.abort();
      handleValueChange(prevSizeRef.current.width, prevSizeRef.current.height);
    });
    mutationObserver.observe(popupElement, {
      childList: true,
      subtree: true,
      characterData: true
    });
    return () => {
      mutationObserver.disconnect();
    };
  }, [popupElement, positionerElement, isActiveItem, handleValueChange, setAutoSizes]);
  React94.useEffect(() => {
    if (isActiveItem && open && popupElement && allowFocusRef.current) {
      allowFocusRef.current = false;
      focusFrame.request(() => {
        var _a;
        (_a = beforeOutsideRef.current) == null ? void 0 : _a.focus();
      });
    }
    return () => {
      focusFrame.cancel();
    };
  }, [beforeOutsideRef, focusFrame, handleValueChange, isActiveItem, open, popupElement]);
  useIsoLayoutEffect(() => {
    if (isActiveItemRef.current && open && popupElement) {
      handleValueChange(0, 0);
    }
  }, [isActiveItemRef, open, popupElement, handleValueChange]);
  function handleOpenChange(nextOpen, eventDetails) {
    const isHover = eventDetails.reason === "trigger-hover";
    if (!interactionsEnabled) {
      return;
    }
    if (pointerType === "touch" && isHover) {
      return;
    }
    if (!nextOpen && value !== itemValue) {
      return;
    }
    function changeState() {
      if (isHover) {
        setStickIfOpen(true);
        stickIfOpenTimeout.clear();
        stickIfOpenTimeout.start(PATIENT_CLICK_THRESHOLD, () => {
          setStickIfOpen(false);
        });
      }
      if (nextOpen) {
        setValue(itemValue, eventDetails);
      } else {
        setValue(null, eventDetails);
        setPointerType("");
      }
    }
    if (isHover) {
      ReactDOM4.flushSync(changeState);
    } else {
      changeState();
    }
  }
  const context = useFloatingRootContext({
    open,
    onOpenChange: handleOpenChange,
    elements: {
      reference: triggerElement,
      floating: positionerElement || viewportElement
    }
  });
  const hover = useHover(context, {
    move: false,
    handleClose: safePolygon({
      blockPointerEvents: pointerType !== "touch"
    }),
    restMs: mounted && positionerElement ? 0 : delay,
    delay: {
      close: closeDelay
    }
  });
  const click = useClick(context, {
    enabled: interactionsEnabled,
    stickIfOpen,
    toggle: isActiveItem
  });
  const dismiss = useDismiss(context, {
    enabled: isActiveItem && interactionsEnabled,
    outsidePress(event) {
      const target = getTarget(event);
      const closestNavigationMenuTrigger = target == null ? void 0 : target.closest(`[${TRIGGER_IDENTIFIER}]`);
      return closestNavigationMenuTrigger === null;
    }
  });
  useIsoLayoutEffect(() => {
    if (isActiveItem) {
      setFloatingRootContext(context);
      prevTriggerElementRef.current = triggerElement;
    }
  }, [isActiveItem, context, setFloatingRootContext, prevTriggerElementRef, triggerElement]);
  const {
    getReferenceProps
  } = useInteractions([hover, click, dismiss]);
  function handleActivation(event) {
    ReactDOM4.flushSync(() => {
      var _a;
      const prevTriggerRect = (_a = prevTriggerElementRef.current) == null ? void 0 : _a.getBoundingClientRect();
      if (mounted && prevTriggerRect && triggerElement) {
        const nextTriggerRect = triggerElement.getBoundingClientRect();
        const isMovingRight = nextTriggerRect.left > prevTriggerRect.left;
        const isMovingDown = nextTriggerRect.top > prevTriggerRect.top;
        if (orientation === "horizontal" && nextTriggerRect.left !== prevTriggerRect.left) {
          setActivationDirection(isMovingRight ? "right" : "left");
        } else if (orientation === "vertical" && nextTriggerRect.top !== prevTriggerRect.top) {
          setActivationDirection(isMovingDown ? "down" : "up");
        }
      }
      if (event.type !== "click") {
        context.dataRef.current.openEvent = void 0;
      }
      if (pointerType === "touch" && event.type !== "click") {
        return;
      }
      if (value != null) {
        setValue(itemValue, createChangeEventDetails(event.type === "mouseenter" ? "trigger-hover" : "trigger-press", event.nativeEvent));
      }
    });
  }
  const handleOpenEvent = useEventCallback((event) => {
    if (!popupElement || !positionerElement) {
      handleActivation(event);
      return;
    }
    const {
      width,
      height
    } = getCssDimensions(popupElement);
    handleActivation(event);
    handleValueChange(width, height);
  });
  const state = React94.useMemo(() => ({
    open: isActiveItem
  }), [isActiveItem]);
  function handleSetPointerType(event) {
    setPointerType(event.pointerType);
  }
  const defaultProps = {
    tabIndex: 0,
    onMouseEnter: handleOpenEvent,
    onClick: handleOpenEvent,
    onPointerEnter: handleSetPointerType,
    onPointerDown: handleSetPointerType,
    "aria-expanded": isActiveItem,
    "aria-controls": isActiveItem ? popupElement == null ? void 0 : popupElement.id : void 0,
    [TRIGGER_IDENTIFIER]: "",
    onFocus() {
      if (!isActiveItem) {
        return;
      }
      setViewportInert(false);
    },
    onMouseMove() {
      allowFocusRef.current = false;
    },
    onKeyDown(event) {
      allowFocusRef.current = true;
      const openHorizontal = orientation === "horizontal" && event.key === "ArrowDown";
      const openVertical = orientation === "vertical" && event.key === "ArrowRight";
      if (openHorizontal || openVertical) {
        setValue(itemValue, createChangeEventDetails("list-navigation", event.nativeEvent));
        handleOpenEvent(event);
        stopEvent(event);
      }
    },
    onBlur(event) {
      if (positionerElement && popupElement && isOutsideMenuEvent({
        currentTarget: event.currentTarget,
        relatedTarget: event.relatedTarget
      }, {
        popupElement,
        rootRef,
        tree,
        nodeId
      })) {
        setValue(null, createChangeEventDetails("focus-out", event.nativeEvent));
      }
    }
  };
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    native: nativeButton
  });
  const referenceElement = positionerElement || viewportElement;
  return (0, import_jsx_runtime37.jsxs)(React94.Fragment, {
    children: [(0, import_jsx_runtime37.jsx)(CompositeItem, {
      tag: "button",
      render,
      className,
      state,
      stateAttributesMapping: pressableTriggerOpenStateMapping,
      refs: [forwardedRef, setTriggerElement, buttonRef],
      props: [getReferenceProps, defaultProps, elementProps, getButtonProps]
    }), isActiveItem && (0, import_jsx_runtime37.jsxs)(React94.Fragment, {
      children: [(0, import_jsx_runtime37.jsx)(FocusGuard, {
        ref: beforeOutsideRef,
        onFocus: (event) => {
          var _a;
          if (referenceElement && isOutsideEvent(event, referenceElement)) {
            (_a = beforeInsideRef.current) == null ? void 0 : _a.focus();
          } else {
            const prevTabbable = getPreviousTabbable(triggerElement);
            prevTabbable == null ? void 0 : prevTabbable.focus();
          }
        }
      }), (0, import_jsx_runtime37.jsx)("span", {
        "aria-owns": viewportElement == null ? void 0 : viewportElement.id,
        style: visuallyHidden
      }), (0, import_jsx_runtime37.jsx)(FocusGuard, {
        ref: afterOutsideRef,
        onFocus: (event) => {
          if (referenceElement && isOutsideEvent(event, referenceElement)) {
            const elementToFocus = afterInsideRef.current && isTabbable(afterInsideRef.current) ? afterInsideRef.current : triggerElement;
            elementToFocus == null ? void 0 : elementToFocus.focus();
          } else {
            const nextTabbable = getNextTabbable(triggerElement);
            nextTabbable == null ? void 0 : nextTabbable.focus();
            if (!contains(rootRef.current, nextTabbable)) {
              setValue(null, createChangeEventDetails("focus-out", event.nativeEvent));
            }
          }
        }
      })]
    })]
  });
});
if (true) NavigationMenuTrigger.displayName = "NavigationMenuTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/portal/NavigationMenuPortal.js
var React96 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/portal/NavigationMenuPortalContext.js
var React95 = __toESM(require_react(), 1);
var NavigationMenuPortalContext = React95.createContext(void 0);
if (true) NavigationMenuPortalContext.displayName = "NavigationMenuPortalContext";
function useNavigationMenuPortalContext() {
  const value = React95.useContext(NavigationMenuPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <NavigationMenu.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/portal/NavigationMenuPortal.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
function NavigationMenuPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    mounted
  } = useNavigationMenuRootContext();
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime38.jsx)(NavigationMenuPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime38.jsx)(FloatingPortal, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/positioner/NavigationMenuPositioner.js
var React98 = __toESM(require_react(), 1);
var ReactDOM5 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/positioner/NavigationMenuPositionerContext.js
var React97 = __toESM(require_react(), 1);
var NavigationMenuPositionerContext = React97.createContext(void 0);
if (true) NavigationMenuPositionerContext.displayName = "NavigationMenuPositionerContext";
function useNavigationMenuPositionerContext(optional = false) {
  const context = React97.useContext(NavigationMenuPositionerContext);
  if (!context && !optional) {
    throw new Error("Base UI: NavigationMenuPositionerContext is missing. NavigationMenuPositioner parts must be placed within <NavigationMenu.Positioner>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/positioner/NavigationMenuPositioner.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var adaptiveOrigin = {
  name: "adaptiveOrigin",
  async fn(state) {
    var _a, _b;
    const {
      x: rawX,
      y: rawY,
      rects: {
        floating: floatRect
      },
      elements: {
        floating
      },
      platform,
      strategy,
      placement
    } = state;
    const win = floating.ownerDocument.defaultView;
    const offsetParent = await ((_a = platform.getOffsetParent) == null ? void 0 : _a.call(platform, floating));
    let offsetDimensions = {
      width: 0,
      height: 0
    };
    if (strategy === "fixed" && (win == null ? void 0 : win.visualViewport)) {
      offsetDimensions = {
        width: win.visualViewport.width,
        height: win.visualViewport.height
      };
    } else if (offsetParent === win) {
      const doc = ownerDocument(floating);
      offsetDimensions = {
        width: doc.documentElement.clientWidth,
        height: doc.documentElement.clientHeight
      };
    } else if (await ((_b = platform.isElement) == null ? void 0 : _b.call(platform, offsetParent))) {
      offsetDimensions = await platform.getDimensions(offsetParent);
    }
    const currentSide = getSide(placement);
    let x = rawX;
    let y = rawY;
    if (currentSide === "left") {
      x = offsetDimensions.width - (rawX + floatRect.width);
    }
    if (currentSide === "top") {
      y = offsetDimensions.height - (rawY + floatRect.height);
    }
    const sideX = currentSide === "left" ? "right" : "left";
    const sideY = currentSide === "top" ? "bottom" : "top";
    return {
      x,
      y,
      data: {
        sideX,
        sideY
      }
    };
  }
};
var NavigationMenuPositioner = React98.forwardRef(function NavigationMenuPositioner2(componentProps, forwardedRef) {
  const {
    open,
    mounted,
    positionerElement,
    setPositionerElement,
    floatingRootContext,
    nested
  } = useNavigationMenuRootContext();
  const {
    className,
    render,
    anchor,
    positionMethod = "absolute",
    side = "bottom",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    collisionAvoidance = nested ? POPUP_COLLISION_AVOIDANCE : DROPDOWN_COLLISION_AVOIDANCE,
    arrowPadding = 5,
    sticky = false,
    trackAnchor = true,
    ...elementProps
  } = componentProps;
  const keepMounted = useNavigationMenuPortalContext();
  const nodeId = useNavigationMenuTreeContext();
  const resizeTimeout = useTimeout();
  const [instant, setInstant] = React98.useState(false);
  const positionerRef = React98.useRef(null);
  const prevTriggerElementRef = React98.useRef(null);
  React98.useEffect(() => {
    if (!positionerElement) {
      return void 0;
    }
    function onFocus(event) {
      if (positionerElement && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(positionerElement);
      }
    }
    positionerElement.addEventListener("focusin", onFocus, true);
    positionerElement.addEventListener("focusout", onFocus, true);
    return () => {
      positionerElement.removeEventListener("focusin", onFocus, true);
      positionerElement.removeEventListener("focusout", onFocus, true);
    };
  }, [positionerElement]);
  const positioning = useAnchorPositioning({
    anchor: anchor ?? (floatingRootContext == null ? void 0 : floatingRootContext.elements.domReference) ?? prevTriggerElementRef,
    positionMethod,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    trackAnchor,
    keepMounted,
    floatingRootContext,
    collisionAvoidance,
    nodeId,
    // Allows the menu to remain anchored without wobbling while its size
    // and position transition simultaneously when side=top or side=left.
    adaptiveOrigin
  });
  const defaultProps = React98.useMemo(() => {
    const hiddenStyles = {};
    if (!open) {
      hiddenStyles.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioning.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, mounted, positioning.positionerStyles]);
  const state = React98.useMemo(() => ({
    open,
    side: positioning.side,
    align: positioning.align,
    anchorHidden: positioning.anchorHidden,
    instant
  }), [open, positioning.side, positioning.align, positioning.anchorHidden, instant]);
  React98.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleResize() {
      ReactDOM5.flushSync(() => {
        setInstant(true);
      });
      resizeTimeout.start(100, () => {
        setInstant(false);
      });
    }
    const win = getWindow(positionerElement);
    win.addEventListener("resize", handleResize);
    return () => {
      win.removeEventListener("resize", handleResize);
    };
  }, [open, resizeTimeout, positionerElement]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, setPositionerElement, positionerRef],
    props: [defaultProps, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return (0, import_jsx_runtime39.jsx)(NavigationMenuPositionerContext.Provider, {
    value: positioning,
    children: element
  });
});
if (true) NavigationMenuPositioner.displayName = "NavigationMenuPositioner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/viewport/NavigationMenuViewport.js
var React99 = __toESM(require_react(), 1);
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
function Guards({
  children
}) {
  const {
    beforeInsideRef,
    beforeOutsideRef,
    afterInsideRef,
    afterOutsideRef,
    positionerElement,
    viewportElement,
    floatingRootContext
  } = useNavigationMenuRootContext();
  const hasPositioner = Boolean(useNavigationMenuPositionerContext(true));
  const referenceElement = positionerElement || viewportElement;
  if (!floatingRootContext && !hasPositioner) {
    return children;
  }
  return (0, import_jsx_runtime40.jsxs)(React99.Fragment, {
    children: [(0, import_jsx_runtime40.jsx)(FocusGuard, {
      ref: beforeInsideRef,
      onFocus: (event) => {
        var _a, _b;
        if (referenceElement && isOutsideEvent(event, referenceElement)) {
          (_a = getNextTabbable(referenceElement)) == null ? void 0 : _a.focus();
        } else {
          (_b = beforeOutsideRef.current) == null ? void 0 : _b.focus();
        }
      }
    }), children, (0, import_jsx_runtime40.jsx)(FocusGuard, {
      ref: afterInsideRef,
      onFocus: (event) => {
        var _a, _b;
        if (referenceElement && isOutsideEvent(event, referenceElement)) {
          (_a = getPreviousTabbable(referenceElement)) == null ? void 0 : _a.focus();
        } else {
          (_b = afterOutsideRef.current) == null ? void 0 : _b.focus();
        }
      }
    })]
  });
}
var NavigationMenuViewport = React99.forwardRef(function NavigationMenuViewport2(componentProps, forwardedRef) {
  const {
    className,
    render,
    children,
    id: idProp,
    ...elementProps
  } = componentProps;
  const id = useId(idProp);
  const {
    setViewportElement,
    setViewportTargetElement,
    floatingRootContext,
    prevTriggerElementRef,
    viewportInert,
    setViewportInert
  } = useNavigationMenuRootContext();
  const hasPositioner = Boolean(useNavigationMenuPositionerContext(true));
  const domReference = floatingRootContext == null ? void 0 : floatingRootContext.elements.domReference;
  useIsoLayoutEffect(() => {
    if (domReference) {
      prevTriggerElementRef.current = domReference;
    }
  }, [domReference, prevTriggerElementRef]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, setViewportElement],
    props: [{
      id,
      onBlur(event) {
        const relatedTarget = event.relatedTarget;
        const currentTarget = event.currentTarget;
        if (relatedTarget && !contains(currentTarget, relatedTarget) && relatedTarget !== domReference) {
          setViewportInert(true);
        }
      },
      ...!hasPositioner && viewportInert && {
        inert: inertValue(true)
      },
      children: hasPositioner ? children : (0, import_jsx_runtime40.jsx)(Guards, {
        children: (0, import_jsx_runtime40.jsx)("div", {
          ref: setViewportTargetElement,
          children
        })
      })
    }, elementProps]
  });
  return hasPositioner ? (0, import_jsx_runtime40.jsx)(Guards, {
    children: element
  }) : element;
});
if (true) NavigationMenuViewport.displayName = "NavigationMenuViewport";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/backdrop/NavigationMenuBackdrop.js
var React100 = __toESM(require_react(), 1);
var stateAttributesMapping12 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var NavigationMenuBackdrop = React100.forwardRef(function NavigationMenuBackdrop2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open,
    mounted,
    transitionStatus
  } = useNavigationMenuRootContext();
  const state = React100.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps],
    stateAttributesMapping: stateAttributesMapping12
  });
  return element;
});
if (true) NavigationMenuBackdrop.displayName = "NavigationMenuBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/popup/NavigationMenuPopup.js
var React101 = __toESM(require_react(), 1);
var stateAttributesMapping13 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var NavigationMenuPopup = React101.forwardRef(function NavigationMenuPopup2(componentProps, forwardedRef) {
  const {
    className,
    render,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    open,
    transitionStatus,
    setPopupElement
  } = useNavigationMenuRootContext();
  const positioning = useNavigationMenuPositionerContext();
  const direction = useDirection();
  const id = useBaseUiId(idProp);
  const state = React101.useMemo(() => ({
    open,
    transitionStatus,
    side: positioning.side,
    align: positioning.align,
    anchorHidden: positioning.anchorHidden
  }), [open, transitionStatus, positioning.side, positioning.align, positioning.anchorHidden]);
  let isOriginSide = positioning.side === "top";
  let isPhysicalLeft = positioning.side === "left";
  if (direction === "rtl") {
    isOriginSide = isOriginSide || positioning.side === "inline-end";
    isPhysicalLeft = isPhysicalLeft || positioning.side === "inline-end";
  } else {
    isOriginSide = isOriginSide || positioning.side === "inline-start";
    isPhysicalLeft = isPhysicalLeft || positioning.side === "inline-start";
  }
  const element = useRenderElement("nav", componentProps, {
    state,
    ref: [forwardedRef, setPopupElement],
    props: [{
      id,
      tabIndex: -1,
      style: isOriginSide ? {
        position: "absolute",
        [positioning.side === "top" ? "bottom" : "top"]: "0",
        [isPhysicalLeft ? "right" : "left"]: "0"
      } : {}
    }, elementProps],
    stateAttributesMapping: stateAttributesMapping13
  });
  return element;
});
if (true) NavigationMenuPopup.displayName = "NavigationMenuPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/arrow/NavigationMenuArrow.js
var React102 = __toESM(require_react(), 1);
var NavigationMenuArrow = React102.forwardRef(function NavigationMenuArrow2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open
  } = useNavigationMenuRootContext();
  const {
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = useNavigationMenuPositionerContext();
  const state = React102.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, arrowRef],
    props: [{
      style: arrowStyles,
      "aria-hidden": true
    }, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return element;
});
if (true) NavigationMenuArrow.displayName = "NavigationMenuArrow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/link/NavigationMenuLink.js
var React103 = __toESM(require_react(), 1);
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var NavigationMenuLink = React103.forwardRef(function NavigationMenuLink2(componentProps, forwardedRef) {
  const {
    className,
    render,
    active = false,
    closeOnClick = false,
    ...elementProps
  } = componentProps;
  const {
    setValue,
    popupElement,
    positionerElement,
    rootRef
  } = useNavigationMenuRootContext();
  const nodeId = useNavigationMenuTreeContext();
  const tree = useFloatingTree();
  const state = React103.useMemo(() => ({
    active
  }), [active]);
  const defaultProps = {
    "aria-current": active ? "page" : void 0,
    tabIndex: void 0,
    onClick(event) {
      if (closeOnClick) {
        setValue(null, createChangeEventDetails("link-press", event.nativeEvent));
      }
    },
    onBlur(event) {
      if (positionerElement && popupElement && isOutsideMenuEvent({
        currentTarget: event.currentTarget,
        relatedTarget: event.relatedTarget
      }, {
        popupElement,
        rootRef,
        tree,
        nodeId
      })) {
        setValue(null, createChangeEventDetails("focus-out", event.nativeEvent));
      }
    }
  };
  return (0, import_jsx_runtime41.jsx)(CompositeItem, {
    tag: "a",
    render,
    className,
    state,
    refs: [forwardedRef],
    props: [defaultProps, elementProps]
  });
});
if (true) NavigationMenuLink.displayName = "NavigationMenuLink";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/navigation-menu/icon/NavigationMenuIcon.js
var React104 = __toESM(require_react(), 1);
var NavigationMenuIcon = React104.forwardRef(function NavigationMenuIcon2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const itemValue = useNavigationMenuItemContext();
  const {
    open,
    value
  } = useNavigationMenuRootContext();
  const isActiveItem = open && value === itemValue;
  const state = React104.useMemo(() => ({
    open: isActiveItem
  }), [isActiveItem]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      "aria-hidden": true,
      children: ""
    }, elementProps],
    stateAttributesMapping: triggerOpenStateMapping
  });
  return element;
});
if (true) NavigationMenuIcon.displayName = "NavigationMenuIcon";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/index.parts.js
var index_parts_exports20 = {};
__export(index_parts_exports20, {
  Decrement: () => NumberFieldDecrement,
  Group: () => NumberFieldGroup,
  Increment: () => NumberFieldIncrement,
  Input: () => NumberFieldInput,
  Root: () => NumberFieldRoot,
  ScrubArea: () => NumberFieldScrubArea,
  ScrubAreaCursor: () => NumberFieldScrubAreaCursor
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/root/NumberFieldRoot.js
var React106 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+utils@0.1.2_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/utils/esm/useInterval.js
var EMPTY4 = 0;
var Interval = class _Interval extends Timeout {
  constructor() {
    super(...arguments);
    __publicField(this, "clear", () => {
      if (this.currentId !== EMPTY4) {
        clearInterval(this.currentId);
        this.currentId = EMPTY4;
      }
    });
  }
  static create() {
    return new _Interval();
  }
  /**
   * Executes `fn` at `delay` interval, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setInterval(() => {
      fn();
    }, delay);
  }
};
function useInterval() {
  const timeout = useRefWithInit(Interval.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/root/NumberFieldRootContext.js
var React105 = __toESM(require_react(), 1);
var NumberFieldRootContext = React105.createContext(void 0);
if (true) NumberFieldRootContext.displayName = "NumberFieldRootContext";
function useNumberFieldRootContext() {
  const context = React105.useContext(NumberFieldRootContext);
  if (context === void 0) {
    throw new Error("Base UI: NumberFieldRootContext is missing. NumberField parts must be placed within <NumberField.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/utils/stateAttributesMapping.js
var stateAttributesMapping14 = {
  inputValue: () => null,
  value: () => null
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/utils/parse.js
var HAN_NUMERALS = ["", "", "", "", "", "", "", "", "", "", ""];
var HAN_NUMERAL_TO_DIGIT = {
  : "0",
  "": "0",
  : "1",
  : "2",
  : "3",
  : "4",
  : "5",
  : "6",
  : "7",
  : "8",
  : "9"
};
var ARABIC_NUMERALS = ["", "", "", "", "", "", "", "", "", ""];
var PERSIAN_NUMERALS = ["", "", "", "", "", "", "", "", "", ""];
var FULLWIDTH_NUMERALS = ["", "", "", "", "", "", "", "", "", ""];
var PERCENTAGES = ["%", "", "", ""];
var PERMILLE = ["", ""];
var UNICODE_MINUS_SIGNS = ["", "", "", "", "", ""];
var UNICODE_PLUS_SIGNS = ["", ""];
var FULLWIDTH_DECIMAL = "";
var FULLWIDTH_GROUP = "";
var ARABIC_RE = new RegExp(`[${ARABIC_NUMERALS.join("")}]`, "g");
var PERSIAN_RE = new RegExp(`[${PERSIAN_NUMERALS.join("")}]`, "g");
var FULLWIDTH_RE = new RegExp(`[${FULLWIDTH_NUMERALS.join("")}]`, "g");
var HAN_RE = new RegExp(`[${HAN_NUMERALS.join("")}]`, "g");
var PERCENT_RE = new RegExp(`[${PERCENTAGES.join("")}]`);
var PERMILLE_RE = new RegExp(`[${PERMILLE.join("")}]`);
var ARABIC_DETECT_RE = /[]/;
var PERSIAN_DETECT_RE = /[]/;
var HAN_DETECT_RE = /[]/;
var FULLWIDTH_DETECT_RE = new RegExp(`[${FULLWIDTH_NUMERALS.join("")}]`);
var BASE_NON_NUMERIC_SYMBOLS = [".", ",", FULLWIDTH_DECIMAL, FULLWIDTH_GROUP, "", ""];
var SPACE_SEPARATOR_RE = new RegExp("\\p{Zs}", "u");
var PLUS_SIGNS_WITH_ASCII = ["+", ...UNICODE_PLUS_SIGNS];
var MINUS_SIGNS_WITH_ASCII = ["-", ...UNICODE_MINUS_SIGNS];
var escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeClassChar = (s) => s.replace(/[-\\\]^]/g, (m) => `\\${m}`);
var charClassFrom = (chars) => `[${chars.map(escapeClassChar).join("")}]`;
var ANY_MINUS_CLASS = charClassFrom(["-"].concat(UNICODE_MINUS_SIGNS));
var ANY_PLUS_CLASS = charClassFrom(["+"].concat(UNICODE_PLUS_SIGNS));
var ANY_MINUS_RE = new RegExp(ANY_MINUS_CLASS, "gu");
var ANY_PLUS_RE = new RegExp(ANY_PLUS_CLASS, "gu");
var ANY_MINUS_DETECT_RE = new RegExp(ANY_MINUS_CLASS);
var ANY_PLUS_DETECT_RE = new RegExp(ANY_PLUS_CLASS);
function getNumberLocaleDetails(locale, options) {
  const parts = getFormatter(locale, options).formatToParts(11111.1);
  const result = {};
  parts.forEach((part) => {
    result[part.type] = part.value;
  });
  getFormatter(locale).formatToParts(0.1).forEach((part) => {
    if (part.type === "decimal") {
      result[part.type] = part.value;
    }
  });
  return result;
}
function parseNumber(formattedNumber, locale, options) {
  if (formattedNumber == null) {
    return null;
  }
  let input = String(formattedNumber).replace(new RegExp("\\p{Cf}", "gu"), "").trim();
  input = input.replace(ANY_MINUS_RE, "-").replace(ANY_PLUS_RE, "+");
  let isNegative = false;
  const trailing = input.match(/([+-])\s*$/);
  if (trailing) {
    if (trailing[1] === "-") {
      isNegative = true;
    }
    input = input.replace(/([+-])\s*$/, "");
  }
  const leading = input.match(/^\s*([+-])/);
  if (leading) {
    if (leading[1] === "-") {
      isNegative = true;
    }
    input = input.replace(/^\s*[+-]/, "");
  }
  let computedLocale = locale;
  if (computedLocale === void 0) {
    if (ARABIC_DETECT_RE.test(input) || PERSIAN_DETECT_RE.test(input)) {
      computedLocale = "ar";
    } else if (HAN_DETECT_RE.test(input)) {
      computedLocale = "zh";
    }
  }
  const {
    group,
    decimal,
    currency
  } = getNumberLocaleDetails(computedLocale, options);
  const unitParts = getFormatter(computedLocale, options).formatToParts(1).filter((p) => p.type === "unit").map((p) => escapeRegExp(p.value));
  const unitRegex = unitParts.length ? new RegExp(unitParts.join("|"), "g") : null;
  let groupRegex = null;
  if (group) {
    groupRegex = new RegExp("\\p{Zs}", "u").test(group) ? new RegExp("\\p{Zs}", "gu") : new RegExp(escapeRegExp(group), "g");
  }
  const replacements = [
    {
      regex: group ? groupRegex : null,
      replacement: ""
    },
    {
      regex: decimal ? new RegExp(escapeRegExp(decimal), "g") : null,
      replacement: "."
    },
    // Fullwidth punctuation
    {
      regex: //g,
      replacement: "."
    },
    // FULLWIDTH_DECIMAL
    {
      regex: //g,
      replacement: ""
    },
    // FULLWIDTH_GROUP
    // Arabic punctuation
    {
      regex: //g,
      replacement: "."
    },
    // ARABIC DECIMAL SEPARATOR (U+066B)
    {
      regex: //g,
      replacement: ""
    },
    // ARABIC THOUSANDS SEPARATOR (U+066C)
    // Currency & unit labels
    {
      regex: currency ? new RegExp(escapeRegExp(currency), "g") : null,
      replacement: ""
    },
    {
      regex: unitRegex,
      replacement: ""
    },
    // Numeral systems to ASCII digits
    {
      regex: ARABIC_RE,
      replacement: (ch) => String(ARABIC_NUMERALS.indexOf(ch))
    },
    {
      regex: PERSIAN_RE,
      replacement: (ch) => String(PERSIAN_NUMERALS.indexOf(ch))
    },
    {
      regex: FULLWIDTH_RE,
      replacement: (ch) => String(FULLWIDTH_NUMERALS.indexOf(ch))
    },
    {
      regex: HAN_RE,
      replacement: (ch) => HAN_NUMERAL_TO_DIGIT[ch]
    }
  ];
  let unformatted = replacements.reduce((acc, {
    regex,
    replacement
  }) => {
    return regex ? acc.replace(regex, replacement) : acc;
  }, input);
  const lastDot = unformatted.lastIndexOf(".");
  if (lastDot !== -1) {
    unformatted = `${unformatted.slice(0, lastDot).replace(/\./g, "")}.${unformatted.slice(lastDot + 1).replace(/\./g, "")}`;
  }
  if (/^[-+]?Infinity$/i.test(input) || /[]/.test(input)) {
    return null;
  }
  const parseTarget = (isNegative ? "-" : "") + unformatted;
  let num = parseFloat(parseTarget);
  const style = options == null ? void 0 : options.style;
  const isUnitPercent = style === "unit" && (options == null ? void 0 : options.unit) === "percent";
  const hasPercentSymbol = PERCENT_RE.test(formattedNumber) || style === "percent";
  const hasPermilleSymbol = PERMILLE_RE.test(formattedNumber);
  if (hasPermilleSymbol) {
    num /= 1e3;
  } else if (!isUnitPercent && hasPercentSymbol) {
    num /= 100;
  }
  if (Number.isNaN(num)) {
    return null;
  }
  return num;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/utils/constants.js
var CHANGE_VALUE_TICK_DELAY = 60;
var START_AUTO_CHANGE_DELAY = 400;
var TOUCH_TIMEOUT = 50;
var MAX_POINTER_MOVES_AFTER_TOUCH = 3;
var SCROLLING_POINTER_MOVE_DISTANCE = 8;
var DEFAULT_STEP = 1;

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/clamp.js
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/utils/validate.js
function removeFloatingPointErrors(value, format = {}) {
  return parseFloat(getFormatter("en-US", {
    maximumFractionDigits: format.maximumFractionDigits,
    minimumFractionDigits: format.minimumFractionDigits,
    useGrouping: false
  }).format(value));
}
function toValidatedNumber(value, {
  step,
  minWithDefault,
  maxWithDefault,
  minWithZeroDefault,
  format,
  snapOnStep,
  small
}) {
  if (value === null) {
    return value;
  }
  const clampedValue = clamp(value, minWithDefault, maxWithDefault);
  if (step != null && snapOnStep) {
    if (small) {
      const stepsFromMin = (clampedValue - minWithZeroDefault) / step;
      const roundedSteps = Math.round(stepsFromMin);
      const snappedValue = minWithZeroDefault + roundedSteps * step;
      return removeFloatingPointErrors(snappedValue, format);
    }
    const base = minWithDefault !== Number.MIN_SAFE_INTEGER ? minWithDefault : minWithZeroDefault;
    if (step > 0) {
      const unsnapped = clampedValue - step;
      const steps = Math.floor((unsnapped - base) / step);
      return removeFloatingPointErrors(base + steps * step + step, format);
    }
    if (step < 0) {
      const absStep = Math.abs(step);
      const unsnapped = clampedValue - step;
      const steps = Math.ceil((unsnapped - base) / absStep);
      return removeFloatingPointErrors(base + steps * absStep + step, format);
    }
  }
  return removeFloatingPointErrors(clampedValue, format);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/root/NumberFieldRoot.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var NumberFieldRoot = React106.forwardRef(function NumberFieldRoot2(componentProps, forwardedRef) {
  const {
    id: idProp,
    min,
    max,
    smallStep = 0.1,
    step = 1,
    largeStep = 10,
    required = false,
    disabled: disabledProp = false,
    readOnly = false,
    name: nameProp,
    defaultValue,
    value: valueProp,
    onValueChange: onValueChangeProp,
    onValueCommitted: onValueCommittedProp,
    allowWheelScrub = false,
    snapOnStep = false,
    format,
    locale,
    render,
    className,
    inputRef: inputRefProp,
    ...elementProps
  } = componentProps;
  const {
    setControlId,
    setDirty,
    validityData,
    setValidityData,
    disabled: fieldDisabled,
    setFilled,
    invalid,
    name: fieldName,
    state: fieldState
  } = useFieldRootContext();
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const [isScrubbing, setIsScrubbing] = React106.useState(false);
  const minWithDefault = min ?? Number.MIN_SAFE_INTEGER;
  const maxWithDefault = max ?? Number.MAX_SAFE_INTEGER;
  const minWithZeroDefault = min ?? 0;
  const formatStyle = format == null ? void 0 : format.style;
  const inputRef = React106.useRef(null);
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    setControlId(id);
    return () => {
      setControlId(void 0);
    };
  }, [id, setControlId]);
  const [valueUnwrapped, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "NumberField",
    state: "value"
  });
  const value = valueUnwrapped ?? null;
  const valueRef = useLatestRef(value);
  useIsoLayoutEffect(() => {
    setFilled(value !== null);
  }, [setFilled, value]);
  const forceRender = useForcedRerendering();
  const formatOptionsRef = useLatestRef(format);
  const onValueChange = useEventCallback(onValueChangeProp);
  const hasPendingCommitRef = React106.useRef(false);
  const onValueCommitted = useEventCallback((nextValue, eventDetails) => {
    hasPendingCommitRef.current = false;
    onValueCommittedProp == null ? void 0 : onValueCommittedProp(nextValue, eventDetails);
  });
  const startTickTimeout = useTimeout();
  const tickInterval = useInterval();
  const intentionalTouchCheckTimeout = useTimeout();
  const isPressedRef = React106.useRef(false);
  const movesAfterTouchRef = React106.useRef(0);
  const allowInputSyncRef = React106.useRef(true);
  const lastChangedValueRef = React106.useRef(null);
  const unsubscribeFromGlobalContextMenuRef = React106.useRef(() => {
  });
  useIsoLayoutEffect(() => {
    if (validityData.initialValue === null && value !== validityData.initialValue) {
      setValidityData((prev) => ({
        ...prev,
        initialValue: value
      }));
    }
  }, [setValidityData, validityData.initialValue, value]);
  const [inputValue, setInputValue] = React106.useState(() => {
    if (valueProp !== void 0) {
      return getControlledInputValue(value, locale, format);
    }
    return formatNumber(value, locale, format);
  });
  const [inputMode, setInputMode] = React106.useState("numeric");
  const getAllowedNonNumericKeys = useEventCallback(() => {
    const {
      decimal,
      group,
      currency
    } = getNumberLocaleDetails(locale, format);
    const keys = /* @__PURE__ */ new Set();
    BASE_NON_NUMERIC_SYMBOLS.forEach((symbol) => keys.add(symbol));
    if (decimal) {
      keys.add(decimal);
    }
    if (group) {
      keys.add(group);
      if (SPACE_SEPARATOR_RE.test(group)) {
        keys.add(" ");
      }
    }
    const allowPercentSymbols = formatStyle === "percent" || formatStyle === "unit" && (format == null ? void 0 : format.unit) === "percent";
    const allowPermilleSymbols = formatStyle === "percent" || formatStyle === "unit" && (format == null ? void 0 : format.unit) === "permille";
    if (allowPercentSymbols) {
      PERCENTAGES.forEach((key) => keys.add(key));
    }
    if (allowPermilleSymbols) {
      PERMILLE.forEach((key) => keys.add(key));
    }
    if (formatStyle === "currency" && currency) {
      keys.add(currency);
    }
    PLUS_SIGNS_WITH_ASCII.forEach((key) => keys.add(key));
    if (minWithDefault < 0) {
      MINUS_SIGNS_WITH_ASCII.forEach((key) => keys.add(key));
    }
    return keys;
  });
  const getStepAmount = useEventCallback((event) => {
    if (event == null ? void 0 : event.altKey) {
      return smallStep;
    }
    if (event == null ? void 0 : event.shiftKey) {
      return largeStep;
    }
    return step;
  });
  const setValue = useEventCallback((unvalidatedValue, event, dir) => {
    const eventWithOptionalKeyState = event;
    const nativeEvent = event && isReactEvent(event) ? event.nativeEvent : event;
    const details = createChangeEventDetails("none", nativeEvent);
    const validatedValue = toValidatedNumber(unvalidatedValue, {
      step: dir ? getStepAmount(eventWithOptionalKeyState) * dir : void 0,
      format: formatOptionsRef.current,
      minWithDefault,
      maxWithDefault,
      minWithZeroDefault,
      snapOnStep,
      small: (eventWithOptionalKeyState == null ? void 0 : eventWithOptionalKeyState.altKey) ?? false
    });
    const shouldFireChange = validatedValue !== value || unvalidatedValue !== value || allowInputSyncRef.current === false;
    if (shouldFireChange) {
      lastChangedValueRef.current = validatedValue;
      onValueChange == null ? void 0 : onValueChange(validatedValue, details);
      if (details.isCanceled) {
        return;
      }
      setValueUnwrapped(validatedValue);
      setDirty(validatedValue !== validityData.initialValue);
      hasPendingCommitRef.current = true;
    }
    if (allowInputSyncRef.current) {
      setInputValue(formatNumber(validatedValue, locale, format));
    }
    forceRender();
  });
  const incrementValue = useEventCallback((amount, dir, currentValue, event) => {
    const prevValue = currentValue == null ? valueRef.current : currentValue;
    const nextValue = typeof prevValue === "number" ? prevValue + amount * dir : Math.max(0, min ?? 0);
    setValue(nextValue, event, dir);
  });
  const stopAutoChange = useEventCallback(() => {
    intentionalTouchCheckTimeout.clear();
    startTickTimeout.clear();
    tickInterval.clear();
    unsubscribeFromGlobalContextMenuRef.current();
    movesAfterTouchRef.current = 0;
  });
  const startAutoChange = useEventCallback((isIncrement, triggerEvent) => {
    stopAutoChange();
    if (!inputRef.current) {
      return;
    }
    const win = getWindow(inputRef.current);
    function handleContextMenu(event) {
      event.preventDefault();
    }
    win.addEventListener("contextmenu", handleContextMenu);
    unsubscribeFromGlobalContextMenuRef.current = () => {
      win.removeEventListener("contextmenu", handleContextMenu);
    };
    win.addEventListener("pointerup", (event) => {
      isPressedRef.current = false;
      stopAutoChange();
      const committed = lastChangedValueRef.current ?? valueRef.current;
      onValueCommitted(committed, createGenericEventDetails("none", event));
    }, {
      once: true
    });
    function tick() {
      const amount = getStepAmount(triggerEvent) ?? DEFAULT_STEP;
      incrementValue(amount, isIncrement ? 1 : -1, void 0, triggerEvent);
    }
    tick();
    startTickTimeout.start(START_AUTO_CHANGE_DELAY, () => {
      tickInterval.start(CHANGE_VALUE_TICK_DELAY, tick);
    });
  });
  useIsoLayoutEffect(function syncFormattedInputValueOnValueChange() {
    if (!allowInputSyncRef.current) {
      return;
    }
    const nextInputValue = valueProp !== void 0 ? getControlledInputValue(value, locale, format) : formatNumber(value, locale, format);
    if (nextInputValue !== inputValue) {
      setInputValue(nextInputValue);
    }
  });
  useIsoLayoutEffect(function setDynamicInputModeForIOS() {
    if (!isIOS) {
      return;
    }
    let computedInputMode = "text";
    if (minWithDefault >= 0) {
      computedInputMode = "decimal";
    }
    setInputMode(computedInputMode);
  }, [minWithDefault, formatStyle]);
  React106.useEffect(() => {
    return () => stopAutoChange();
  }, [stopAutoChange]);
  React106.useEffect(function registerElementWheelListener() {
    const element2 = inputRef.current;
    if (disabled || readOnly || !allowWheelScrub || !element2) {
      return void 0;
    }
    function handleWheel(event) {
      if (
        // Allow pinch-zooming.
        event.ctrlKey || ownerDocument(inputRef.current).activeElement !== inputRef.current
      ) {
        return;
      }
      event.preventDefault();
      const amount = getStepAmount(event) ?? DEFAULT_STEP;
      incrementValue(amount, event.deltaY > 0 ? -1 : 1, void 0, event);
    }
    element2.addEventListener("wheel", handleWheel);
    return () => {
      element2.removeEventListener("wheel", handleWheel);
    };
  }, [allowWheelScrub, incrementValue, disabled, readOnly, largeStep, step, getStepAmount]);
  const state = React106.useMemo(() => ({
    ...fieldState,
    disabled,
    readOnly,
    required,
    value,
    inputValue,
    scrubbing: isScrubbing
  }), [fieldState, disabled, readOnly, required, value, inputValue, isScrubbing]);
  const contextValue = React106.useMemo(() => ({
    inputRef,
    inputValue,
    value,
    startAutoChange,
    stopAutoChange,
    minWithDefault,
    maxWithDefault,
    disabled,
    readOnly,
    id,
    setValue,
    incrementValue,
    getStepAmount,
    allowInputSyncRef,
    formatOptionsRef,
    valueRef,
    lastChangedValueRef,
    hasPendingCommitRef,
    isPressedRef,
    intentionalTouchCheckTimeout,
    movesAfterTouchRef,
    name,
    required,
    invalid,
    inputMode,
    getAllowedNonNumericKeys,
    min,
    max,
    setInputValue,
    locale,
    isScrubbing,
    setIsScrubbing,
    state,
    onValueCommitted
  }), [inputRef, inputValue, value, startAutoChange, stopAutoChange, minWithDefault, maxWithDefault, disabled, readOnly, id, setValue, incrementValue, getStepAmount, allowInputSyncRef, formatOptionsRef, valueRef, lastChangedValueRef, hasPendingCommitRef, isPressedRef, intentionalTouchCheckTimeout, movesAfterTouchRef, name, required, invalid, inputMode, getAllowedNonNumericKeys, min, max, setInputValue, locale, isScrubbing, state, onValueCommitted]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    state,
    props: elementProps,
    stateAttributesMapping: stateAttributesMapping14
  });
  return (0, import_jsx_runtime42.jsxs)(NumberFieldRootContext.Provider, {
    value: contextValue,
    children: [element, name && (0, import_jsx_runtime42.jsx)("input", {
      type: "hidden",
      name,
      ref: inputRefProp,
      value: value ?? "",
      disabled,
      required
    })]
  });
});
if (true) NumberFieldRoot.displayName = "NumberFieldRoot";
function getControlledInputValue(value, locale, format) {
  const explicitPrecision = (format == null ? void 0 : format.maximumFractionDigits) != null || (format == null ? void 0 : format.minimumFractionDigits) != null;
  return explicitPrecision ? formatNumber(value, locale, format) : formatNumberMaxPrecision(value, locale, format);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/group/NumberFieldGroup.js
var React107 = __toESM(require_react(), 1);
var NumberFieldGroup = React107.forwardRef(function NumberFieldGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useNumberFieldRootContext();
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      role: "group"
    }, elementProps],
    stateAttributesMapping: stateAttributesMapping14
  });
  return element;
});
if (true) NumberFieldGroup.displayName = "NumberFieldGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/increment/NumberFieldIncrement.js
var React109 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/root/useNumberFieldButton.js
var React108 = __toESM(require_react(), 1);
function useNumberFieldButton(params) {
  const {
    allowInputSyncRef,
    disabled,
    formatOptionsRef,
    getStepAmount,
    id,
    incrementValue,
    inputRef,
    inputValue,
    intentionalTouchCheckTimeout,
    isIncrement,
    isPressedRef,
    locale,
    maxWithDefault,
    minWithDefault,
    movesAfterTouchRef,
    readOnly,
    setValue,
    startAutoChange,
    stopAutoChange,
    value,
    valueRef,
    lastChangedValueRef,
    onValueCommitted
  } = params;
  const incrementDownCoordsRef = React108.useRef({
    x: 0,
    y: 0
  });
  const isTouchingButtonRef = React108.useRef(false);
  const ignoreClickRef = React108.useRef(false);
  const pointerTypeRef = React108.useRef("");
  const isMin = value != null && value <= minWithDefault;
  const isMax = value != null && value >= maxWithDefault;
  const commitValue = useEventCallback((nativeEvent) => {
    allowInputSyncRef.current = true;
    const parsedValue = parseNumber(inputValue, locale, formatOptionsRef.current);
    if (parsedValue !== null) {
      valueRef.current = parsedValue;
      setValue(parsedValue, nativeEvent);
    }
  });
  const props = React108.useMemo(() => ({
    disabled: disabled || (isIncrement ? isMax : isMin),
    "aria-readonly": readOnly || void 0,
    "aria-label": isIncrement ? "Increase" : "Decrease",
    "aria-controls": id,
    // Keyboard users shouldn't have access to the buttons, since they can use the input element
    // to change the value. On the other hand, `aria-hidden` is not applied because touch screen
    // readers should be able to use the buttons.
    tabIndex: -1,
    style: {
      WebkitUserSelect: "none",
      userSelect: "none"
    },
    onTouchStart() {
      isTouchingButtonRef.current = true;
    },
    onTouchEnd() {
      isTouchingButtonRef.current = false;
    },
    onClick(event) {
      const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);
      if (event.defaultPrevented || isDisabled || // If it's not a keyboard/virtual click, ignore.
      (pointerTypeRef.current === "touch" ? ignoreClickRef.current : event.detail !== 0)) {
        return;
      }
      commitValue(event.nativeEvent);
      const amount = getStepAmount(event) ?? DEFAULT_STEP;
      const prev = valueRef.current;
      incrementValue(amount, isIncrement ? 1 : -1, void 0, event.nativeEvent);
      const committed = lastChangedValueRef.current ?? valueRef.current;
      if (committed !== prev) {
        onValueCommitted(committed, createGenericEventDetails("none", event.nativeEvent));
      }
    },
    onPointerDown(event) {
      var _a;
      const isMainButton = !event.button || event.button === 0;
      const isDisabled = disabled || (isIncrement ? isMax : isMin);
      if (event.defaultPrevented || readOnly || !isMainButton || isDisabled) {
        return;
      }
      pointerTypeRef.current = event.pointerType;
      ignoreClickRef.current = false;
      isPressedRef.current = true;
      incrementDownCoordsRef.current = {
        x: event.clientX,
        y: event.clientY
      };
      commitValue(event.nativeEvent);
      if (event.pointerType !== "touch") {
        event.preventDefault();
        (_a = inputRef.current) == null ? void 0 : _a.focus();
        startAutoChange(isIncrement, event);
      } else {
        intentionalTouchCheckTimeout.start(TOUCH_TIMEOUT, () => {
          const moves = movesAfterTouchRef.current;
          movesAfterTouchRef.current = 0;
          const stillPressed = isPressedRef.current;
          if (stillPressed && moves != null && moves < MAX_POINTER_MOVES_AFTER_TOUCH) {
            startAutoChange(isIncrement, event);
            ignoreClickRef.current = true;
          } else {
            ignoreClickRef.current = false;
            stopAutoChange();
          }
        });
      }
    },
    onPointerUp(event) {
      if (event.pointerType === "touch") {
        isPressedRef.current = false;
      }
    },
    onPointerMove(event) {
      const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);
      if (isDisabled || event.pointerType !== "touch" || !isPressedRef.current) {
        return;
      }
      if (movesAfterTouchRef.current != null) {
        movesAfterTouchRef.current += 1;
      }
      const {
        x,
        y
      } = incrementDownCoordsRef.current;
      const dx = x - event.clientX;
      const dy = y - event.clientY;
      if (dx ** 2 + dy ** 2 > SCROLLING_POINTER_MOVE_DISTANCE ** 2) {
        stopAutoChange();
      }
    },
    onMouseEnter(event) {
      const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);
      if (event.defaultPrevented || isDisabled || !isPressedRef.current || isTouchingButtonRef.current || pointerTypeRef.current === "touch") {
        return;
      }
      startAutoChange(isIncrement, event);
    },
    onMouseLeave() {
      if (isTouchingButtonRef.current) {
        return;
      }
      stopAutoChange();
    },
    onMouseUp() {
      if (isTouchingButtonRef.current) {
        return;
      }
      stopAutoChange();
    }
  }), [disabled, isIncrement, isMax, isMin, readOnly, id, commitValue, getStepAmount, valueRef, incrementValue, lastChangedValueRef, onValueCommitted, isPressedRef, inputRef, startAutoChange, intentionalTouchCheckTimeout, movesAfterTouchRef, stopAutoChange]);
  return React108.useMemo(() => ({
    props
  }), [props]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/increment/NumberFieldIncrement.js
var NumberFieldIncrement = React109.forwardRef(function NumberFieldIncrement2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    allowInputSyncRef,
    disabled: contextDisabled,
    formatOptionsRef,
    getStepAmount,
    id,
    incrementValue,
    inputRef,
    inputValue,
    intentionalTouchCheckTimeout,
    isPressedRef,
    locale,
    maxWithDefault,
    minWithDefault,
    movesAfterTouchRef,
    readOnly,
    setValue,
    startAutoChange,
    state,
    stopAutoChange,
    value,
    valueRef,
    lastChangedValueRef,
    onValueCommitted
  } = useNumberFieldRootContext();
  const disabled = disabledProp || contextDisabled;
  const {
    props
  } = useNumberFieldButton({
    isIncrement: true,
    inputRef,
    startAutoChange,
    stopAutoChange,
    minWithDefault,
    maxWithDefault,
    value,
    inputValue,
    disabled,
    readOnly,
    id,
    setValue,
    getStepAmount,
    incrementValue,
    allowInputSyncRef,
    formatOptionsRef,
    valueRef,
    isPressedRef,
    intentionalTouchCheckTimeout,
    movesAfterTouchRef,
    locale,
    lastChangedValueRef,
    onValueCommitted
  });
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const buttonState = React109.useMemo(() => ({
    ...state,
    disabled
  }), [state, disabled]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state: buttonState,
    props: [props, elementProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping14
  });
  return element;
});
if (true) NumberFieldIncrement.displayName = "NumberFieldIncrement";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/decrement/NumberFieldDecrement.js
var React110 = __toESM(require_react(), 1);
var NumberFieldDecrement = React110.forwardRef(function NumberFieldDecrement2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    allowInputSyncRef,
    disabled: contextDisabled,
    formatOptionsRef,
    getStepAmount,
    id,
    incrementValue,
    inputRef,
    inputValue,
    intentionalTouchCheckTimeout,
    isPressedRef,
    maxWithDefault,
    minWithDefault,
    movesAfterTouchRef,
    readOnly,
    setValue,
    startAutoChange,
    state,
    stopAutoChange,
    value,
    valueRef,
    locale,
    lastChangedValueRef,
    onValueCommitted
  } = useNumberFieldRootContext();
  const disabled = disabledProp || contextDisabled;
  const {
    props
  } = useNumberFieldButton({
    isIncrement: false,
    inputRef,
    startAutoChange,
    stopAutoChange,
    minWithDefault,
    maxWithDefault,
    value,
    inputValue,
    disabled,
    readOnly,
    id,
    setValue,
    getStepAmount,
    incrementValue,
    allowInputSyncRef,
    formatOptionsRef,
    valueRef,
    isPressedRef,
    intentionalTouchCheckTimeout,
    movesAfterTouchRef,
    locale,
    lastChangedValueRef,
    onValueCommitted
  });
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const buttonState = React110.useMemo(() => ({
    ...state,
    disabled
  }), [state, disabled]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state: buttonState,
    props: [props, elementProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping14
  });
  return element;
});
if (true) NumberFieldDecrement.displayName = "NumberFieldDecrement";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/input/NumberFieldInput.js
var React111 = __toESM(require_react(), 1);
var stateAttributesMapping15 = {
  ...fieldValidityMapping,
  ...stateAttributesMapping14
};
var NAVIGATE_KEYS = /* @__PURE__ */ new Set(["Backspace", "Delete", "ArrowLeft", "ArrowRight", "Tab", "Enter", "Escape"]);
var NumberFieldInput = React111.forwardRef(function NumberFieldInput2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    allowInputSyncRef,
    disabled,
    formatOptionsRef,
    getAllowedNonNumericKeys,
    getStepAmount,
    id,
    incrementValue,
    inputMode,
    inputValue,
    max,
    min,
    name,
    readOnly,
    required,
    setValue,
    state,
    setInputValue,
    locale,
    inputRef,
    value,
    onValueCommitted,
    lastChangedValueRef,
    hasPendingCommitRef,
    valueRef
  } = useNumberFieldRootContext();
  const {
    clearErrors
  } = useFormContext();
  const {
    labelId,
    validationMode,
    setTouched,
    setFocused,
    invalid
  } = useFieldRootContext();
  const {
    getInputValidationProps,
    getValidationProps,
    commitValidation,
    inputRef: inputValidationRef
  } = useFieldControlValidation();
  const hasTouchedInputRef = React111.useRef(false);
  const blockRevalidationRef = React111.useRef(false);
  useField({
    id,
    commitValidation,
    value,
    controlRef: inputRef,
    name,
    getValue: () => value ?? null
  });
  const prevValueRef = React111.useRef(value);
  const prevInputValueRef = React111.useRef(inputValue);
  useIsoLayoutEffect(() => {
    if (prevValueRef.current === value && prevInputValueRef.current === inputValue) {
      return;
    }
    clearErrors(name);
    if (validationMode === "onChange") {
      commitValidation(value);
    }
  }, [value, inputValue, name, clearErrors, validationMode, commitValidation]);
  useIsoLayoutEffect(() => {
    if (prevValueRef.current === value || validationMode === "onChange") {
      return;
    }
    if (blockRevalidationRef.current) {
      blockRevalidationRef.current = false;
      return;
    }
    commitValidation(value, true);
  }, [commitValidation, validationMode, value]);
  useIsoLayoutEffect(() => {
    prevValueRef.current = value;
    prevInputValueRef.current = inputValue;
  }, [value, inputValue]);
  const inputProps = {
    id,
    required,
    disabled,
    readOnly,
    inputMode,
    value: inputValue,
    type: "text",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: "false",
    "aria-roledescription": "Number field",
    "aria-invalid": invalid || void 0,
    "aria-labelledby": labelId,
    // If the server's locale does not match the client's locale, the formatting may not match,
    // causing a hydration mismatch.
    suppressHydrationWarning: true,
    onFocus(event) {
      if (event.defaultPrevented || readOnly || disabled || hasTouchedInputRef.current) {
        return;
      }
      hasTouchedInputRef.current = true;
      setFocused(true);
      const target = event.currentTarget;
      const length = target.value.length;
      target.setSelectionRange(length, length);
    },
    onBlur(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      setTouched(true);
      setFocused(false);
      const hadManualInput = !allowInputSyncRef.current;
      const hadPendingProgrammaticChange = hasPendingCommitRef.current;
      allowInputSyncRef.current = true;
      if (inputValue.trim() === "") {
        setValue(null);
        if (validationMode === "onBlur") {
          commitValidation(null);
        }
        onValueCommitted(null, createGenericEventDetails("none", event.nativeEvent));
        return;
      }
      const formatOptions = formatOptionsRef.current;
      const parsedValue = parseNumber(inputValue, locale, formatOptions);
      if (parsedValue === null) {
        return;
      }
      blockRevalidationRef.current = true;
      const hasExplicitPrecision = (formatOptions == null ? void 0 : formatOptions.maximumFractionDigits) != null || (formatOptions == null ? void 0 : formatOptions.minimumFractionDigits) != null;
      const maxFrac = formatOptions == null ? void 0 : formatOptions.maximumFractionDigits;
      const committed = hasExplicitPrecision && typeof maxFrac === "number" ? Number(parsedValue.toFixed(maxFrac)) : parsedValue;
      const nextEventDetails = createGenericEventDetails("none", event.nativeEvent);
      const shouldUpdateValue = value !== committed;
      const shouldCommit = hadManualInput || shouldUpdateValue || hadPendingProgrammaticChange;
      if (validationMode === "onBlur") {
        commitValidation(committed);
      }
      if (shouldUpdateValue) {
        setValue(committed, event.nativeEvent);
      }
      if (shouldCommit) {
        onValueCommitted(committed, nextEventDetails);
      }
      const canonicalText = formatNumber(committed, locale, formatOptions);
      const maxPrecisionText = formatNumberMaxPrecision(parsedValue, locale, formatOptions);
      const shouldPreserveFullPrecision = !hasExplicitPrecision && parsedValue === value && inputValue === maxPrecisionText;
      if (!shouldPreserveFullPrecision && inputValue !== canonicalText) {
        setInputValue(canonicalText);
      }
    },
    onChange(event) {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      allowInputSyncRef.current = false;
      const targetValue = event.target.value;
      if (targetValue.trim() === "") {
        setInputValue(targetValue);
        setValue(null, event.nativeEvent);
        return;
      }
      const allowedNonNumericKeys = getAllowedNonNumericKeys();
      const isValidCharacterString = Array.from(targetValue).every((ch) => {
        const isAsciiDigit = ch >= "0" && ch <= "9";
        const isArabicNumeral = ARABIC_DETECT_RE.test(ch);
        const isHanNumeral = HAN_DETECT_RE.test(ch);
        const isPersianNumeral = PERSIAN_DETECT_RE.test(ch);
        const isFullwidthNumeral = FULLWIDTH_DETECT_RE.test(ch);
        const isMinus = ANY_MINUS_DETECT_RE.test(ch);
        return isAsciiDigit || isArabicNumeral || isHanNumeral || isPersianNumeral || isFullwidthNumeral || isMinus || allowedNonNumericKeys.has(ch);
      });
      if (!isValidCharacterString) {
        return;
      }
      if (event.isTrusted) {
        setInputValue(targetValue);
        const parsedValue2 = parseNumber(targetValue, locale, formatOptionsRef.current);
        if (parsedValue2 !== null) {
          setValue(parsedValue2, event.nativeEvent);
        }
        return;
      }
      const parsedValue = parseNumber(targetValue, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        setInputValue(targetValue);
        setValue(parsedValue, event.nativeEvent);
      }
    },
    onKeyDown(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      const nativeEvent = event.nativeEvent;
      allowInputSyncRef.current = true;
      const allowedNonNumericKeys = getAllowedNonNumericKeys();
      let isAllowedNonNumericKey = allowedNonNumericKeys.has(event.key);
      const {
        decimal,
        currency,
        percentSign
      } = getNumberLocaleDetails(locale, formatOptionsRef.current);
      const selectionStart = event.currentTarget.selectionStart;
      const selectionEnd = event.currentTarget.selectionEnd;
      const isAllSelected = selectionStart === 0 && selectionEnd === inputValue.length;
      const selectionIsExactlyCharAt = (index) => selectionStart === index && selectionEnd === index + 1;
      if (ANY_MINUS_DETECT_RE.test(event.key) && Array.from(allowedNonNumericKeys).some((k) => ANY_MINUS_DETECT_RE.test(k || ""))) {
        const existingIndex = inputValue.search(ANY_MINUS_RE);
        const isReplacingExisting = existingIndex != null && existingIndex !== -1 && selectionIsExactlyCharAt(existingIndex);
        isAllowedNonNumericKey = !(ANY_MINUS_DETECT_RE.test(inputValue) || ANY_PLUS_DETECT_RE.test(inputValue)) || isAllSelected || isReplacingExisting;
      }
      if (ANY_PLUS_DETECT_RE.test(event.key) && Array.from(allowedNonNumericKeys).some((k) => ANY_PLUS_DETECT_RE.test(k || ""))) {
        const existingIndex = inputValue.search(ANY_PLUS_RE);
        const isReplacingExisting = existingIndex != null && existingIndex !== -1 && selectionIsExactlyCharAt(existingIndex);
        isAllowedNonNumericKey = !(ANY_MINUS_DETECT_RE.test(inputValue) || ANY_PLUS_DETECT_RE.test(inputValue)) || isAllSelected || isReplacingExisting;
      }
      [decimal, currency, percentSign].forEach((symbol) => {
        if (event.key === symbol) {
          const symbolIndex = inputValue.indexOf(symbol);
          const isSymbolHighlighted = selectionStart === symbolIndex && selectionEnd === symbolIndex + 1;
          isAllowedNonNumericKey = !inputValue.includes(symbol) || isAllSelected || isSymbolHighlighted;
        }
      });
      const isAsciiDigit = event.key >= "0" && event.key <= "9";
      const isArabicNumeral = ARABIC_DETECT_RE.test(event.key);
      const isHanNumeral = HAN_DETECT_RE.test(event.key);
      const isFullwidthNumeral = FULLWIDTH_DETECT_RE.test(event.key);
      const isNavigateKey = NAVIGATE_KEYS.has(event.key);
      if (
        // Allow composition events (e.g., pinyin)
        // event.nativeEvent.isComposing does not work in Safari:
        // https://bugs.webkit.org/show_bug.cgi?id=165004
        event.which === 229 || event.altKey || event.ctrlKey || event.metaKey || isAllowedNonNumericKey || isAsciiDigit || isArabicNumeral || isFullwidthNumeral || isHanNumeral || isNavigateKey
      ) {
        return;
      }
      const parsedValue = parseNumber(inputValue, locale, formatOptionsRef.current);
      const amount = getStepAmount(event) ?? DEFAULT_STEP;
      stopEvent(event);
      const details = createChangeEventDetails("none", nativeEvent);
      if (event.key === "ArrowUp") {
        incrementValue(amount, 1, parsedValue, nativeEvent);
        onValueCommitted(lastChangedValueRef.current ?? valueRef.current, details);
      } else if (event.key === "ArrowDown") {
        incrementValue(amount, -1, parsedValue, nativeEvent);
        onValueCommitted(lastChangedValueRef.current ?? valueRef.current, details);
      } else if (event.key === "Home" && min != null) {
        setValue(min, nativeEvent);
        onValueCommitted(lastChangedValueRef.current ?? valueRef.current, details);
      } else if (event.key === "End" && max != null) {
        setValue(max, nativeEvent);
        onValueCommitted(lastChangedValueRef.current ?? valueRef.current, details);
      }
    },
    onPaste(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      event.preventDefault();
      const clipboardData = event.clipboardData || window.Clipboard;
      const pastedData = clipboardData.getData("text/plain");
      const parsedValue = parseNumber(pastedData, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        allowInputSyncRef.current = false;
        setValue(parsedValue, event.nativeEvent);
        setInputValue(pastedData);
      }
    }
  };
  const element = useRenderElement("input", componentProps, {
    ref: [forwardedRef, inputRef, inputValidationRef],
    state,
    props: [inputProps, getInputValidationProps(), getValidationProps(), elementProps],
    stateAttributesMapping: stateAttributesMapping15
  });
  return element;
});
if (true) NumberFieldInput.displayName = "NumberFieldInput";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/scrub-area/NumberFieldScrubArea.js
var React113 = __toESM(require_react(), 1);
var ReactDOM6 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/scrub-area/NumberFieldScrubAreaContext.js
var React112 = __toESM(require_react(), 1);
var NumberFieldScrubAreaContext = React112.createContext(void 0);
if (true) NumberFieldScrubAreaContext.displayName = "NumberFieldScrubAreaContext";
function useNumberFieldScrubAreaContext() {
  const context = React112.useContext(NumberFieldScrubAreaContext);
  if (context === void 0) {
    throw new Error("Base UI: NumberFieldScrubAreaContext is missing. NumberFieldScrubArea parts must be placed within <NumberField.ScrubArea>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/utils/getViewportRect.js
function getViewportRect(teleportDistance, scrubAreaEl) {
  const win = getWindow(scrubAreaEl);
  const rect = scrubAreaEl.getBoundingClientRect();
  if (rect && teleportDistance != null) {
    return {
      x: rect.left - teleportDistance / 2,
      y: rect.top - teleportDistance / 2,
      width: rect.right + teleportDistance / 2,
      height: rect.bottom + teleportDistance / 2
    };
  }
  const vV = win.visualViewport;
  if (vV) {
    return {
      x: vV.offsetLeft,
      y: vV.offsetTop,
      width: vV.offsetLeft + vV.width,
      height: vV.offsetTop + vV.height
    };
  }
  return {
    x: 0,
    y: 0,
    width: win.document.documentElement.clientWidth,
    height: win.document.documentElement.clientHeight
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/utils/subscribeToVisualViewportResize.js
function subscribeToVisualViewportResize(element, visualScaleRef) {
  const vV = getWindow(element).visualViewport;
  if (!vV) {
    return () => {
    };
  }
  function handleVisualResize() {
    if (vV) {
      visualScaleRef.current = vV.scale;
    }
  }
  handleVisualResize();
  vV.addEventListener("resize", handleVisualResize);
  return () => {
    vV.removeEventListener("resize", handleVisualResize);
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/scrub-area/NumberFieldScrubArea.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var NumberFieldScrubArea = React113.forwardRef(function NumberFieldScrubArea2(componentProps, forwardedRef) {
  const {
    render,
    className,
    direction = "horizontal",
    pixelSensitivity = 2,
    teleportDistance,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useNumberFieldRootContext();
  const {
    isScrubbing,
    setIsScrubbing,
    disabled,
    readOnly,
    value,
    inputRef,
    incrementValue,
    getStepAmount,
    onValueCommitted,
    lastChangedValueRef,
    valueRef
  } = useNumberFieldRootContext();
  const latestValueRef = useLatestRef(value);
  const scrubAreaRef = React113.useRef(null);
  const isScrubbingRef = React113.useRef(false);
  const scrubAreaCursorRef = React113.useRef(null);
  const virtualCursorCoords = React113.useRef({
    x: 0,
    y: 0
  });
  const visualScaleRef = React113.useRef(1);
  const [isTouchInput, setIsTouchInput] = React113.useState(false);
  const [isPointerLockDenied, setIsPointerLockDenied] = React113.useState(false);
  React113.useEffect(() => {
    if (!isScrubbing || !scrubAreaCursorRef.current) {
      return void 0;
    }
    return subscribeToVisualViewportResize(scrubAreaCursorRef.current, visualScaleRef);
  }, [isScrubbing]);
  const updateCursorTransform = useEventCallback((x, y) => {
    if (scrubAreaCursorRef.current) {
      scrubAreaCursorRef.current.style.transform = `translate3d(${x}px,${y}px,0) scale(${1 / visualScaleRef.current})`;
    }
  });
  const onScrub = React113.useCallback(({
    movementX,
    movementY
  }) => {
    const virtualCursor = scrubAreaCursorRef.current;
    const scrubAreaEl = scrubAreaRef.current;
    if (!virtualCursor || !scrubAreaEl) {
      return;
    }
    const rect = getViewportRect(teleportDistance, scrubAreaEl);
    const coords = virtualCursorCoords.current;
    const newCoords = {
      x: Math.round(coords.x + movementX),
      y: Math.round(coords.y + movementY)
    };
    const cursorWidth = virtualCursor.offsetWidth;
    const cursorHeight = virtualCursor.offsetHeight;
    if (newCoords.x + cursorWidth / 2 < rect.x) {
      newCoords.x = rect.width - cursorWidth / 2;
    } else if (newCoords.x + cursorWidth / 2 > rect.width) {
      newCoords.x = rect.x - cursorWidth / 2;
    }
    if (newCoords.y + cursorHeight / 2 < rect.y) {
      newCoords.y = rect.height - cursorHeight / 2;
    } else if (newCoords.y + cursorHeight / 2 > rect.height) {
      newCoords.y = rect.y - cursorHeight / 2;
    }
    virtualCursorCoords.current = newCoords;
    updateCursorTransform(newCoords.x, newCoords.y);
  }, [teleportDistance, updateCursorTransform]);
  const onScrubbingChange = React113.useCallback((scrubbingValue, {
    clientX,
    clientY
  }) => {
    ReactDOM6.flushSync(() => {
      setIsScrubbing(scrubbingValue);
    });
    const virtualCursor = scrubAreaCursorRef.current;
    if (!virtualCursor || !scrubbingValue) {
      return;
    }
    const initialCoords = {
      x: clientX - virtualCursor.offsetWidth / 2,
      y: clientY - virtualCursor.offsetHeight / 2
    };
    virtualCursorCoords.current = initialCoords;
    updateCursorTransform(initialCoords.x, initialCoords.y);
  }, [setIsScrubbing, updateCursorTransform]);
  React113.useEffect(function registerGlobalScrubbingEventListeners() {
    if (!inputRef.current || disabled || readOnly || !isScrubbing) {
      return void 0;
    }
    let cumulativeDelta = 0;
    function handleScrubPointerUp(event) {
      try {
        ownerDocument(scrubAreaRef.current).exitPointerLock();
      } catch {
      } finally {
        isScrubbingRef.current = false;
        onScrubbingChange(false, event);
        onValueCommitted(lastChangedValueRef.current ?? valueRef.current, createGenericEventDetails("none", event));
      }
    }
    function handleScrubPointerMove(event) {
      if (!isScrubbingRef.current) {
        return;
      }
      event.preventDefault();
      onScrub(event);
      const {
        movementX,
        movementY
      } = event;
      cumulativeDelta += direction === "vertical" ? movementY : movementX;
      if (Math.abs(cumulativeDelta) >= pixelSensitivity) {
        cumulativeDelta = 0;
        const dValue = direction === "vertical" ? -movementY : movementX;
        incrementValue(dValue * (getStepAmount(event) ?? DEFAULT_STEP), 1);
      }
    }
    const win = getWindow(inputRef.current);
    win.addEventListener("pointerup", handleScrubPointerUp, true);
    win.addEventListener("pointermove", handleScrubPointerMove, true);
    return () => {
      win.removeEventListener("pointerup", handleScrubPointerUp, true);
      win.removeEventListener("pointermove", handleScrubPointerMove, true);
    };
  }, [disabled, readOnly, isScrubbing, incrementValue, latestValueRef, getStepAmount, inputRef, onScrubbingChange, onScrub, direction, pixelSensitivity, lastChangedValueRef, onValueCommitted, valueRef]);
  React113.useEffect(function registerScrubberTouchPreventListener() {
    const element2 = scrubAreaRef.current;
    if (!element2 || disabled || readOnly) {
      return void 0;
    }
    function handleTouchStart(event) {
      if (event.touches.length === 1) {
        event.preventDefault();
      }
    }
    element2.addEventListener("touchstart", handleTouchStart);
    return () => {
      element2.removeEventListener("touchstart", handleTouchStart);
    };
  }, [disabled, readOnly]);
  const defaultProps = {
    role: "presentation",
    style: {
      touchAction: "none",
      WebkitUserSelect: "none",
      userSelect: "none"
    },
    async onPointerDown(event) {
      var _a;
      const isMainButton = !event.button || event.button === 0;
      if (event.defaultPrevented || readOnly || !isMainButton || disabled) {
        return;
      }
      const isTouch = event.pointerType === "touch";
      setIsTouchInput(isTouch);
      if (event.pointerType === "mouse") {
        event.preventDefault();
        (_a = inputRef.current) == null ? void 0 : _a.focus();
      }
      isScrubbingRef.current = true;
      onScrubbingChange(true, event.nativeEvent);
      if (!isTouch && !isWebKit) {
        try {
          await ownerDocument(scrubAreaRef.current).body.requestPointerLock();
          setIsPointerLockDenied(false);
        } catch (error) {
          setIsPointerLockDenied(true);
        } finally {
          if (isScrubbingRef.current) {
            ReactDOM6.flushSync(() => {
              onScrubbingChange(true, event.nativeEvent);
            });
          }
        }
      }
    }
  };
  const element = useRenderElement("span", componentProps, {
    ref: [forwardedRef, scrubAreaRef],
    state,
    props: [defaultProps, elementProps],
    stateAttributesMapping: stateAttributesMapping14
  });
  const contextValue = React113.useMemo(() => ({
    isScrubbing,
    isTouchInput,
    isPointerLockDenied,
    scrubAreaCursorRef,
    scrubAreaRef,
    direction,
    pixelSensitivity,
    teleportDistance
  }), [isScrubbing, isTouchInput, isPointerLockDenied, direction, pixelSensitivity, teleportDistance]);
  return (0, import_jsx_runtime43.jsx)(NumberFieldScrubAreaContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) NumberFieldScrubArea.displayName = "NumberFieldScrubArea";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/number-field/scrub-area-cursor/NumberFieldScrubAreaCursor.js
var React114 = __toESM(require_react(), 1);
var ReactDOM7 = __toESM(require_react_dom(), 1);
var NumberFieldScrubAreaCursor = React114.forwardRef(function NumberFieldScrubAreaCursor2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useNumberFieldRootContext();
  const {
    isScrubbing,
    isTouchInput,
    isPointerLockDenied,
    scrubAreaCursorRef
  } = useNumberFieldScrubAreaContext();
  const [domElement, setDomElement] = React114.useState(null);
  const shouldRender = isScrubbing && !isWebKit && !isTouchInput && !isPointerLockDenied;
  const element = useRenderElement("span", componentProps, {
    enabled: shouldRender,
    ref: [forwardedRef, scrubAreaCursorRef, setDomElement],
    state,
    props: [{
      role: "presentation",
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        pointerEvents: "none"
      }
    }, elementProps],
    stateAttributesMapping: stateAttributesMapping14
  });
  return element && ReactDOM7.createPortal(element, ownerDocument(domElement).body);
});
if (true) NumberFieldScrubAreaCursor.displayName = "NumberFieldScrubAreaCursor";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/index.parts.js
var index_parts_exports21 = {};
__export(index_parts_exports21, {
  Arrow: () => PopoverArrow,
  Backdrop: () => PopoverBackdrop,
  Close: () => PopoverClose,
  Description: () => PopoverDescription,
  Popup: () => PopoverPopup,
  Portal: () => PopoverPortal,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/root/PopoverRoot.js
var React116 = __toESM(require_react(), 1);
var ReactDOM8 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/utils/constants.js
var OPEN_DELAY = 300;

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/root/PopoverRootContext.js
var React115 = __toESM(require_react(), 1);
var PopoverRootContext = React115.createContext(void 0);
if (true) PopoverRootContext.displayName = "PopoverRootContext";
function usePopoverRootContext(optional) {
  const context = React115.useContext(PopoverRootContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: PopoverRootContext is missing. Popover parts must be placed within <Popover.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/root/PopoverRoot.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
function PopoverRootComponent({
  props
}) {
  const {
    open: externalOpen,
    onOpenChange,
    defaultOpen = false,
    delay = OPEN_DELAY,
    closeDelay = 0,
    openOnHover = false,
    onOpenChangeComplete,
    modal = false
  } = props;
  const [instantType, setInstantType] = React116.useState();
  const [titleId, setTitleId] = React116.useState();
  const [descriptionId, setDescriptionId] = React116.useState();
  const [triggerElement, setTriggerElement] = React116.useState(null);
  const [positionerElement, setPositionerElement] = React116.useState(null);
  const [openReason, setOpenReason] = React116.useState(null);
  const [stickIfOpen, setStickIfOpen] = React116.useState(true);
  const backdropRef = React116.useRef(null);
  const internalBackdropRef = React116.useRef(null);
  const popupRef = React116.useRef(null);
  const stickIfOpenTimeout = useTimeout();
  const nested = useFloatingParentNodeId() != null;
  let floatingEvents;
  const [open, setOpenUnwrapped] = useControlled({
    controlled: externalOpen,
    default: defaultOpen,
    name: "Popover",
    state: "open"
  });
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  const {
    openMethod,
    triggerProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(open);
  const handleUnmount = useEventCallback(() => {
    setMounted(false);
    setStickIfOpen(true);
    setOpenReason(null);
    onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(false);
    resetOpenInteractionType();
  });
  useOpenChangeComplete({
    enabled: !props.actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  React116.useImperativeHandle(props.actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  React116.useEffect(() => {
    if (!open) {
      stickIfOpenTimeout.clear();
    }
  }, [stickIfOpenTimeout, open]);
  const setOpen = useEventCallback((nextOpen, eventDetails) => {
    const isHover = eventDetails.reason === "trigger-hover";
    const isKeyboardClick = eventDetails.reason === "trigger-press" && eventDetails.event.detail === 0;
    const isDismissClose = !nextOpen && (eventDetails.reason === "escape-key" || eventDetails.reason === "none");
    onOpenChange == null ? void 0 : onOpenChange(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const details = {
      open: nextOpen,
      nativeEvent: eventDetails.event,
      reason: eventDetails.reason,
      nested
    };
    floatingEvents == null ? void 0 : floatingEvents.emit("openchange", details);
    function changeState() {
      setOpenUnwrapped(nextOpen);
      if (nextOpen) {
        setOpenReason(eventDetails.reason);
      }
    }
    if (isHover) {
      setStickIfOpen(true);
      stickIfOpenTimeout.start(PATIENT_CLICK_THRESHOLD, () => {
        setStickIfOpen(false);
      });
      ReactDOM8.flushSync(changeState);
    } else {
      changeState();
    }
    if (isKeyboardClick || isDismissClose) {
      setInstantType(isKeyboardClick ? "click" : "dismiss");
    } else {
      setInstantType(void 0);
    }
  });
  const floatingContext = useFloatingRootContext({
    elements: {
      reference: triggerElement,
      floating: positionerElement
    },
    open,
    onOpenChange: setOpen
  });
  floatingEvents = floatingContext.events;
  useScrollLock({
    enabled: open && modal === true && openReason !== "trigger-hover" && openMethod !== "touch",
    mounted,
    open,
    referenceElement: positionerElement
  });
  const computedRestMs = delay;
  const hover = useHover(floatingContext, {
    enabled: openOnHover && (openMethod !== "touch" || openReason !== "trigger-press"),
    mouseOnly: true,
    move: false,
    handleClose: safePolygon({
      blockPointerEvents: true
    }),
    restMs: computedRestMs,
    delay: {
      close: closeDelay
    }
  });
  const click = useClick(floatingContext, {
    stickIfOpen
  });
  const dismiss = useDismiss(floatingContext, {
    outsidePressEvent: {
      // Ensure `aria-hidden` on outside elements is removed immediately
      // on outside press when trapping focus.
      mouse: modal === "trap-focus" ? "sloppy" : "intentional",
      touch: "sloppy"
    }
  });
  const role = useRole(floatingContext);
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([hover, click, dismiss, role]);
  const popoverContext = React116.useMemo(() => ({
    open,
    setOpen,
    mounted,
    setMounted,
    transitionStatus,
    triggerElement,
    setTriggerElement,
    positionerElement,
    setPositionerElement,
    popupRef,
    titleId,
    setTitleId,
    descriptionId,
    setDescriptionId,
    backdropRef,
    internalBackdropRef,
    triggerProps: mergeProps(getReferenceProps(), triggerProps),
    popupProps: getFloatingProps(),
    floatingRootContext: floatingContext,
    instantType,
    openMethod,
    openReason,
    onOpenChangeComplete,
    openOnHover,
    delay,
    closeDelay,
    modal
  }), [open, setOpen, mounted, setMounted, transitionStatus, positionerElement, titleId, descriptionId, getReferenceProps, triggerElement, triggerProps, getFloatingProps, floatingContext, instantType, openMethod, openReason, onOpenChangeComplete, openOnHover, delay, closeDelay, modal]);
  return (0, import_jsx_runtime44.jsx)(PopoverRootContext.Provider, {
    value: popoverContext,
    children: props.children
  });
}
function PopoverRoot(props) {
  if (usePopoverRootContext(true)) {
    return (0, import_jsx_runtime44.jsx)(PopoverRootComponent, {
      props
    });
  }
  return (0, import_jsx_runtime44.jsx)(FloatingTree, {
    children: (0, import_jsx_runtime44.jsx)(PopoverRootComponent, {
      props
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/trigger/PopoverTrigger.js
var React117 = __toESM(require_react(), 1);
var PopoverTrigger = React117.forwardRef(function PopoverTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    open,
    setTriggerElement,
    triggerProps,
    openReason
  } = usePopoverRootContext();
  const state = React117.useMemo(() => ({
    disabled,
    open
  }), [disabled, open]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const stateAttributesMapping22 = React117.useMemo(() => ({
    open(value) {
      if (value && openReason === "trigger-press") {
        return pressableTriggerOpenStateMapping.open(value);
      }
      return triggerOpenStateMapping.open(value);
    }
  }), [openReason]);
  const element = useRenderElement("button", componentProps, {
    state,
    ref: [buttonRef, setTriggerElement, forwardedRef],
    props: [triggerProps, {
      [CLICK_TRIGGER_IDENTIFIER]: ""
    }, elementProps, getButtonProps],
    stateAttributesMapping: stateAttributesMapping22
  });
  return element;
});
if (true) PopoverTrigger.displayName = "PopoverTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/portal/PopoverPortal.js
var React119 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/portal/PopoverPortalContext.js
var React118 = __toESM(require_react(), 1);
var PopoverPortalContext = React118.createContext(void 0);
if (true) PopoverPortalContext.displayName = "PopoverPortalContext";
function usePopoverPortalContext() {
  const value = React118.useContext(PopoverPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <Popover.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/portal/PopoverPortal.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
function PopoverPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    mounted
  } = usePopoverRootContext();
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime45.jsx)(PopoverPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime45.jsx)(FloatingPortal, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/positioner/PopoverPositioner.js
var React121 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/positioner/PopoverPositionerContext.js
var React120 = __toESM(require_react(), 1);
var PopoverPositionerContext = React120.createContext(void 0);
if (true) PopoverPositionerContext.displayName = "PopoverPositionerContext";
function usePopoverPositionerContext() {
  const context = React120.useContext(PopoverPositionerContext);
  if (!context) {
    throw new Error("Base UI: PopoverPositionerContext is missing. PopoverPositioner parts must be placed within <Popover.Positioner>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/positioner/PopoverPositioner.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var PopoverPositioner = React121.forwardRef(function PopoverPositioner2(componentProps, forwardedRef) {
  const {
    render,
    className,
    anchor,
    positionMethod = "absolute",
    side = "bottom",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = false,
    trackAnchor = true,
    collisionAvoidance = POPUP_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps;
  const {
    floatingRootContext,
    open,
    mounted,
    setPositionerElement,
    modal,
    openReason,
    openMethod,
    triggerElement,
    internalBackdropRef
  } = usePopoverRootContext();
  const keepMounted = usePopoverPortalContext();
  const nodeId = useFloatingNodeId();
  const positioning = useAnchorPositioning({
    anchor,
    floatingRootContext,
    positionMethod,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    trackAnchor,
    keepMounted,
    nodeId,
    collisionAvoidance
  });
  const defaultProps = React121.useMemo(() => {
    const hiddenStyles = {};
    if (!open) {
      hiddenStyles.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioning.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, mounted, positioning.positionerStyles]);
  const positioner = React121.useMemo(() => ({
    props: defaultProps,
    ...positioning
  }), [defaultProps, positioning]);
  const state = React121.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    anchorHidden: positioner.anchorHidden
  }), [open, positioner.side, positioner.align, positioner.anchorHidden]);
  const element = useRenderElement("div", componentProps, {
    state,
    props: [positioner.props, elementProps],
    ref: [forwardedRef, setPositionerElement],
    stateAttributesMapping: popupStateMapping
  });
  return (0, import_jsx_runtime46.jsxs)(PopoverPositionerContext.Provider, {
    value: positioner,
    children: [mounted && modal === true && openReason !== "trigger-hover" && openMethod !== "touch" && (0, import_jsx_runtime46.jsx)(InternalBackdrop, {
      ref: internalBackdropRef,
      inert: inertValue(!open),
      cutout: triggerElement
    }), (0, import_jsx_runtime46.jsx)(FloatingNode, {
      id: nodeId,
      children: element
    })]
  });
});
if (true) PopoverPositioner.displayName = "PopoverPositioner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/popup/PopoverPopup.js
var React122 = __toESM(require_react(), 1);
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping16 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var PopoverPopup = React122.forwardRef(function PopoverPopup2(componentProps, forwardedRef) {
  const {
    className,
    render,
    initialFocus,
    finalFocus,
    ...elementProps
  } = componentProps;
  const {
    open,
    instantType,
    transitionStatus,
    popupProps,
    titleId,
    descriptionId,
    popupRef,
    mounted,
    openReason,
    onOpenChangeComplete,
    modal,
    openMethod
  } = usePopoverRootContext();
  const positioner = usePopoverPositionerContext();
  const insideToolbar = useToolbarRootContext(true) != null;
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      if (open) {
        onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(true);
      }
    }
  });
  const defaultInitialFocus = useEventCallback((interactionType) => {
    if (interactionType === "touch") {
      return popupRef.current;
    }
    return true;
  });
  const resolvedInitialFocus = initialFocus === void 0 ? defaultInitialFocus : initialFocus;
  const state = React122.useMemo(() => ({
    open,
    side: positioner.side,
    align: positioner.align,
    instant: instantType,
    transitionStatus
  }), [open, positioner.side, positioner.align, instantType, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, popupRef],
    props: [popupProps, {
      "aria-labelledby": titleId,
      "aria-describedby": descriptionId,
      onKeyDown(event) {
        if (insideToolbar && COMPOSITE_KEYS.has(event.key)) {
          event.stopPropagation();
        }
      }
    }, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps],
    stateAttributesMapping: stateAttributesMapping16
  });
  return (0, import_jsx_runtime47.jsx)(FloatingFocusManager, {
    context: positioner.context,
    openInteractionType: openMethod,
    modal: modal === "trap-focus",
    disabled: !mounted || openReason === "trigger-hover",
    initialFocus: resolvedInitialFocus,
    returnFocus: finalFocus,
    restoreFocus: "popup",
    children: element
  });
});
if (true) PopoverPopup.displayName = "PopoverPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/arrow/PopoverArrow.js
var React123 = __toESM(require_react(), 1);
var PopoverArrow = React123.forwardRef(function PopoverArrow2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open
  } = usePopoverRootContext();
  const {
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = usePopoverPositionerContext();
  const state = React123.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, arrowRef],
    props: [{
      style: arrowStyles,
      "aria-hidden": true
    }, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return element;
});
if (true) PopoverArrow.displayName = "PopoverArrow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/backdrop/PopoverBackdrop.js
var React124 = __toESM(require_react(), 1);
var stateAttributesMapping17 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var PopoverBackdrop = React124.forwardRef(function PopoverBackdrop2(props, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = props;
  const {
    open,
    mounted,
    transitionStatus,
    openReason,
    backdropRef
  } = usePopoverRootContext();
  const state = React124.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  const element = useRenderElement("div", props, {
    state,
    ref: [backdropRef, forwardedRef],
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        pointerEvents: openReason === "trigger-hover" ? "none" : void 0,
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps],
    stateAttributesMapping: stateAttributesMapping17
  });
  return element;
});
if (true) PopoverBackdrop.displayName = "PopoverBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/title/PopoverTitle.js
var React125 = __toESM(require_react(), 1);
var PopoverTitle = React125.forwardRef(function PopoverTitle2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    setTitleId
  } = usePopoverRootContext();
  const id = useBaseUiId(elementProps.id);
  useIsoLayoutEffect(() => {
    setTitleId(id);
    return () => {
      setTitleId(void 0);
    };
  }, [setTitleId, id]);
  const element = useRenderElement("h2", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
  return element;
});
if (true) PopoverTitle.displayName = "PopoverTitle";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/description/PopoverDescription.js
var React126 = __toESM(require_react(), 1);
var PopoverDescription = React126.forwardRef(function PopoverDescription2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    setDescriptionId
  } = usePopoverRootContext();
  const id = useBaseUiId(elementProps.id);
  useIsoLayoutEffect(() => {
    setDescriptionId(id);
    return () => {
      setDescriptionId(void 0);
    };
  }, [setDescriptionId, id]);
  const element = useRenderElement("p", componentProps, {
    ref: forwardedRef,
    props: [{
      id
    }, elementProps]
  });
  return element;
});
if (true) PopoverDescription.displayName = "PopoverDescription";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/popover/close/PopoverClose.js
var React127 = __toESM(require_react(), 1);
var PopoverClose = React127.forwardRef(function PopoverClose2(props, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    ...elementProps
  } = props;
  const {
    buttonRef,
    getButtonProps
  } = useButton({
    disabled,
    focusableWhenDisabled: false,
    native: nativeButton
  });
  const {
    setOpen
  } = usePopoverRootContext();
  const element = useRenderElement("button", props, {
    ref: [forwardedRef, buttonRef],
    props: [{
      onClick(event) {
        setOpen(false, createChangeEventDetails("close-press", event.nativeEvent));
      }
    }, elementProps, getButtonProps]
  });
  return element;
});
if (true) PopoverClose.displayName = "PopoverClose";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/index.parts.js
var index_parts_exports22 = {};
__export(index_parts_exports22, {
  Arrow: () => PreviewCardArrow,
  Backdrop: () => PreviewCardBackdrop,
  Popup: () => PreviewCardPopup,
  Portal: () => PreviewCardPortal,
  Positioner: () => PreviewCardPositioner,
  Root: () => PreviewCardRoot,
  Trigger: () => PreviewCardTrigger
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/root/PreviewCardRoot.js
var React130 = __toESM(require_react(), 1);
var ReactDOM9 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/root/PreviewCardContext.js
var React128 = __toESM(require_react(), 1);
var PreviewCardRootContext = React128.createContext(void 0);
if (true) PreviewCardRootContext.displayName = "PreviewCardRootContext";
function usePreviewCardRootContext() {
  const context = React128.useContext(PreviewCardRootContext);
  if (context === void 0) {
    throw new Error("Base UI: PreviewCardRootContext is missing. PreviewCard parts must be placed within <PreviewCard.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/utils/constants.js
var OPEN_DELAY2 = 600;
var CLOSE_DELAY = 300;

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/interactions/useFocusWithDelay.js
var React129 = __toESM(require_react(), 1);
function useFocusWithDelay(context, props = {}) {
  const {
    onOpenChange,
    elements,
    open,
    dataRef
  } = context;
  const {
    delay
  } = props;
  const timeout = useTimeout();
  const blockFocusRef = React129.useRef(false);
  React129.useEffect(() => {
    const win = getWindow(elements.domReference);
    function handleBlur() {
      if (!open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference))) {
        blockFocusRef.current = true;
      }
    }
    win.addEventListener("blur", handleBlur);
    return () => {
      win.removeEventListener("blur", handleBlur);
    };
  }, [elements.domReference, open]);
  const reference = React129.useMemo(() => ({
    onFocus(event) {
      const {
        nativeEvent
      } = event;
      timeout.start(delay ?? 0, () => {
        onOpenChange(true, createChangeEventDetails("trigger-focus", nativeEvent));
      });
    },
    onBlur(event) {
      blockFocusRef.current = false;
      const {
        relatedTarget,
        nativeEvent
      } = event;
      timeout.start(0, () => {
        var _a;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        if (!relatedTarget && activeEl === elements.domReference) {
          return;
        }
        if (contains((_a = dataRef.current.floatingContext) == null ? void 0 : _a.refs.floating.current, activeEl) || contains(elements.domReference, activeEl)) {
          return;
        }
        onOpenChange(false, createChangeEventDetails("trigger-focus", nativeEvent));
      });
    }
  }), [delay, onOpenChange, elements.domReference, dataRef, timeout]);
  return React129.useMemo(() => ({
    reference
  }), [reference]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/root/PreviewCardRoot.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
function PreviewCardRoot(props) {
  const {
    open: externalOpen,
    defaultOpen,
    onOpenChange: onOpenChangeProp,
    delay,
    closeDelay,
    onOpenChangeComplete,
    actionsRef
  } = props;
  const delayWithDefault = delay ?? OPEN_DELAY2;
  const closeDelayWithDefault = closeDelay ?? CLOSE_DELAY;
  const [triggerElement, setTriggerElement] = React130.useState(null);
  const [positionerElement, setPositionerElement] = React130.useState(null);
  const [instantTypeState, setInstantTypeState] = React130.useState();
  const popupRef = React130.useRef(null);
  const [open, setOpenUnwrapped] = useControlled({
    controlled: externalOpen,
    default: defaultOpen,
    name: "PreviewCard",
    state: "open"
  });
  const onOpenChange = useEventCallback(onOpenChangeProp);
  const {
    mounted,
    setMounted,
    transitionStatus
  } = useTransitionStatus(open);
  const handleUnmount = useEventCallback(() => {
    setMounted(false);
    onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(false);
  });
  useOpenChangeComplete({
    enabled: !actionsRef,
    open,
    ref: popupRef,
    onComplete() {
      if (!open) {
        handleUnmount();
      }
    }
  });
  React130.useImperativeHandle(actionsRef, () => ({
    unmount: handleUnmount
  }), [handleUnmount]);
  const setOpen = useEventCallback((nextOpen, eventDetails) => {
    const isHover = eventDetails.reason === "trigger-hover";
    const isFocusOpen = nextOpen && eventDetails.reason === "trigger-focus";
    const isDismissClose = !nextOpen && (eventDetails.reason === "trigger-press" || eventDetails.reason === "escape-key");
    onOpenChange(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    function changeState() {
      setOpenUnwrapped(nextOpen);
    }
    if (isHover) {
      ReactDOM9.flushSync(changeState);
    } else {
      changeState();
    }
    if (isFocusOpen || isDismissClose) {
      setInstantTypeState(isFocusOpen ? "focus" : "dismiss");
    } else if (eventDetails.reason === "trigger-hover") {
      setInstantTypeState(void 0);
    }
  });
  const context = useFloatingRootContext({
    elements: {
      reference: triggerElement,
      floating: positionerElement
    },
    open,
    onOpenChange: setOpen
  });
  const instantType = instantTypeState;
  const computedRestMs = delayWithDefault;
  const hover = useHover(context, {
    mouseOnly: true,
    move: false,
    handleClose: safePolygon(),
    restMs: computedRestMs,
    delay: {
      close: closeDelayWithDefault
    }
  });
  const focus = useFocusWithDelay(context, {
    delay: OPEN_DELAY2
  });
  const dismiss = useDismiss(context);
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([hover, focus, dismiss]);
  const contextValue = React130.useMemo(() => ({
    open,
    setOpen,
    mounted,
    setMounted,
    setTriggerElement,
    positionerElement,
    setPositionerElement,
    popupRef,
    triggerProps: getReferenceProps(),
    popupProps: getFloatingProps(),
    floatingRootContext: context,
    instantType,
    transitionStatus,
    onOpenChangeComplete,
    delay: delayWithDefault,
    closeDelay: closeDelayWithDefault
  }), [open, setOpen, mounted, setMounted, positionerElement, getReferenceProps, getFloatingProps, context, instantType, transitionStatus, onOpenChangeComplete, delayWithDefault, closeDelayWithDefault]);
  return (0, import_jsx_runtime48.jsx)(PreviewCardRootContext.Provider, {
    value: contextValue,
    children: props.children
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/portal/PreviewCardPortal.js
var React132 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/portal/PreviewCardPortalContext.js
var React131 = __toESM(require_react(), 1);
var PreviewCardPortalContext = React131.createContext(void 0);
if (true) PreviewCardPortalContext.displayName = "PreviewCardPortalContext";
function usePreviewCardPortalContext() {
  const value = React131.useContext(PreviewCardPortalContext);
  if (value === void 0) {
    throw new Error("Base UI: <PreviewCard.Portal> is missing.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/portal/PreviewCardPortal.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
function PreviewCardPortal(props) {
  const {
    children,
    keepMounted = false,
    container
  } = props;
  const {
    mounted
  } = usePreviewCardRootContext();
  const shouldRender = mounted || keepMounted;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime49.jsx)(PreviewCardPortalContext.Provider, {
    value: keepMounted,
    children: (0, import_jsx_runtime49.jsx)(FloatingPortalLite, {
      root: container,
      children
    })
  });
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/trigger/PreviewCardTrigger.js
var React133 = __toESM(require_react(), 1);
var PreviewCardTrigger = React133.forwardRef(function PreviewCardTrigger2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    open,
    triggerProps,
    setTriggerElement
  } = usePreviewCardRootContext();
  const state = React133.useMemo(() => ({
    open
  }), [open]);
  const element = useRenderElement("a", componentProps, {
    ref: [setTriggerElement, forwardedRef],
    state,
    props: [triggerProps, elementProps],
    stateAttributesMapping: triggerOpenStateMapping
  });
  return element;
});
if (true) PreviewCardTrigger.displayName = "PreviewCardTrigger";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/positioner/PreviewCardPositioner.js
var React135 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/positioner/PreviewCardPositionerContext.js
var React134 = __toESM(require_react(), 1);
var PreviewCardPositionerContext = React134.createContext(void 0);
if (true) PreviewCardPositionerContext.displayName = "PreviewCardPositionerContext";
function usePreviewCardPositionerContext() {
  const context = React134.useContext(PreviewCardPositionerContext);
  if (context === void 0) {
    throw new Error("Base UI: <PreviewCard.Popup> and <PreviewCard.Arrow> must be used within the <PreviewCard.Positioner> component");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/positioner/PreviewCardPositioner.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var PreviewCardPositioner = React135.forwardRef(function PreviewCardPositioner2(componentProps, forwardedRef) {
  const {
    render,
    className,
    anchor,
    positionMethod = "absolute",
    side = "bottom",
    align = "center",
    sideOffset = 0,
    alignOffset = 0,
    collisionBoundary = "clipping-ancestors",
    collisionPadding = 5,
    arrowPadding = 5,
    sticky = false,
    trackAnchor = true,
    collisionAvoidance = POPUP_COLLISION_AVOIDANCE,
    ...elementProps
  } = componentProps;
  const {
    open,
    mounted,
    floatingRootContext,
    setPositionerElement
  } = usePreviewCardRootContext();
  const keepMounted = usePreviewCardPortalContext();
  const positioning = useAnchorPositioning({
    anchor,
    floatingRootContext,
    positionMethod,
    mounted,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    trackAnchor,
    keepMounted,
    collisionAvoidance
  });
  const defaultProps = React135.useMemo(() => {
    const hiddenStyles = {};
    if (!open) {
      hiddenStyles.pointerEvents = "none";
    }
    return {
      role: "presentation",
      hidden: !mounted,
      style: {
        ...positioning.positionerStyles,
        ...hiddenStyles
      }
    };
  }, [open, mounted, positioning.positionerStyles]);
  const state = React135.useMemo(() => ({
    open,
    side: positioning.side,
    align: positioning.align,
    anchorHidden: positioning.anchorHidden
  }), [open, positioning.side, positioning.align, positioning.anchorHidden]);
  const contextValue = React135.useMemo(() => ({
    side: positioning.side,
    align: positioning.align,
    arrowRef: positioning.arrowRef,
    arrowUncentered: positioning.arrowUncentered,
    arrowStyles: positioning.arrowStyles
  }), [positioning.side, positioning.align, positioning.arrowRef, positioning.arrowUncentered, positioning.arrowStyles]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [setPositionerElement, forwardedRef],
    props: [defaultProps, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return (0, import_jsx_runtime50.jsx)(PreviewCardPositionerContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) PreviewCardPositioner.displayName = "PreviewCardPositioner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/popup/PreviewCardPopup.js
var React136 = __toESM(require_react(), 1);
var stateAttributesMapping18 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var PreviewCardPopup = React136.forwardRef(function PreviewCardPopup2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    open,
    transitionStatus,
    popupRef,
    onOpenChangeComplete,
    popupProps
  } = usePreviewCardRootContext();
  const {
    side,
    align
  } = usePreviewCardPositionerContext();
  useOpenChangeComplete({
    open,
    ref: popupRef,
    onComplete() {
      if (open) {
        onOpenChangeComplete == null ? void 0 : onOpenChangeComplete(true);
      }
    }
  });
  const state = React136.useMemo(() => ({
    open,
    side,
    align,
    transitionStatus
  }), [open, side, align, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    ref: [popupRef, forwardedRef],
    state,
    props: [popupProps, transitionStatus === "starting" ? DISABLED_TRANSITIONS_STYLE : EMPTY_OBJECT, elementProps],
    stateAttributesMapping: stateAttributesMapping18
  });
  return element;
});
if (true) PreviewCardPopup.displayName = "PreviewCardPopup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/arrow/PreviewCardArrow.js
var React137 = __toESM(require_react(), 1);
var PreviewCardArrow = React137.forwardRef(function PreviewCardArrow2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    open
  } = usePreviewCardRootContext();
  const {
    arrowRef,
    side,
    align,
    arrowUncentered,
    arrowStyles
  } = usePreviewCardPositionerContext();
  const state = React137.useMemo(() => ({
    open,
    side,
    align,
    uncentered: arrowUncentered
  }), [open, side, align, arrowUncentered]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [arrowRef, forwardedRef],
    props: [{
      style: arrowStyles,
      "aria-hidden": true
    }, elementProps],
    stateAttributesMapping: popupStateMapping
  });
  return element;
});
if (true) PreviewCardArrow.displayName = "PreviewCardArrow";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/preview-card/backdrop/PreviewCardBackdrop.js
var React138 = __toESM(require_react(), 1);
var stateAttributesMapping19 = {
  ...popupStateMapping,
  ...transitionStatusMapping
};
var PreviewCardBackdrop = React138.forwardRef(function PreviewCardBackdrop2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    open,
    mounted,
    transitionStatus
  } = usePreviewCardRootContext();
  const state = React138.useMemo(() => ({
    open,
    transitionStatus
  }), [open, transitionStatus]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef],
    props: [{
      role: "presentation",
      hidden: !mounted,
      style: {
        pointerEvents: "none",
        userSelect: "none",
        WebkitUserSelect: "none"
      }
    }, elementProps],
    stateAttributesMapping: stateAttributesMapping19
  });
  return element;
});
if (true) PreviewCardBackdrop.displayName = "PreviewCardBackdrop";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/index.parts.js
var index_parts_exports23 = {};
__export(index_parts_exports23, {
  Indicator: () => ProgressIndicator,
  Label: () => ProgressLabel,
  Root: () => ProgressRoot,
  Track: () => ProgressTrack,
  Value: () => ProgressValue
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/root/ProgressRoot.js
var React140 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/root/ProgressRootContext.js
var React139 = __toESM(require_react(), 1);
var ProgressRootContext = React139.createContext(void 0);
if (true) ProgressRootContext.displayName = "ProgressRootContext";
function useProgressRootContext() {
  const context = React139.useContext(ProgressRootContext);
  if (context === void 0) {
    throw new Error("Base UI: ProgressRootContext is missing. Progress parts must be placed within <Progress.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/root/ProgressRootDataAttributes.js
var ProgressRootDataAttributes = (function(ProgressRootDataAttributes2) {
  ProgressRootDataAttributes2["complete"] = "data-complete";
  ProgressRootDataAttributes2["indeterminate"] = "data-indeterminate";
  ProgressRootDataAttributes2["progressing"] = "data-progressing";
  return ProgressRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/root/stateAttributesMapping.js
var progressStateAttributesMapping = {
  status(value) {
    if (value === "progressing") {
      return {
        [ProgressRootDataAttributes.progressing]: ""
      };
    }
    if (value === "complete") {
      return {
        [ProgressRootDataAttributes.complete]: ""
      };
    }
    if (value === "indeterminate") {
      return {
        [ProgressRootDataAttributes.indeterminate]: ""
      };
    }
    return null;
  }
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/root/ProgressRoot.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
function formatValue(value, locale, format) {
  if (value == null) {
    return "";
  }
  if (!format) {
    return formatNumber(value / 100, locale, {
      style: "percent"
    });
  }
  return formatNumber(value, locale, format);
}
function getDefaultAriaValueText(formattedValue, value) {
  if (value == null) {
    return "indeterminate progress";
  }
  return formattedValue || `${value}%`;
}
var ProgressRoot = React140.forwardRef(function ProgressRoot2(componentProps, forwardedRef) {
  const {
    format,
    getAriaValueText = getDefaultAriaValueText,
    locale,
    max = 100,
    min = 0,
    value,
    render,
    className,
    ...elementProps
  } = componentProps;
  const [labelId, setLabelId] = React140.useState();
  const formatOptionsRef = useLatestRef(format);
  let status = "indeterminate";
  if (Number.isFinite(value)) {
    status = value === max ? "complete" : "progressing";
  }
  const formattedValue = formatValue(value, locale, formatOptionsRef.current);
  const state = React140.useMemo(() => ({
    status
  }), [status]);
  const defaultProps = {
    "aria-labelledby": labelId,
    "aria-valuemax": max,
    "aria-valuemin": min,
    "aria-valuenow": value ?? void 0,
    "aria-valuetext": getAriaValueText(formattedValue, value),
    role: "progressbar"
  };
  const contextValue = React140.useMemo(() => ({
    formattedValue,
    max,
    min,
    setLabelId,
    state,
    status,
    value
  }), [formattedValue, max, min, setLabelId, state, status, value]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [defaultProps, elementProps],
    stateAttributesMapping: progressStateAttributesMapping
  });
  return (0, import_jsx_runtime51.jsx)(ProgressRootContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) ProgressRoot.displayName = "ProgressRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/track/ProgressTrack.js
var React141 = __toESM(require_react(), 1);
var ProgressTrack = React141.forwardRef(function ProgressTrack2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useProgressRootContext();
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: elementProps,
    stateAttributesMapping: progressStateAttributesMapping
  });
  return element;
});
if (true) ProgressTrack.displayName = "ProgressTrack";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/indicator/ProgressIndicator.js
var React142 = __toESM(require_react(), 1);
var ProgressIndicator = React142.forwardRef(function ProgressIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    max,
    min,
    value,
    state
  } = useProgressRootContext();
  const percentageValue = Number.isFinite(value) && value !== null ? valueToPercent(value, min, max) : null;
  const getStyles = React142.useCallback(() => {
    if (percentageValue == null) {
      return {};
    }
    return {
      insetInlineStart: 0,
      height: "inherit",
      width: `${percentageValue}%`
    };
  }, [percentageValue]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      style: getStyles()
    }, elementProps],
    stateAttributesMapping: progressStateAttributesMapping
  });
  return element;
});
if (true) ProgressIndicator.displayName = "ProgressIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/value/ProgressValue.js
var React143 = __toESM(require_react(), 1);
var ProgressValue = React143.forwardRef(function ProgressValue2(componentProps, forwardedRef) {
  const {
    className,
    render,
    children,
    ...elementProps
  } = componentProps;
  const {
    value,
    formattedValue,
    state
  } = useProgressRootContext();
  const formattedValueArg = value == null ? "indeterminate" : formattedValue;
  const formattedValueDisplay = value == null ? null : formattedValue;
  const element = useRenderElement("span", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      "aria-hidden": true,
      children: typeof children === "function" ? children(formattedValueArg, value) : formattedValueDisplay
    }, elementProps],
    stateAttributesMapping: progressStateAttributesMapping
  });
  return element;
});
if (true) ProgressValue.displayName = "ProgressValue";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/progress/label/ProgressLabel.js
var React144 = __toESM(require_react(), 1);
var ProgressLabel = React144.forwardRef(function ProgressLabel2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const {
    setLabelId,
    state
  } = useProgressRootContext();
  useIsoLayoutEffect(() => {
    setLabelId(id);
    return () => setLabelId(void 0);
  }, [id, setLabelId]);
  const element = useRenderElement("span", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      id
    }, elementProps],
    stateAttributesMapping: progressStateAttributesMapping
  });
  return element;
});
if (true) ProgressLabel.displayName = "ProgressLabel";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/index.parts.js
var index_parts_exports24 = {};
__export(index_parts_exports24, {
  Indicator: () => RadioIndicator,
  Root: () => RadioRoot
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/root/RadioRoot.js
var React147 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/root/RadioRootDataAttributes.js
var RadioRootDataAttributes = (function(RadioRootDataAttributes2) {
  RadioRootDataAttributes2["checked"] = "data-checked";
  RadioRootDataAttributes2["unchecked"] = "data-unchecked";
  RadioRootDataAttributes2["disabled"] = "data-disabled";
  RadioRootDataAttributes2["readonly"] = "data-readonly";
  RadioRootDataAttributes2["required"] = "data-required";
  RadioRootDataAttributes2["valid"] = "data-valid";
  RadioRootDataAttributes2["invalid"] = "data-invalid";
  RadioRootDataAttributes2["touched"] = "data-touched";
  RadioRootDataAttributes2["dirty"] = "data-dirty";
  RadioRootDataAttributes2["filled"] = "data-filled";
  RadioRootDataAttributes2["focused"] = "data-focused";
  return RadioRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/utils/stateAttributesMapping.js
var stateAttributesMapping20 = {
  checked(value) {
    if (value) {
      return {
        [RadioRootDataAttributes.checked]: ""
      };
    }
    return {
      [RadioRootDataAttributes.unchecked]: ""
    };
  },
  ...transitionStatusMapping,
  ...fieldValidityMapping
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio-group/RadioGroupContext.js
var React145 = __toESM(require_react(), 1);
var RadioGroupContext = React145.createContext({
  disabled: void 0,
  readOnly: void 0,
  required: void 0,
  name: void 0,
  checkedValue: "",
  setCheckedValue: NOOP,
  onValueChange: NOOP,
  touched: false,
  setTouched: NOOP,
  registerControlRef: NOOP
});
if (true) RadioGroupContext.displayName = "RadioGroupContext";
function useRadioGroupContext() {
  return React145.useContext(RadioGroupContext);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/root/RadioRootContext.js
var React146 = __toESM(require_react(), 1);
var RadioRootContext = React146.createContext(void 0);
if (true) RadioRootContext.displayName = "RadioRootContext";
function useRadioRootContext() {
  const value = React146.useContext(RadioRootContext);
  if (value === void 0) {
    throw new Error("Base UI: RadioRootContext is missing. Radio parts must be placed within <Radio.Root>.");
  }
  return value;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/root/RadioRoot.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var RadioRoot = React147.forwardRef(function RadioRoot2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    readOnly: readOnlyProp = false,
    required: requiredProp = false,
    value,
    inputRef: inputRefProp,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    disabled: disabledRoot,
    readOnly: readOnlyRoot,
    required: requiredRoot,
    checkedValue,
    setCheckedValue,
    touched,
    setTouched,
    fieldControlValidation,
    registerControlRef
  } = useRadioGroupContext();
  const {
    state: fieldState,
    disabled: fieldDisabled
  } = useFieldRootContext();
  const disabled = fieldDisabled || disabledRoot || disabledProp;
  const readOnly = readOnlyRoot || readOnlyProp;
  const required = requiredRoot || requiredProp;
  const {
    setDirty,
    validityData,
    setTouched: setFieldTouched,
    setFilled
  } = useFieldRootContext();
  const checked = checkedValue === value;
  const inputRef = React147.useRef(null);
  const ref = useMergedRefs(inputRefProp, inputRef);
  useIsoLayoutEffect(() => {
    var _a;
    if ((_a = inputRef.current) == null ? void 0 : _a.checked) {
      setFilled(true);
    }
  }, [setFilled]);
  const rootProps = React147.useMemo(() => ({
    role: "radio",
    "aria-checked": checked,
    "aria-required": required || void 0,
    "aria-disabled": disabled || void 0,
    "aria-readonly": readOnly || void 0,
    [ACTIVE_COMPOSITE_ITEM]: checked ? "" : void 0,
    disabled,
    onKeyDown(event) {
      if (event.key === "Enter") {
        event.preventDefault();
      }
    },
    onClick(event) {
      var _a;
      if (event.defaultPrevented || disabled || readOnly) {
        return;
      }
      event.preventDefault();
      (_a = inputRef.current) == null ? void 0 : _a.click();
    },
    onFocus(event) {
      var _a;
      if (event.defaultPrevented || disabled || readOnly || !touched) {
        return;
      }
      (_a = inputRef.current) == null ? void 0 : _a.click();
      setTouched(false);
    }
  }), [checked, required, disabled, readOnly, touched, setTouched]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const id = useBaseUiId();
  const inputProps = React147.useMemo(() => ({
    type: "radio",
    ref,
    // Set `id` to stop Chrome warning about an unassociated input
    id,
    tabIndex: -1,
    style: visuallyHidden,
    "aria-hidden": true,
    disabled,
    checked,
    required,
    readOnly,
    onChange(event) {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      if (disabled || readOnly || value === void 0) {
        return;
      }
      const details = createChangeEventDetails("none", event.nativeEvent);
      if (details.isCanceled) {
        return;
      }
      setFieldTouched(true);
      setDirty(value !== validityData.initialValue);
      setFilled(true);
      setCheckedValue(value, details);
    }
  }), [checked, disabled, id, readOnly, ref, required, setCheckedValue, setDirty, setFieldTouched, setFilled, validityData.initialValue, value]);
  const state = React147.useMemo(() => ({
    ...fieldState,
    required,
    disabled,
    readOnly,
    checked
  }), [fieldState, disabled, readOnly, checked, required]);
  const contextValue = React147.useMemo(() => state, [state]);
  const isRadioGroup = setCheckedValue !== NOOP;
  const refs = [forwardedRef, registerControlRef, buttonRef];
  const props = [rootProps, (fieldControlValidation == null ? void 0 : fieldControlValidation.getValidationProps) ?? EMPTY_OBJECT, elementProps, getButtonProps];
  const element = useRenderElement("button", componentProps, {
    enabled: !isRadioGroup,
    state,
    ref: refs,
    props,
    stateAttributesMapping: stateAttributesMapping20
  });
  return (0, import_jsx_runtime52.jsxs)(RadioRootContext.Provider, {
    value: contextValue,
    children: [isRadioGroup ? (0, import_jsx_runtime52.jsx)(CompositeItem, {
      tag: "button",
      render,
      className,
      state,
      refs,
      props,
      stateAttributesMapping: stateAttributesMapping20
    }) : element, (0, import_jsx_runtime52.jsx)("input", {
      ...inputProps
    })]
  });
});
if (true) RadioRoot.displayName = "RadioRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio/indicator/RadioIndicator.js
var React148 = __toESM(require_react(), 1);
var RadioIndicator = React148.forwardRef(function RadioIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const rootState = useRadioRootContext();
  const rendered = rootState.checked;
  const {
    transitionStatus,
    setMounted
  } = useTransitionStatus(rendered);
  const state = React148.useMemo(() => ({
    ...rootState,
    transitionStatus
  }), [rootState, transitionStatus]);
  const indicatorRef = React148.useRef(null);
  const shouldRender = keepMounted || rendered;
  const element = useRenderElement("span", componentProps, {
    enabled: shouldRender,
    ref: [forwardedRef, indicatorRef],
    state,
    props: elementProps,
    stateAttributesMapping: stateAttributesMapping20
  });
  useOpenChangeComplete({
    open: rendered,
    ref: indicatorRef,
    onComplete() {
      if (!rendered) {
        setMounted(false);
      }
    }
  });
  if (!shouldRender) {
    return null;
  }
  return element;
});
if (true) RadioIndicator.displayName = "RadioIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/radio-group/RadioGroup.js
var React149 = __toESM(require_react(), 1);
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var MODIFIER_KEYS = [SHIFT];
var RadioGroup = React149.forwardRef(function RadioGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp,
    readOnly,
    required,
    onValueChange: onValueChangeProp,
    value: externalValue,
    defaultValue,
    name: nameProp,
    inputRef: inputRefProp,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    labelId,
    setTouched: setFieldTouched,
    setFocused,
    validationMode,
    name: fieldName,
    disabled: fieldDisabled,
    state: fieldState
  } = useFieldRootContext();
  const fieldControlValidation = useFieldControlValidation();
  const {
    clearErrors
  } = useFormContext();
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const id = useBaseUiId(idProp);
  const [checkedValue, setCheckedValueUnwrapped] = useControlled({
    controlled: externalValue,
    default: defaultValue,
    name: "RadioGroup",
    state: "value"
  });
  const onValueChange = useEventCallback(onValueChangeProp);
  const setCheckedValue = useEventCallback((value, eventDetails) => {
    onValueChange(value, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setCheckedValueUnwrapped(value);
  });
  const controlRef = React149.useRef(null);
  const registerControlRef = useEventCallback((element) => {
    if (controlRef.current == null && element != null) {
      controlRef.current = element;
    }
  });
  useField({
    id,
    commitValidation: fieldControlValidation.commitValidation,
    value: checkedValue,
    controlRef,
    name,
    getValue: () => checkedValue ?? null
  });
  const prevValueRef = React149.useRef(checkedValue);
  useIsoLayoutEffect(() => {
    if (prevValueRef.current === checkedValue) {
      return;
    }
    clearErrors(name);
    if (validationMode === "onChange") {
      fieldControlValidation.commitValidation(checkedValue);
    } else {
      fieldControlValidation.commitValidation(checkedValue, true);
    }
  }, [name, clearErrors, validationMode, checkedValue, fieldControlValidation]);
  useIsoLayoutEffect(() => {
    prevValueRef.current = checkedValue;
  }, [checkedValue]);
  const [touched, setTouched] = React149.useState(false);
  const onBlur = useEventCallback((event) => {
    if (!contains(event.currentTarget, event.relatedTarget)) {
      setFieldTouched(true);
      setFocused(false);
      if (validationMode === "onBlur") {
        fieldControlValidation.commitValidation(checkedValue);
      }
    }
  });
  const onKeyDownCapture = useEventCallback((event) => {
    if (event.key.startsWith("Arrow")) {
      setFieldTouched(true);
      setTouched(true);
      setFocused(true);
    }
  });
  const serializedCheckedValue = React149.useMemo(() => {
    if (checkedValue == null) {
      return "";
    }
    if (typeof checkedValue === "string") {
      return checkedValue;
    }
    return JSON.stringify(checkedValue);
  }, [checkedValue]);
  const mergedInputRef = useMergedRefs(fieldControlValidation.inputRef, inputRefProp);
  const inputProps = mergeProps({
    value: serializedCheckedValue,
    ref: mergedInputRef,
    id,
    name: serializedCheckedValue ? name : void 0,
    disabled,
    readOnly,
    required,
    "aria-hidden": true,
    tabIndex: -1,
    style: visuallyHidden,
    onFocus() {
      var _a;
      (_a = controlRef.current) == null ? void 0 : _a.focus();
    }
  }, fieldControlValidation.getInputValidationProps);
  const state = React149.useMemo(() => ({
    ...fieldState,
    disabled: disabled ?? false,
    required: required ?? false,
    readOnly: readOnly ?? false
  }), [fieldState, disabled, readOnly, required]);
  const contextValue = React149.useMemo(() => ({
    ...fieldState,
    checkedValue,
    disabled,
    name,
    onValueChange,
    readOnly,
    registerControlRef,
    required,
    setCheckedValue,
    setTouched,
    touched
  }), [checkedValue, disabled, fieldState, name, onValueChange, readOnly, registerControlRef, required, setCheckedValue, setTouched, touched]);
  const defaultProps = {
    role: "radiogroup",
    "aria-required": required || void 0,
    "aria-disabled": disabled || void 0,
    "aria-readonly": readOnly || void 0,
    "aria-labelledby": labelId,
    onFocus() {
      setFocused(true);
    },
    onBlur,
    onKeyDownCapture
  };
  return (0, import_jsx_runtime53.jsxs)(RadioGroupContext.Provider, {
    value: contextValue,
    children: [(0, import_jsx_runtime53.jsx)(CompositeRoot, {
      render,
      className,
      state,
      props: [defaultProps, fieldControlValidation.getValidationProps, elementProps],
      refs: [forwardedRef],
      stateAttributesMapping: fieldValidityMapping,
      enableHomeAndEndKeys: false,
      modifierKeys: MODIFIER_KEYS
    }), (0, import_jsx_runtime53.jsx)("input", {
      ...inputProps
    })]
  });
});
if (true) RadioGroup.displayName = "RadioGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/index.parts.js
var index_parts_exports25 = {};
__export(index_parts_exports25, {
  Content: () => ScrollAreaContent,
  Corner: () => ScrollAreaCorner,
  Root: () => ScrollAreaRoot,
  Scrollbar: () => ScrollAreaScrollbar,
  Thumb: () => ScrollAreaThumb,
  Viewport: () => ScrollAreaViewport
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/root/ScrollAreaRoot.js
var React151 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/root/ScrollAreaRootContext.js
var React150 = __toESM(require_react(), 1);
var ScrollAreaRootContext = React150.createContext(void 0);
if (true) ScrollAreaRootContext.displayName = "ScrollAreaRootContext";
function useScrollAreaRootContext() {
  const context = React150.useContext(ScrollAreaRootContext);
  if (context === void 0) {
    throw new Error("Base UI: ScrollAreaRootContext is missing. ScrollArea parts must be placed within <ScrollArea.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/root/ScrollAreaRootCssVars.js
var ScrollAreaRootCssVars = (function(ScrollAreaRootCssVars2) {
  ScrollAreaRootCssVars2["scrollAreaCornerHeight"] = "--scroll-area-corner-height";
  ScrollAreaRootCssVars2["scrollAreaCornerWidth"] = "--scroll-area-corner-width";
  ScrollAreaRootCssVars2["scrollAreaOverflowXStart"] = "--scroll-area-overflow-x-start";
  ScrollAreaRootCssVars2["scrollAreaOverflowXEnd"] = "--scroll-area-overflow-x-end";
  ScrollAreaRootCssVars2["scrollAreaOverflowYStart"] = "--scroll-area-overflow-y-start";
  ScrollAreaRootCssVars2["scrollAreaOverflowYEnd"] = "--scroll-area-overflow-y-end";
  return ScrollAreaRootCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/constants.js
var SCROLL_TIMEOUT = 500;
var MIN_THUMB_SIZE = 16;

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/utils/getOffset.js
function getOffset(element, prop, axis) {
  if (!element) {
    return 0;
  }
  const styles = getComputedStyle(element);
  const propAxis = axis === "x" ? "Inline" : "Block";
  if (axis === "x" && prop === "margin") {
    return parseFloat(styles[`${prop}InlineStart`]) * 2;
  }
  return parseFloat(styles[`${prop}${propAxis}Start`]) + parseFloat(styles[`${prop}${propAxis}End`]);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/scrollbar/ScrollAreaScrollbarDataAttributes.js
var ScrollAreaScrollbarDataAttributes = (function(ScrollAreaScrollbarDataAttributes2) {
  ScrollAreaScrollbarDataAttributes2["orientation"] = "data-orientation";
  ScrollAreaScrollbarDataAttributes2["hovering"] = "data-hovering";
  ScrollAreaScrollbarDataAttributes2["scrolling"] = "data-scrolling";
  ScrollAreaScrollbarDataAttributes2["hasOverflowX"] = "data-has-overflow-x";
  ScrollAreaScrollbarDataAttributes2["hasOverflowY"] = "data-has-overflow-y";
  ScrollAreaScrollbarDataAttributes2["overflowXStart"] = "data-overflow-x-start";
  ScrollAreaScrollbarDataAttributes2["overflowXEnd"] = "data-overflow-x-end";
  ScrollAreaScrollbarDataAttributes2["overflowYStart"] = "data-overflow-y-start";
  ScrollAreaScrollbarDataAttributes2["overflowYEnd"] = "data-overflow-y-end";
  return ScrollAreaScrollbarDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/root/ScrollAreaRootDataAttributes.js
var ScrollAreaRootDataAttributes = (function(ScrollAreaRootDataAttributes2) {
  ScrollAreaRootDataAttributes2["hasOverflowX"] = "data-has-overflow-x";
  ScrollAreaRootDataAttributes2["hasOverflowY"] = "data-has-overflow-y";
  ScrollAreaRootDataAttributes2["overflowXStart"] = "data-overflow-x-start";
  ScrollAreaRootDataAttributes2["overflowXEnd"] = "data-overflow-x-end";
  ScrollAreaRootDataAttributes2["overflowYStart"] = "data-overflow-y-start";
  ScrollAreaRootDataAttributes2["overflowYEnd"] = "data-overflow-y-end";
  return ScrollAreaRootDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/root/stateAttributes.js
var scrollAreaStateAttributesMapping = {
  hasOverflowX: (value) => value ? {
    [ScrollAreaRootDataAttributes.hasOverflowX]: ""
  } : null,
  hasOverflowY: (value) => value ? {
    [ScrollAreaRootDataAttributes.hasOverflowY]: ""
  } : null,
  overflowXStart: (value) => value ? {
    [ScrollAreaRootDataAttributes.overflowXStart]: ""
  } : null,
  overflowXEnd: (value) => value ? {
    [ScrollAreaRootDataAttributes.overflowXEnd]: ""
  } : null,
  overflowYStart: (value) => value ? {
    [ScrollAreaRootDataAttributes.overflowYStart]: ""
  } : null,
  overflowYEnd: (value) => value ? {
    [ScrollAreaRootDataAttributes.overflowYEnd]: ""
  } : null,
  cornerHidden: () => null
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/root/ScrollAreaRoot.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE2 = {
  width: 0,
  height: 0
};
var DEFAULT_OVERFLOW_EDGES = {
  xStart: false,
  xEnd: false,
  yStart: false,
  yEnd: false
};
var ScrollAreaRoot = React151.forwardRef(function ScrollAreaRoot2(componentProps, forwardedRef) {
  const {
    render,
    className,
    overflowEdgeThreshold: overflowEdgeThresholdProp,
    ...elementProps
  } = componentProps;
  const [hovering, setHovering] = React151.useState(false);
  const [scrollingX, setScrollingX] = React151.useState(false);
  const [scrollingY, setScrollingY] = React151.useState(false);
  const [cornerSize, setCornerSize] = React151.useState(DEFAULT_SIZE2);
  const [thumbSize, setThumbSize] = React151.useState(DEFAULT_SIZE2);
  const [touchModality, setTouchModality] = React151.useState(false);
  const [overflowEdges, setOverflowEdges] = React151.useState(DEFAULT_OVERFLOW_EDGES);
  const rootId = useBaseUiId();
  const rootRef = React151.useRef(null);
  const viewportRef = React151.useRef(null);
  const scrollbarYRef = React151.useRef(null);
  const scrollbarXRef = React151.useRef(null);
  const thumbYRef = React151.useRef(null);
  const thumbXRef = React151.useRef(null);
  const cornerRef = React151.useRef(null);
  const thumbDraggingRef = React151.useRef(false);
  const startYRef = React151.useRef(0);
  const startXRef = React151.useRef(0);
  const startScrollTopRef = React151.useRef(0);
  const startScrollLeftRef = React151.useRef(0);
  const currentOrientationRef = React151.useRef("vertical");
  const scrollYTimeout = useTimeout();
  const scrollXTimeout = useTimeout();
  const scrollPositionRef = React151.useRef({
    x: 0,
    y: 0
  });
  const [hiddenState, setHiddenState] = React151.useState({
    scrollbarYHidden: false,
    scrollbarXHidden: false,
    cornerHidden: false
  });
  const overflowEdgeThreshold = normalizeOverflowEdgeThreshold(overflowEdgeThresholdProp);
  const handleScroll = useEventCallback((scrollPosition) => {
    const offsetX = scrollPosition.x - scrollPositionRef.current.x;
    const offsetY = scrollPosition.y - scrollPositionRef.current.y;
    scrollPositionRef.current = scrollPosition;
    if (offsetY !== 0) {
      setScrollingY(true);
      scrollYTimeout.start(SCROLL_TIMEOUT, () => {
        setScrollingY(false);
      });
    }
    if (offsetX !== 0) {
      setScrollingX(true);
      scrollXTimeout.start(SCROLL_TIMEOUT, () => {
        setScrollingX(false);
      });
    }
  });
  const handlePointerDown = useEventCallback((event) => {
    if (event.button !== 0) {
      return;
    }
    thumbDraggingRef.current = true;
    startYRef.current = event.clientY;
    startXRef.current = event.clientX;
    currentOrientationRef.current = event.currentTarget.getAttribute(ScrollAreaScrollbarDataAttributes.orientation);
    if (viewportRef.current) {
      startScrollTopRef.current = viewportRef.current.scrollTop;
      startScrollLeftRef.current = viewportRef.current.scrollLeft;
    }
    if (thumbYRef.current && currentOrientationRef.current === "vertical") {
      thumbYRef.current.setPointerCapture(event.pointerId);
    }
    if (thumbXRef.current && currentOrientationRef.current === "horizontal") {
      thumbXRef.current.setPointerCapture(event.pointerId);
    }
  });
  const handlePointerMove = useEventCallback((event) => {
    if (!thumbDraggingRef.current) {
      return;
    }
    const deltaY = event.clientY - startYRef.current;
    const deltaX = event.clientX - startXRef.current;
    if (viewportRef.current) {
      const scrollableContentHeight = viewportRef.current.scrollHeight;
      const viewportHeight = viewportRef.current.clientHeight;
      const scrollableContentWidth = viewportRef.current.scrollWidth;
      const viewportWidth = viewportRef.current.clientWidth;
      if (thumbYRef.current && scrollbarYRef.current && currentOrientationRef.current === "vertical") {
        const scrollbarYOffset = getOffset(scrollbarYRef.current, "padding", "y");
        const thumbYOffset = getOffset(thumbYRef.current, "margin", "y");
        const thumbHeight = thumbYRef.current.offsetHeight;
        const maxThumbOffsetY = scrollbarYRef.current.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;
        const scrollRatioY = deltaY / maxThumbOffsetY;
        viewportRef.current.scrollTop = startScrollTopRef.current + scrollRatioY * (scrollableContentHeight - viewportHeight);
        event.preventDefault();
        setScrollingY(true);
        scrollYTimeout.start(SCROLL_TIMEOUT, () => {
          setScrollingY(false);
        });
      }
      if (thumbXRef.current && scrollbarXRef.current && currentOrientationRef.current === "horizontal") {
        const scrollbarXOffset = getOffset(scrollbarXRef.current, "padding", "x");
        const thumbXOffset = getOffset(thumbXRef.current, "margin", "x");
        const thumbWidth = thumbXRef.current.offsetWidth;
        const maxThumbOffsetX = scrollbarXRef.current.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;
        const scrollRatioX = deltaX / maxThumbOffsetX;
        viewportRef.current.scrollLeft = startScrollLeftRef.current + scrollRatioX * (scrollableContentWidth - viewportWidth);
        event.preventDefault();
        setScrollingX(true);
        scrollXTimeout.start(SCROLL_TIMEOUT, () => {
          setScrollingX(false);
        });
      }
    }
  });
  const handlePointerUp = useEventCallback((event) => {
    thumbDraggingRef.current = false;
    if (thumbYRef.current && currentOrientationRef.current === "vertical") {
      thumbYRef.current.releasePointerCapture(event.pointerId);
    }
    if (thumbXRef.current && currentOrientationRef.current === "horizontal") {
      thumbXRef.current.releasePointerCapture(event.pointerId);
    }
  });
  function handlePointerEnterOrMove(event) {
    const isTouch = event.pointerType === "touch";
    setTouchModality(isTouch);
    if (!isTouch) {
      const isTargetRootChild = contains(rootRef.current, event.target);
      setHovering(isTargetRootChild);
    }
  }
  const state = React151.useMemo(() => ({
    hasOverflowX: !hiddenState.scrollbarXHidden,
    hasOverflowY: !hiddenState.scrollbarYHidden,
    overflowXStart: overflowEdges.xStart,
    overflowXEnd: overflowEdges.xEnd,
    overflowYStart: overflowEdges.yStart,
    overflowYEnd: overflowEdges.yEnd,
    cornerHidden: hiddenState.cornerHidden
  }), [hiddenState.scrollbarXHidden, hiddenState.scrollbarYHidden, hiddenState.cornerHidden, overflowEdges]);
  const props = {
    role: "presentation",
    onPointerEnter: handlePointerEnterOrMove,
    onPointerMove: handlePointerEnterOrMove,
    onPointerDown({
      pointerType
    }) {
      setTouchModality(pointerType === "touch");
    },
    onPointerLeave() {
      setHovering(false);
    },
    style: {
      position: "relative",
      [ScrollAreaRootCssVars.scrollAreaCornerHeight]: `${cornerSize.height}px`,
      [ScrollAreaRootCssVars.scrollAreaCornerWidth]: `${cornerSize.width}px`
    }
  };
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, rootRef],
    props: [props, elementProps],
    stateAttributesMapping: scrollAreaStateAttributesMapping
  });
  const contextValue = React151.useMemo(() => ({
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    handleScroll,
    cornerSize,
    setCornerSize,
    thumbSize,
    setThumbSize,
    touchModality,
    cornerRef,
    scrollingX,
    setScrollingX,
    scrollingY,
    setScrollingY,
    hovering,
    setHovering,
    viewportRef,
    rootRef,
    scrollbarYRef,
    scrollbarXRef,
    thumbYRef,
    thumbXRef,
    rootId,
    hiddenState,
    setHiddenState,
    overflowEdges,
    setOverflowEdges,
    viewportState: state,
    overflowEdgeThreshold
  }), [handlePointerDown, handlePointerMove, handlePointerUp, handleScroll, cornerSize, thumbSize, touchModality, cornerRef, scrollingX, setScrollingX, scrollingY, setScrollingY, hovering, setHovering, viewportRef, rootRef, scrollbarYRef, scrollbarXRef, thumbYRef, thumbXRef, rootId, hiddenState, overflowEdges, state, overflowEdgeThreshold]);
  return (0, import_jsx_runtime54.jsxs)(ScrollAreaRootContext.Provider, {
    value: contextValue,
    children: [styleDisableScrollbar.element, element]
  });
});
if (true) ScrollAreaRoot.displayName = "ScrollAreaRoot";
function normalizeOverflowEdgeThreshold(threshold) {
  if (typeof threshold === "number") {
    const value = Math.max(0, threshold);
    return {
      xStart: value,
      xEnd: value,
      yStart: value,
      yEnd: value
    };
  }
  return {
    xStart: Math.max(0, (threshold == null ? void 0 : threshold.xStart) || 0),
    xEnd: Math.max(0, (threshold == null ? void 0 : threshold.xEnd) || 0),
    yStart: Math.max(0, (threshold == null ? void 0 : threshold.yStart) || 0),
    yEnd: Math.max(0, (threshold == null ? void 0 : threshold.yEnd) || 0)
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/viewport/ScrollAreaViewport.js
var React153 = __toESM(require_react(), 1);
var ReactDOM10 = __toESM(require_react_dom(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/viewport/ScrollAreaViewportContext.js
var React152 = __toESM(require_react(), 1);
var ScrollAreaViewportContext = React152.createContext(void 0);
if (true) ScrollAreaViewportContext.displayName = "ScrollAreaViewportContext";
function useScrollAreaViewportContext() {
  const context = React152.useContext(ScrollAreaViewportContext);
  if (context === void 0) {
    throw new Error("Base UI: ScrollAreaViewportContext missing. ScrollAreaViewport parts must be placed within <ScrollArea.Viewport>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/utils/onVisible.js
function onVisible(element, callback) {
  if (typeof IntersectionObserver === "undefined") {
    return () => {
    };
  }
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.intersectionRatio > 0) {
        callback();
        observer.disconnect();
      }
    });
  });
  observer.observe(element);
  return () => {
    observer.disconnect();
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/viewport/ScrollAreaViewport.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var ScrollAreaViewport = React153.forwardRef(function ScrollAreaViewport2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    viewportRef,
    rootRef,
    scrollbarYRef,
    scrollbarXRef,
    thumbYRef,
    thumbXRef,
    cornerRef,
    setCornerSize,
    setThumbSize,
    rootId,
    setHiddenState,
    hiddenState,
    handleScroll,
    setHovering,
    setOverflowEdges,
    overflowEdges,
    overflowEdgeThreshold
  } = useScrollAreaRootContext();
  const direction = useDirection();
  const programmaticScrollRef = React153.useRef(true);
  const scrollEndTimeout = useTimeout();
  function computeThumbPositionHandler() {
    const viewportEl = viewportRef.current;
    const scrollbarYEl = scrollbarYRef.current;
    const scrollbarXEl = scrollbarXRef.current;
    const thumbYEl = thumbYRef.current;
    const thumbXEl = thumbXRef.current;
    const cornerEl = cornerRef.current;
    if (!viewportEl) {
      return;
    }
    const scrollableContentHeight = viewportEl.scrollHeight;
    const scrollableContentWidth = viewportEl.scrollWidth;
    const viewportHeight = viewportEl.clientHeight;
    const viewportWidth = viewportEl.clientWidth;
    const scrollTop = viewportEl.scrollTop;
    const scrollLeft = viewportEl.scrollLeft;
    if (scrollableContentHeight === 0 || scrollableContentWidth === 0) {
      return;
    }
    const scrollbarYHidden = viewportHeight >= scrollableContentHeight;
    const scrollbarXHidden = viewportWidth >= scrollableContentWidth;
    const ratioX = viewportWidth / scrollableContentWidth;
    const ratioY = viewportHeight / scrollableContentHeight;
    const maxScrollLeft = Math.max(0, scrollableContentWidth - viewportWidth);
    const maxScrollTop = Math.max(0, scrollableContentHeight - viewportHeight);
    let scrollLeftFromStart = 0;
    let scrollLeftFromEnd = 0;
    if (!scrollbarXHidden) {
      if (direction === "rtl") {
        scrollLeftFromStart = clamp(-scrollLeft, 0, maxScrollLeft);
      } else {
        scrollLeftFromStart = clamp(scrollLeft, 0, maxScrollLeft);
      }
      scrollLeftFromEnd = maxScrollLeft - scrollLeftFromStart;
    }
    const scrollTopFromStart = !scrollbarYHidden ? clamp(scrollTop, 0, maxScrollTop) : 0;
    const scrollTopFromEnd = !scrollbarYHidden ? maxScrollTop - scrollTopFromStart : 0;
    const nextWidth = scrollbarXHidden ? 0 : viewportWidth;
    const nextHeight = scrollbarYHidden ? 0 : viewportHeight;
    const scrollbarXOffset = getOffset(scrollbarXEl, "padding", "x");
    const scrollbarYOffset = getOffset(scrollbarYEl, "padding", "y");
    const thumbXOffset = getOffset(thumbXEl, "margin", "x");
    const thumbYOffset = getOffset(thumbYEl, "margin", "y");
    const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;
    const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;
    const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;
    const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;
    const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);
    const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);
    setThumbSize((prevSize) => {
      if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {
        return prevSize;
      }
      return {
        width: clampedNextWidth,
        height: clampedNextHeight
      };
    });
    if (scrollbarYEl && thumbYEl) {
      const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;
      const scrollRangeY = scrollableContentHeight - viewportHeight;
      const scrollRatioY = scrollRangeY === 0 ? 0 : scrollTop / scrollRangeY;
      const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));
      thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;
    }
    if (scrollbarXEl && thumbXEl) {
      const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;
      const scrollRangeX = scrollableContentWidth - viewportWidth;
      const scrollRatioX = scrollRangeX === 0 ? 0 : scrollLeft / scrollRangeX;
      const thumbOffsetX = direction === "rtl" ? clamp(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : clamp(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);
      thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;
    }
    const clampedScrollLeftStart = clamp(scrollLeftFromStart, 0, maxScrollLeft);
    const clampedScrollLeftEnd = clamp(scrollLeftFromEnd, 0, maxScrollLeft);
    const clampedScrollTopStart = clamp(scrollTopFromStart, 0, maxScrollTop);
    const clampedScrollTopEnd = clamp(scrollTopFromEnd, 0, maxScrollTop);
    const overflowMetricsPx = [[ScrollAreaRootCssVars.scrollAreaOverflowXStart, clampedScrollLeftStart], [ScrollAreaRootCssVars.scrollAreaOverflowXEnd, clampedScrollLeftEnd], [ScrollAreaRootCssVars.scrollAreaOverflowYStart, clampedScrollTopStart], [ScrollAreaRootCssVars.scrollAreaOverflowYEnd, clampedScrollTopEnd]];
    const rootEl = rootRef.current;
    if (rootEl) {
      for (const [cssVar, value] of overflowMetricsPx) {
        rootEl.style.setProperty(cssVar, `${value}px`);
      }
    }
    if (cornerEl) {
      if (scrollbarXHidden || scrollbarYHidden) {
        setCornerSize({
          width: 0,
          height: 0
        });
      } else if (!scrollbarXHidden && !scrollbarYHidden) {
        const width = (scrollbarYEl == null ? void 0 : scrollbarYEl.offsetWidth) || 0;
        const height = (scrollbarXEl == null ? void 0 : scrollbarXEl.offsetHeight) || 0;
        setCornerSize({
          width,
          height
        });
      }
    }
    setHiddenState((prevState) => {
      const cornerHidden = scrollbarYHidden || scrollbarXHidden;
      if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {
        return prevState;
      }
      return {
        scrollbarYHidden,
        scrollbarXHidden,
        cornerHidden
      };
    });
    const nextOverflowEdges = {
      xStart: !scrollbarXHidden && clampedScrollLeftStart > overflowEdgeThreshold.xStart,
      xEnd: !scrollbarXHidden && clampedScrollLeftEnd > overflowEdgeThreshold.xEnd,
      yStart: !scrollbarYHidden && clampedScrollTopStart > overflowEdgeThreshold.yStart,
      yEnd: !scrollbarYHidden && clampedScrollTopEnd > overflowEdgeThreshold.yEnd
    };
    setOverflowEdges((prev) => {
      if (prev.xStart === nextOverflowEdges.xStart && prev.xEnd === nextOverflowEdges.xEnd && prev.yStart === nextOverflowEdges.yStart && prev.yEnd === nextOverflowEdges.yEnd) {
        return prev;
      }
      return nextOverflowEdges;
    });
  }
  const computeThumbPosition = useEventCallback(() => {
    ReactDOM10.flushSync(computeThumbPositionHandler);
  });
  useIsoLayoutEffect(() => {
    if (!viewportRef.current) {
      return void 0;
    }
    const cleanup = onVisible(viewportRef.current, computeThumbPosition);
    return cleanup;
  }, [computeThumbPosition, viewportRef]);
  useIsoLayoutEffect(() => {
    queueMicrotask(computeThumbPosition);
  }, [computeThumbPosition, hiddenState, direction]);
  useIsoLayoutEffect(() => {
    var _a;
    if ((_a = viewportRef.current) == null ? void 0 : _a.matches(":hover")) {
      setHovering(true);
    }
  }, [viewportRef, setHovering]);
  React153.useEffect(() => {
    if (typeof ResizeObserver === "undefined") {
      return void 0;
    }
    const ro = new ResizeObserver(computeThumbPosition);
    if (viewportRef.current) {
      ro.observe(viewportRef.current);
    }
    return () => {
      ro.disconnect();
    };
  }, [computeThumbPosition, viewportRef]);
  const handleUserInteraction = useEventCallback(() => {
    programmaticScrollRef.current = false;
  });
  const props = {
    role: "presentation",
    ...rootId && {
      "data-id": `${rootId}-viewport`
    },
    // https://accessibilityinsights.io/info-examples/web/scrollable-region-focusable/
    ...(!hiddenState.scrollbarXHidden || !hiddenState.scrollbarYHidden) && {
      tabIndex: 0
    },
    className: styleDisableScrollbar.className,
    style: {
      overflow: "scroll"
    },
    onScroll() {
      if (!viewportRef.current) {
        return;
      }
      computeThumbPosition();
      if (!programmaticScrollRef.current) {
        handleScroll({
          x: viewportRef.current.scrollLeft,
          y: viewportRef.current.scrollTop
        });
      }
      scrollEndTimeout.start(100, () => {
        programmaticScrollRef.current = true;
      });
    },
    onWheel: handleUserInteraction,
    onTouchMove: handleUserInteraction,
    onPointerMove: handleUserInteraction,
    onPointerEnter: handleUserInteraction,
    onKeyDown: handleUserInteraction
  };
  const viewportState = React153.useMemo(() => ({
    hasOverflowX: !hiddenState.scrollbarXHidden,
    hasOverflowY: !hiddenState.scrollbarYHidden,
    overflowXStart: overflowEdges.xStart,
    overflowXEnd: overflowEdges.xEnd,
    overflowYStart: overflowEdges.yStart,
    overflowYEnd: overflowEdges.yEnd,
    cornerHidden: hiddenState.cornerHidden
  }), [hiddenState.scrollbarXHidden, hiddenState.scrollbarYHidden, hiddenState.cornerHidden, overflowEdges]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, viewportRef],
    state: viewportState,
    props: [props, elementProps],
    stateAttributesMapping: scrollAreaStateAttributesMapping
  });
  const contextValue = React153.useMemo(() => ({
    computeThumbPosition
  }), [computeThumbPosition]);
  return (0, import_jsx_runtime55.jsx)(ScrollAreaViewportContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) ScrollAreaViewport.displayName = "ScrollAreaViewport";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/scrollbar/ScrollAreaScrollbar.js
var React155 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/scrollbar/ScrollAreaScrollbarContext.js
var React154 = __toESM(require_react(), 1);
var ScrollAreaScrollbarContext = React154.createContext(void 0);
if (true) ScrollAreaScrollbarContext.displayName = "ScrollAreaScrollbarContext";
function useScrollAreaScrollbarContext() {
  const context = React154.useContext(ScrollAreaScrollbarContext);
  if (context === void 0) {
    throw new Error("Base UI: ScrollAreaScrollbarContext is missing. ScrollAreaScrollbar parts must be placed within <ScrollArea.Scrollbar>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/scrollbar/ScrollAreaScrollbarCssVars.js
var ScrollAreaScrollbarCssVars = (function(ScrollAreaScrollbarCssVars2) {
  ScrollAreaScrollbarCssVars2["scrollAreaThumbHeight"] = "--scroll-area-thumb-height";
  ScrollAreaScrollbarCssVars2["scrollAreaThumbWidth"] = "--scroll-area-thumb-width";
  return ScrollAreaScrollbarCssVars2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/scrollbar/ScrollAreaScrollbar.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var ScrollAreaScrollbar = React155.forwardRef(function ScrollAreaScrollbar2(componentProps, forwardedRef) {
  const {
    render,
    className,
    orientation = "vertical",
    keepMounted = false,
    ...elementProps
  } = componentProps;
  const {
    hovering,
    scrollingX,
    scrollingY,
    hiddenState,
    overflowEdges,
    scrollbarYRef,
    scrollbarXRef,
    viewportRef,
    thumbYRef,
    thumbXRef,
    handlePointerDown,
    handlePointerUp,
    rootId,
    thumbSize
  } = useScrollAreaRootContext();
  const state = React155.useMemo(() => ({
    hovering,
    scrolling: {
      horizontal: scrollingX,
      vertical: scrollingY
    }[orientation],
    orientation,
    hasOverflowX: !hiddenState.scrollbarXHidden,
    hasOverflowY: !hiddenState.scrollbarYHidden,
    overflowXStart: overflowEdges.xStart,
    overflowXEnd: overflowEdges.xEnd,
    overflowYStart: overflowEdges.yStart,
    overflowYEnd: overflowEdges.yEnd,
    cornerHidden: hiddenState.cornerHidden
  }), [hovering, scrollingX, scrollingY, orientation, hiddenState, overflowEdges]);
  const direction = useDirection();
  React155.useEffect(() => {
    const viewportEl = viewportRef.current;
    const scrollbarEl = orientation === "vertical" ? scrollbarYRef.current : scrollbarXRef.current;
    if (!scrollbarEl) {
      return void 0;
    }
    function handleWheel(event) {
      if (!viewportEl || !scrollbarEl || event.ctrlKey) {
        return;
      }
      event.preventDefault();
      if (orientation === "vertical") {
        if (viewportEl.scrollTop === 0 && event.deltaY < 0) {
          return;
        }
      } else if (viewportEl.scrollLeft === 0 && event.deltaX < 0) {
        return;
      }
      if (orientation === "vertical") {
        if (viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0) {
          return;
        }
      } else if (viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0) {
        return;
      }
      if (orientation === "vertical") {
        viewportEl.scrollTop += event.deltaY;
      } else {
        viewportEl.scrollLeft += event.deltaX;
      }
    }
    scrollbarEl.addEventListener("wheel", handleWheel, {
      passive: false
    });
    return () => {
      scrollbarEl.removeEventListener("wheel", handleWheel);
    };
  }, [orientation, scrollbarXRef, scrollbarYRef, viewportRef]);
  const props = {
    ...rootId && {
      "data-id": `${rootId}-scrollbar`
    },
    onPointerDown(event) {
      if (event.button !== 0) {
        return;
      }
      if (event.currentTarget !== event.target) {
        return;
      }
      if (!viewportRef.current) {
        return;
      }
      if (thumbYRef.current && scrollbarYRef.current && orientation === "vertical") {
        const thumbYOffset = getOffset(thumbYRef.current, "margin", "y");
        const scrollbarYOffset = getOffset(scrollbarYRef.current, "padding", "y");
        const thumbHeight = thumbYRef.current.offsetHeight;
        const trackRectY = scrollbarYRef.current.getBoundingClientRect();
        const clickY = event.clientY - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;
        const scrollableContentHeight = viewportRef.current.scrollHeight;
        const viewportHeight = viewportRef.current.clientHeight;
        const maxThumbOffsetY = scrollbarYRef.current.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;
        const scrollRatioY = clickY / maxThumbOffsetY;
        const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);
        viewportRef.current.scrollTop = newScrollTop;
      }
      if (thumbXRef.current && scrollbarXRef.current && orientation === "horizontal") {
        const thumbXOffset = getOffset(thumbXRef.current, "margin", "x");
        const scrollbarXOffset = getOffset(scrollbarXRef.current, "padding", "x");
        const thumbWidth = thumbXRef.current.offsetWidth;
        const trackRectX = scrollbarXRef.current.getBoundingClientRect();
        const clickX = event.clientX - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;
        const scrollableContentWidth = viewportRef.current.scrollWidth;
        const viewportWidth = viewportRef.current.clientWidth;
        const maxThumbOffsetX = scrollbarXRef.current.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;
        const scrollRatioX = clickX / maxThumbOffsetX;
        let newScrollLeft;
        if (direction === "rtl") {
          newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);
          if (viewportRef.current.scrollLeft <= 0) {
            newScrollLeft = -newScrollLeft;
          }
        } else {
          newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);
        }
        viewportRef.current.scrollLeft = newScrollLeft;
      }
      handlePointerDown(event);
    },
    onPointerUp: handlePointerUp,
    style: {
      position: "absolute",
      touchAction: "none",
      WebkitUserSelect: "none",
      userSelect: "none",
      ...orientation === "vertical" && {
        top: 0,
        bottom: `var(${ScrollAreaRootCssVars.scrollAreaCornerHeight})`,
        insetInlineEnd: 0,
        [ScrollAreaScrollbarCssVars.scrollAreaThumbHeight]: `${thumbSize.height}px`
      },
      ...orientation === "horizontal" && {
        insetInlineStart: 0,
        insetInlineEnd: `var(${ScrollAreaRootCssVars.scrollAreaCornerWidth})`,
        bottom: 0,
        [ScrollAreaScrollbarCssVars.scrollAreaThumbWidth]: `${thumbSize.width}px`
      }
    }
  };
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, orientation === "vertical" ? scrollbarYRef : scrollbarXRef],
    state,
    props: [props, elementProps],
    stateAttributesMapping: scrollAreaStateAttributesMapping
  });
  const contextValue = React155.useMemo(() => ({
    orientation
  }), [orientation]);
  const isHidden = orientation === "vertical" ? hiddenState.scrollbarYHidden : hiddenState.scrollbarXHidden;
  const shouldRender = keepMounted || !isHidden;
  if (!shouldRender) {
    return null;
  }
  return (0, import_jsx_runtime56.jsx)(ScrollAreaScrollbarContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) ScrollAreaScrollbar.displayName = "ScrollAreaScrollbar";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/content/ScrollAreaContent.js
var React156 = __toESM(require_react(), 1);
var ScrollAreaContent = React156.forwardRef(function ScrollAreaContent2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const contentWrapperRef = React156.useRef(null);
  const {
    computeThumbPosition
  } = useScrollAreaViewportContext();
  const {
    viewportState
  } = useScrollAreaRootContext();
  useIsoLayoutEffect(() => {
    if (typeof ResizeObserver === "undefined") {
      return void 0;
    }
    const ro = new ResizeObserver(computeThumbPosition);
    if (contentWrapperRef.current) {
      ro.observe(contentWrapperRef.current);
    }
    return () => {
      ro.disconnect();
    };
  }, [computeThumbPosition]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, contentWrapperRef],
    state: viewportState,
    stateAttributesMapping: scrollAreaStateAttributesMapping,
    props: [{
      role: "presentation",
      style: {
        minWidth: "fit-content"
      }
    }, elementProps]
  });
  return element;
});
if (true) ScrollAreaContent.displayName = "ScrollAreaContent";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/thumb/ScrollAreaThumb.js
var React157 = __toESM(require_react(), 1);
var ScrollAreaThumb = React157.forwardRef(function ScrollAreaThumb2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    thumbYRef,
    thumbXRef,
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    setScrollingX,
    setScrollingY
  } = useScrollAreaRootContext();
  const {
    orientation
  } = useScrollAreaScrollbarContext();
  const state = React157.useMemo(() => ({
    orientation
  }), [orientation]);
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, orientation === "vertical" ? thumbYRef : thumbXRef],
    state,
    props: [{
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp(event) {
        if (orientation === "vertical") {
          setScrollingY(false);
        }
        if (orientation === "horizontal") {
          setScrollingX(false);
        }
        handlePointerUp(event);
      },
      style: {
        ...orientation === "vertical" && {
          height: `var(${ScrollAreaScrollbarCssVars.scrollAreaThumbHeight})`
        },
        ...orientation === "horizontal" && {
          width: `var(${ScrollAreaScrollbarCssVars.scrollAreaThumbWidth})`
        }
      }
    }, elementProps]
  });
  return element;
});
if (true) ScrollAreaThumb.displayName = "ScrollAreaThumb";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/scroll-area/corner/ScrollAreaCorner.js
var React158 = __toESM(require_react(), 1);
var ScrollAreaCorner = React158.forwardRef(function ScrollAreaCorner2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    cornerRef,
    cornerSize,
    hiddenState
  } = useScrollAreaRootContext();
  const element = useRenderElement("div", componentProps, {
    ref: [forwardedRef, cornerRef],
    props: [{
      style: {
        position: "absolute",
        bottom: 0,
        insetInlineEnd: 0,
        width: cornerSize.width,
        height: cornerSize.height
      }
    }, elementProps]
  });
  if (hiddenState.cornerHidden) {
    return null;
  }
  return element;
});
if (true) ScrollAreaCorner.displayName = "ScrollAreaCorner";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/index.parts.js
var index_parts_exports26 = {};
__export(index_parts_exports26, {
  Control: () => SliderControl,
  Indicator: () => SliderIndicator,
  Root: () => SliderRoot,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  Value: () => SliderValue
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/root/SliderRoot.js
var React160 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/utils/areArraysEqual.js
function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
  return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/utils/asc.js
function asc(a, b) {
  return a - b;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/utils/replaceArrayItemAtIndex.js
function replaceArrayItemAtIndex(array, index, newValue) {
  const output = array.slice();
  output[index] = newValue;
  return output.sort(asc);
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/utils/getSliderValue.js
function getSliderValue(valueInput, index, min, max, range, values) {
  let newValue = valueInput;
  newValue = clamp(newValue, min, max);
  if (range) {
    newValue = replaceArrayItemAtIndex(
      values,
      index,
      // Bound the new value to the thumb's neighbours.
      clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity)
    );
  }
  return newValue;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/utils/validateMinimumDistance.js
function validateMinimumDistance(values, step, minStepsBetweenValues) {
  if (!Array.isArray(values)) {
    return true;
  }
  const distances = values.reduce((acc, val, index, vals) => {
    if (index === vals.length - 1) {
      return acc;
    }
    acc.push(Math.abs(val - vals[index + 1]));
    return acc;
  }, []);
  return Math.min(...distances) >= step * minStepsBetweenValues;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/root/stateAttributesMapping.js
var sliderStateAttributesMapping = {
  activeThumbIndex: () => null,
  max: () => null,
  min: () => null,
  minStepsBetweenValues: () => null,
  step: () => null,
  values: () => null
};

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/root/SliderRootContext.js
var React159 = __toESM(require_react(), 1);
var SliderRootContext = React159.createContext(void 0);
if (true) SliderRootContext.displayName = "SliderRootContext";
function useSliderRootContext() {
  const context = React159.useContext(SliderRootContext);
  if (context === void 0) {
    throw new Error("Base UI: SliderRootContext is missing. Slider parts must be placed within <Slider.Root>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/root/SliderRoot.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (Array.isArray(newValue) && Array.isArray(oldValue)) {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
var SliderRoot = React160.forwardRef(function SliderRoot2(componentProps, forwardedRef) {
  const {
    "aria-labelledby": ariaLabelledByProp,
    className,
    defaultValue,
    disabled: disabledProp = false,
    id: idProp,
    format,
    largeStep = 10,
    locale,
    render,
    max = 100,
    min = 0,
    minStepsBetweenValues = 0,
    name: nameProp,
    onValueChange: onValueChangeProp,
    onValueCommitted: onValueCommittedProp,
    orientation = "horizontal",
    step = 1,
    thumbAlignment = "center",
    value: valueProp,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const onValueChange = useEventCallback(onValueChangeProp);
  const onValueCommitted = useEventCallback(onValueCommittedProp);
  const {
    clearErrors
  } = useFormContext();
  const {
    labelId,
    state: fieldState,
    disabled: fieldDisabled,
    name: fieldName,
    setTouched,
    setDirty,
    validityData,
    validationMode
  } = useFieldRootContext();
  const fieldControlValidation = useFieldControlValidation();
  const ariaLabelledby = ariaLabelledByProp ?? labelId;
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const [valueUnwrapped, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue ?? min,
    name: "Slider"
  });
  const sliderRef = React160.useRef(null);
  const controlRef = React160.useRef(null);
  const thumbRefs = React160.useRef([]);
  const pressedInputRef = React160.useRef(null);
  const pressedThumbCenterOffsetRef = React160.useRef(null);
  const pressedThumbIndexRef = React160.useRef(-1);
  const lastChangedValueRef = React160.useRef(null);
  const formatOptionsRef = useLatestRef(format);
  const [active, setActive] = React160.useState(-1);
  const [dragging, setDragging] = React160.useState(false);
  const [thumbMap, setThumbMap] = React160.useState(() => /* @__PURE__ */ new Map());
  const [indicatorPosition, setIndicatorPosition] = React160.useState([void 0, void 0]);
  useField({
    id,
    commitValidation: fieldControlValidation.commitValidation,
    value: valueUnwrapped,
    controlRef,
    name,
    getValue: () => valueUnwrapped
  });
  const registerFieldControlRef = useEventCallback((element2) => {
    if (element2) {
      controlRef.current = element2;
    }
  });
  const range = Array.isArray(valueUnwrapped);
  const values = React160.useMemo(() => {
    if (!range) {
      return [clamp(valueUnwrapped, min, max)];
    }
    return valueUnwrapped.slice().sort(asc);
  }, [max, min, range, valueUnwrapped]);
  const setValue = useEventCallback((newValue, thumbIndex, event) => {
    if (Number.isNaN(newValue) || areValuesEqual(newValue, valueUnwrapped)) {
      return;
    }
    const clonedEvent = new event.constructor(event.type, event);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value: newValue,
        name
      }
    });
    lastChangedValueRef.current = newValue;
    const details = createChangeEventDetails("none", clonedEvent, {
      activeThumbIndex: thumbIndex
    });
    onValueChange(newValue, details);
    if (details.isCanceled) {
      return;
    }
    setValueUnwrapped(newValue);
    clearErrors(name);
    fieldControlValidation.commitValidation(newValue, true);
  });
  const handleInputChange = useEventCallback((valueInput, index, event) => {
    const newValue = getSliderValue(valueInput, index, min, max, range, values);
    if (validateMinimumDistance(newValue, step, minStepsBetweenValues)) {
      setValue(newValue, index, event.nativeEvent);
      setDirty(newValue !== validityData.initialValue);
      setTouched(true);
      const nextValue = lastChangedValueRef.current ?? newValue;
      onValueCommitted(nextValue, createGenericEventDetails("none", event.nativeEvent));
      clearErrors(name);
      if (validationMode === "onChange") {
        fieldControlValidation.commitValidation(nextValue ?? newValue);
      } else {
        fieldControlValidation.commitValidation(nextValue ?? newValue, true);
      }
    }
  });
  if (true) {
    if (min >= max) {
      warn("Slider `max` must be greater than `min`.");
    }
  }
  useIsoLayoutEffect(() => {
    var _a;
    const activeEl = activeElement(ownerDocument(sliderRef.current));
    if (disabled && activeEl && ((_a = sliderRef.current) == null ? void 0 : _a.contains(activeEl))) {
      activeEl.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  const state = React160.useMemo(() => ({
    ...fieldState,
    activeThumbIndex: active,
    disabled,
    dragging,
    orientation,
    max,
    min,
    minStepsBetweenValues,
    step,
    values
  }), [fieldState, active, disabled, dragging, max, min, minStepsBetweenValues, orientation, step, values]);
  const contextValue = React160.useMemo(() => ({
    active,
    controlRef,
    disabled,
    dragging,
    fieldControlValidation,
    formatOptionsRef,
    handleInputChange,
    indicatorPosition,
    inset: thumbAlignment !== "center",
    labelId: ariaLabelledby,
    largeStep,
    lastChangedValueRef,
    locale,
    max,
    min,
    minStepsBetweenValues,
    name,
    onValueCommitted,
    orientation,
    pressedInputRef,
    pressedThumbCenterOffsetRef,
    pressedThumbIndexRef,
    registerFieldControlRef,
    renderBeforeHydration: thumbAlignment === "edge",
    setActive,
    setDragging,
    setIndicatorPosition,
    setValue,
    state,
    step,
    thumbMap,
    thumbRefs,
    values
  }), [active, controlRef, ariaLabelledby, disabled, dragging, fieldControlValidation, formatOptionsRef, handleInputChange, indicatorPosition, largeStep, lastChangedValueRef, locale, max, min, minStepsBetweenValues, name, onValueCommitted, orientation, pressedInputRef, pressedThumbCenterOffsetRef, pressedThumbIndexRef, registerFieldControlRef, setActive, setDragging, setIndicatorPosition, setValue, state, step, thumbAlignment, thumbMap, thumbRefs, values]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, sliderRef],
    props: [{
      "aria-labelledby": ariaLabelledby,
      id,
      role: "group"
    }, fieldControlValidation.getValidationProps, elementProps],
    stateAttributesMapping: sliderStateAttributesMapping
  });
  return (0, import_jsx_runtime57.jsx)(SliderRootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime57.jsx)(CompositeList, {
      elementsRef: thumbRefs,
      onMapChange: setThumbMap,
      children: element
    })
  });
});
if (true) SliderRoot.displayName = "SliderRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/value/SliderValue.js
var React161 = __toESM(require_react(), 1);
var SliderValue = React161.forwardRef(function SliderValue2(componentProps, forwardedRef) {
  const {
    "aria-live": ariaLive = "off",
    render,
    className,
    children,
    ...elementProps
  } = componentProps;
  const {
    thumbMap,
    state,
    values,
    formatOptionsRef,
    locale
  } = useSliderRootContext();
  const outputFor = React161.useMemo(() => {
    let htmlFor = "";
    for (const thumbMetadata of thumbMap.values()) {
      if (thumbMetadata == null ? void 0 : thumbMetadata.inputId) {
        htmlFor += `${thumbMetadata.inputId} `;
      }
    }
    return htmlFor.trim() === "" ? void 0 : htmlFor.trim();
  }, [thumbMap]);
  const formattedValues = React161.useMemo(() => {
    const arr = [];
    for (let i = 0; i < values.length; i += 1) {
      arr.push(formatNumber(values[i], locale, formatOptionsRef.current ?? void 0));
    }
    return arr;
  }, [formatOptionsRef, locale, values]);
  const defaultDisplayValue = React161.useMemo(() => {
    const arr = [];
    for (let i = 0; i < values.length; i += 1) {
      arr.push(formattedValues[i] || values[i]);
    }
    return arr.join("  ");
  }, [values, formattedValues]);
  const element = useRenderElement("output", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      // off by default because it will keep announcing when the slider is being dragged
      // and also when the value is changing (but not yet committed)
      "aria-live": ariaLive,
      children: typeof children === "function" ? children(formattedValues, values) : defaultDisplayValue,
      htmlFor: outputFor
    }, elementProps],
    stateAttributesMapping: sliderStateAttributesMapping
  });
  return element;
});
if (true) SliderValue.displayName = "SliderValue";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/control/SliderControl.js
var React162 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/utils/getMidpoint.js
function getMidpoint(element) {
  const rect = element.getBoundingClientRect();
  return {
    x: (rect.left + rect.right) / 2,
    y: (rect.top + rect.bottom) / 2
  };
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/utils/roundValueToStep.js
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min) {
  const nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/control/SliderControl.js
var INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function getControlOffset(styles, vertical) {
  if (!styles) {
    return {
      start: 0,
      end: 0
    };
  }
  const start = !vertical ? "InlineStart" : "Top";
  const end = !vertical ? "InlineEnd" : "Bottom";
  return {
    start: parseFloat(styles[`border${start}Width`]) + parseFloat(styles[`padding${start}`]),
    end: parseFloat(styles[`border${end}Width`]) + parseFloat(styles[`padding${end}`])
  };
}
function getFingerCoords(event, touchIdRef) {
  if (touchIdRef.current != null && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchIdRef.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return null;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
var SliderControl = React162.forwardRef(function SliderControl2(componentProps, forwardedRef) {
  const {
    render: renderProp,
    className,
    ...elementProps
  } = componentProps;
  const {
    disabled,
    dragging,
    fieldControlValidation,
    inset,
    lastChangedValueRef,
    max,
    min,
    minStepsBetweenValues,
    onValueCommitted,
    orientation,
    pressedInputRef,
    pressedThumbCenterOffsetRef,
    pressedThumbIndexRef,
    registerFieldControlRef,
    renderBeforeHydration,
    setActive,
    setDragging,
    setValue,
    state,
    step,
    thumbRefs,
    values
  } = useSliderRootContext();
  const direction = useDirection();
  const range = values.length > 1;
  const vertical = orientation === "vertical";
  const controlRef = React162.useRef(null);
  const stylesRef = React162.useRef(null);
  const setStylesRef = useEventCallback((element2) => {
    if (element2 && stylesRef.current == null) {
      if (stylesRef.current == null) {
        stylesRef.current = getComputedStyle(element2);
      }
    }
  });
  const touchIdRef = React162.useRef(null);
  const moveCountRef = React162.useRef(0);
  const insetThumbOffsetRef = React162.useRef(0);
  const getFingerState = useEventCallback((fingerCoords) => {
    const control = controlRef.current;
    if (!control) {
      return null;
    }
    const {
      width,
      height,
      bottom,
      left,
      right
    } = control.getBoundingClientRect();
    const controlOffset = getControlOffset(stylesRef.current, vertical);
    const insetThumbOffset = insetThumbOffsetRef.current;
    const controlSize = (vertical ? height : width) - controlOffset.start - controlOffset.end - insetThumbOffset * 2;
    const thumbCenterOffset = pressedThumbCenterOffsetRef.current ?? 0;
    const fingerX = fingerCoords.x - thumbCenterOffset;
    const fingerY = fingerCoords.y - thumbCenterOffset;
    const valueSize = vertical ? bottom - fingerY - controlOffset.end : (direction === "rtl" ? right - fingerX : fingerX - left) - controlOffset.start;
    const valueRescaled = clamp((valueSize - insetThumbOffset) / controlSize, 0, 1);
    let newValue = (max - min) * valueRescaled + min;
    newValue = roundValueToStep(newValue, step, min);
    newValue = clamp(newValue, min, max);
    if (!range) {
      return {
        value: newValue,
        thumbIndex: 0
      };
    }
    const minValueDifference = minStepsBetweenValues * step;
    newValue = clamp(newValue, values[pressedThumbIndexRef.current - 1] + minValueDifference || -Infinity, values[pressedThumbIndexRef.current + 1] - minValueDifference || Infinity);
    return {
      value: replaceArrayItemAtIndex(values, pressedThumbIndexRef.current, newValue),
      thumbIndex: pressedThumbIndexRef.current
    };
  });
  const startPressing = useEventCallback((fingerCoords) => {
    const pressedThumbIndex = pressedThumbIndexRef.current;
    let closestThumbIndex = pressedThumbIndex;
    if (pressedThumbIndex > -1 && pressedThumbIndex < values.length) {
      if (values[pressedThumbIndex] === max) {
        let candidateIndex = pressedThumbIndex;
        while (candidateIndex > 0 && values[candidateIndex - 1] === max) {
          candidateIndex -= 1;
        }
        closestThumbIndex = candidateIndex;
      }
    } else {
      const axis = !vertical ? "x" : "y";
      let minDistance;
      closestThumbIndex = -1;
      for (let i = 0; i < thumbRefs.current.length; i += 1) {
        const thumbEl = thumbRefs.current[i];
        if (isElement(thumbEl)) {
          const midpoint = getMidpoint(thumbEl);
          const distance = Math.abs(fingerCoords[axis] - midpoint[axis]);
          if (minDistance === void 0 || distance <= minDistance) {
            closestThumbIndex = i;
            minDistance = distance;
          }
        }
      }
    }
    if (closestThumbIndex > -1 && closestThumbIndex !== pressedThumbIndex) {
      pressedThumbIndexRef.current = closestThumbIndex;
    }
    if (inset) {
      const thumbEl = thumbRefs.current[closestThumbIndex];
      if (isElement(thumbEl)) {
        const thumbRect = thumbEl.getBoundingClientRect();
        const side = !vertical ? "width" : "height";
        insetThumbOffsetRef.current = thumbRect[side] / 2;
      }
    }
  });
  const focusThumb = useEventCallback((thumbIndex) => {
    var _a, _b, _c;
    (_c = (_b = (_a = thumbRefs.current) == null ? void 0 : _a[thumbIndex]) == null ? void 0 : _b.querySelector('input[type="range"]')) == null ? void 0 : _c.focus({
      preventScroll: true
    });
  });
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const fingerCoords = getFingerCoords(nativeEvent, touchIdRef);
    if (fingerCoords == null) {
      return;
    }
    moveCountRef.current += 1;
    if (nativeEvent.type === "pointermove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const finger = getFingerState(fingerCoords);
    if (finger == null) {
      return;
    }
    if (validateMinimumDistance(finger.value, step, minStepsBetweenValues)) {
      if (!dragging && moveCountRef.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
        setDragging(true);
      }
      setValue(finger.value, finger.thumbIndex, nativeEvent);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    var _a, _b;
    setActive(-1);
    setDragging(false);
    pressedInputRef.current = null;
    pressedThumbCenterOffsetRef.current = null;
    pressedThumbIndexRef.current = -1;
    const fingerCoords = getFingerCoords(nativeEvent, touchIdRef);
    if (fingerCoords == null) {
      return;
    }
    const finger = getFingerState(fingerCoords);
    if (finger == null) {
      return;
    }
    fieldControlValidation.commitValidation(lastChangedValueRef.current ?? finger.value);
    onValueCommitted(lastChangedValueRef.current ?? finger.value, createGenericEventDetails("none", nativeEvent));
    if ("pointerType" in nativeEvent && ((_a = controlRef.current) == null ? void 0 : _a.hasPointerCapture(nativeEvent.pointerId))) {
      (_b = controlRef.current) == null ? void 0 : _b.releasePointerCapture(nativeEvent.pointerId);
    }
    touchIdRef.current = null;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchIdRef.current = touch.identifier;
    }
    const fingerCoords = getFingerCoords(nativeEvent, touchIdRef);
    if (fingerCoords != null) {
      startPressing(fingerCoords);
      const finger = getFingerState(fingerCoords);
      if (finger == null) {
        return;
      }
      focusThumb(finger.thumbIndex);
      setValue(finger.value, finger.thumbIndex, nativeEvent);
    }
    moveCountRef.current = 0;
    const doc = ownerDocument(controlRef.current);
    doc.addEventListener("touchmove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("touchend", handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = useEventCallback(() => {
    const doc = ownerDocument(controlRef.current);
    doc.removeEventListener("pointermove", handleTouchMove);
    doc.removeEventListener("pointerup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  });
  const focusFrame = useAnimationFrame();
  React162.useEffect(() => {
    const control = controlRef.current;
    if (!control) {
      return () => stopListening();
    }
    control.addEventListener("touchstart", handleTouchStart, {
      passive: true
    });
    return () => {
      control.removeEventListener("touchstart", handleTouchStart);
      focusFrame.cancel();
      stopListening();
    };
  }, [stopListening, handleTouchStart, controlRef, focusFrame]);
  React162.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, registerFieldControlRef, controlRef, setStylesRef],
    props: [{
      ["data-base-ui-slider-control"]: renderBeforeHydration ? "" : void 0,
      onPointerDown(event) {
        const control = controlRef.current;
        if (!control || disabled || event.defaultPrevented || !isElement(event.target) || // Only handle left clicks
        event.button !== 0) {
          return;
        }
        const fingerCoords = getFingerCoords(event, touchIdRef);
        if (fingerCoords != null) {
          startPressing(fingerCoords);
          const finger = getFingerState(fingerCoords);
          if (finger == null) {
            return;
          }
          const pressedOnFocusedThumb = contains(thumbRefs.current[finger.thumbIndex], activeElement(ownerDocument(control)));
          if (pressedOnFocusedThumb) {
            event.preventDefault();
          } else {
            focusFrame.request(() => {
              focusThumb(finger.thumbIndex);
            });
          }
          setDragging(true);
          const pressedOnAnyThumb = pressedThumbCenterOffsetRef.current != null;
          if (!pressedOnAnyThumb) {
            setValue(finger.value, finger.thumbIndex, event.nativeEvent);
          }
        }
        if (event.nativeEvent.pointerId) {
          control.setPointerCapture(event.nativeEvent.pointerId);
        }
        moveCountRef.current = 0;
        const doc = ownerDocument(controlRef.current);
        doc.addEventListener("pointermove", handleTouchMove, {
          passive: true
        });
        doc.addEventListener("pointerup", handleTouchEnd);
      },
      tabIndex: -1
    }, elementProps],
    stateAttributesMapping: sliderStateAttributesMapping
  });
  return element;
});
if (true) SliderControl.displayName = "SliderControl";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/track/SliderTrack.js
var React163 = __toESM(require_react(), 1);
var SliderTrack = React163.forwardRef(function SliderTrack2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useSliderRootContext();
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      style: {
        position: "relative"
      }
    }, elementProps],
    stateAttributesMapping: sliderStateAttributesMapping
  });
  return element;
});
if (true) SliderTrack.displayName = "SliderTrack";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/thumb/SliderThumb.js
var React164 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/thumb/SliderThumbDataAttributes.js
var SliderThumbDataAttributes = (function(SliderThumbDataAttributes2) {
  SliderThumbDataAttributes2["index"] = "data-index";
  SliderThumbDataAttributes2["dragging"] = "data-dragging";
  SliderThumbDataAttributes2["orientation"] = "data-orientation";
  SliderThumbDataAttributes2["disabled"] = "data-disabled";
  SliderThumbDataAttributes2["readonly"] = "data-readonly";
  SliderThumbDataAttributes2["required"] = "data-required";
  SliderThumbDataAttributes2["valid"] = "data-valid";
  SliderThumbDataAttributes2["invalid"] = "data-invalid";
  SliderThumbDataAttributes2["touched"] = "data-touched";
  SliderThumbDataAttributes2["dirty"] = "data-dirty";
  SliderThumbDataAttributes2["focused"] = "data-focused";
  return SliderThumbDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/thumb/prehydrationScript.min.js
var script = '!function(){const t=document.currentScript?.parentElement;if(!t)return;const e=t.closest("[data-base-ui-slider-control]");if(!e)return;const r=e.querySelector("[data-base-ui-slider-indicator]"),i=e.getBoundingClientRect(),n="vertical"===e.getAttribute("data-orientation")?"height":"width",o=e.querySelectorAll(\'input[type="range"]\'),l=o.length>1,s=o.length-1;let a=null,u=null;for(let t=0;t<o.length;t+=1){const e=o[t],y=parseFloat(e.getAttribute("value")??"");if(Number.isNaN(y))return;const c=e.parentElement;if(!c)return;const p=parseFloat(e.getAttribute("max")??"100"),g=parseFloat(e.getAttribute("min")??"0"),b=c?.getBoundingClientRect(),d=i[n]-b[n],m=100*(y-g)/(p-g),v=(b[n]/2+d*m/100)/i[n]*100;c.style.setProperty("--position",`${v}%`),Number.isFinite(v)&&(c.style.removeProperty("visibility"),r&&(0===t?(a=v,r.style.setProperty("--start-position",`${v}%`),l||r.style.removeProperty("visibility")):t===s&&(u=v-(a??0),r.style.setProperty("--end-position",`${v}%`),r.style.setProperty("--relative-size",`${u}%`),r.style.removeProperty("visibility"))))}}();';

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/thumb/SliderThumb.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var PAGE_UP = "PageUp";
var PAGE_DOWN = "PageDown";
var ALL_KEYS = /* @__PURE__ */ new Set([ARROW_UP, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, HOME, END, PAGE_UP, PAGE_DOWN]);
function getDefaultAriaValueText2(values, index, format, locale) {
  if (index < 0) {
    return void 0;
  }
  if (values.length === 2) {
    if (index === 0) {
      return `${formatNumber(values[index], locale, format)} start range`;
    }
    return `${formatNumber(values[index], locale, format)} end range`;
  }
  return format ? formatNumber(values[index], locale, format) : void 0;
}
function getNewValue(thumbValue, step, direction, min, max) {
  return direction === 1 ? Math.min(thumbValue + step, max) : Math.max(thumbValue - step, min);
}
var SliderThumb = React164.forwardRef(function SliderThumb2(componentProps, forwardedRef) {
  const {
    render,
    children: childrenProp,
    className,
    "aria-describedby": ariaDescribedByProp,
    "aria-label": ariaLabelProp,
    "aria-labelledby": ariaLabelledByProp,
    disabled: disabledProp = false,
    getAriaLabel: getAriaLabelProp,
    getAriaValueText: getAriaValueTextProp,
    id: idProp,
    index: indexProp,
    inputRef: inputRefProp,
    onBlur: onBlurProp,
    onFocus: onFocusProp,
    onKeyDown: onKeyDownProp,
    tabIndex: tabIndexProp,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const inputId = `${id}-input`;
  const {
    active: activeIndex,
    controlRef,
    disabled: contextDisabled,
    fieldControlValidation,
    formatOptionsRef,
    handleInputChange,
    inset,
    labelId,
    largeStep,
    locale,
    max,
    min,
    minStepsBetweenValues,
    name,
    orientation,
    pressedInputRef,
    pressedThumbCenterOffsetRef,
    pressedThumbIndexRef,
    renderBeforeHydration,
    setActive,
    setIndicatorPosition,
    state,
    step,
    values: sliderValues
  } = useSliderRootContext();
  const direction = useDirection();
  const disabled = disabledProp || contextDisabled;
  const range = sliderValues.length > 1;
  const vertical = orientation === "vertical";
  const rtl = direction === "rtl";
  const {
    controlId,
    setControlId,
    setTouched,
    setFocused,
    validationMode
  } = useFieldRootContext();
  const thumbRef = React164.useRef(null);
  const inputRef = React164.useRef(null);
  useIsoLayoutEffect(() => {
    setControlId(inputId);
    return () => {
      setControlId(void 0);
    };
  }, [controlId, inputId, setControlId]);
  const thumbMetadata = React164.useMemo(() => ({
    inputId
  }), [inputId]);
  const {
    ref: listItemRef,
    index: compositeIndex
  } = useCompositeListItem({
    metadata: thumbMetadata
  });
  const index = !range ? 0 : indexProp ?? compositeIndex;
  const last = index === sliderValues.length - 1;
  const thumbValue = sliderValues[index];
  const thumbValuePercent = valueToPercent(thumbValue, min, max);
  const [isMounted, setIsMounted] = React164.useState(false);
  const [positionPercent, setPositionPercent] = React164.useState();
  useOnMount(() => setIsMounted(true));
  const getInsetPosition = useEventCallback(() => {
    const control = controlRef.current;
    const thumb = thumbRef.current;
    if (!control || !thumb) {
      return;
    }
    const thumbRect = thumb.getBoundingClientRect();
    const controlRect = control.getBoundingClientRect();
    const side = vertical ? "height" : "width";
    const controlSize = controlRect[side] - thumbRect[side];
    const thumbOffsetFromControlEdge = thumbRect[side] / 2 + controlSize * thumbValuePercent / 100;
    const nextPositionPercent = thumbOffsetFromControlEdge / controlRect[side] * 100;
    setPositionPercent(nextPositionPercent);
    if (index === 0) {
      setIndicatorPosition((prevPosition) => [nextPositionPercent, prevPosition[1]]);
    } else if (last) {
      setIndicatorPosition((prevPosition) => [prevPosition[0], nextPositionPercent]);
    }
  });
  useIsoLayoutEffect(() => {
    if (inset) {
      queueMicrotask(getInsetPosition);
    }
  }, [getInsetPosition, inset]);
  useIsoLayoutEffect(() => {
    if (inset) {
      getInsetPosition();
    }
  }, [getInsetPosition, inset, thumbValuePercent]);
  const getThumbStyle = React164.useCallback(() => {
    const startEdge = vertical ? "bottom" : "insetInlineStart";
    const crossOffsetProperty = vertical ? "left" : "top";
    if (!inset) {
      if (!Number.isFinite(thumbValuePercent)) {
        return visuallyHidden;
      }
      return {
        position: "absolute",
        [startEdge]: `${thumbValuePercent}%`,
        [crossOffsetProperty]: "50%",
        translate: `${(vertical || !rtl ? -1 : 1) * 50}% ${(vertical ? 1 : -1) * 50}%`,
        zIndex: activeIndex === index ? 1 : void 0
      };
    }
    return {
      ["--position"]: `${positionPercent}%`,
      visibility: renderBeforeHydration && !isMounted || positionPercent === void 0 ? "hidden" : void 0,
      position: "absolute",
      [startEdge]: "var(--position)",
      [crossOffsetProperty]: "50%",
      translate: `${(vertical || !rtl ? -1 : 1) * 50}% ${(vertical ? 1 : -1) * 50}%`,
      zIndex: activeIndex === index ? 1 : void 0
    };
  }, [activeIndex, index, inset, isMounted, positionPercent, renderBeforeHydration, rtl, thumbValuePercent, vertical]);
  let cssWritingMode;
  if (orientation === "vertical") {
    cssWritingMode = rtl ? "vertical-rl" : "vertical-lr";
  }
  const inputProps = mergeProps({
    "aria-label": typeof getAriaLabelProp === "function" ? getAriaLabelProp(index) : ariaLabelProp,
    "aria-labelledby": ariaLabelledByProp ?? labelId,
    "aria-describedby": ariaDescribedByProp,
    "aria-orientation": orientation,
    "aria-valuenow": thumbValue,
    "aria-valuetext": typeof getAriaValueTextProp === "function" ? getAriaValueTextProp(formatNumber(thumbValue, locale, formatOptionsRef.current ?? void 0), thumbValue, index) : getDefaultAriaValueText2(sliderValues, index, formatOptionsRef.current ?? void 0, locale),
    disabled,
    id: inputId,
    max,
    min,
    name,
    onChange(event) {
      handleInputChange(event.target.valueAsNumber, index, event);
    },
    onFocus() {
      setActive(index);
      setFocused(true);
    },
    onBlur() {
      if (!thumbRef.current) {
        return;
      }
      setActive(-1);
      setTouched(true);
      setFocused(false);
      if (validationMode === "onBlur") {
        fieldControlValidation.commitValidation(getSliderValue(thumbValue, index, min, max, range, sliderValues));
      }
    },
    onKeyDown(event) {
      if (!ALL_KEYS.has(event.key)) {
        return;
      }
      if (COMPOSITE_KEYS.has(event.key)) {
        event.stopPropagation();
      }
      let newValue = null;
      const roundedValue = roundValueToStep(thumbValue, step, min);
      switch (event.key) {
        case ARROW_UP:
          newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, 1, min, max);
          break;
        case ARROW_RIGHT:
          newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, rtl ? -1 : 1, min, max);
          break;
        case ARROW_DOWN:
          newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, -1, min, max);
          break;
        case ARROW_LEFT:
          newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, rtl ? 1 : -1, min, max);
          break;
        case PAGE_UP:
          newValue = getNewValue(roundedValue, largeStep, 1, min, max);
          break;
        case PAGE_DOWN:
          newValue = getNewValue(roundedValue, largeStep, -1, min, max);
          break;
        case END:
          newValue = max;
          if (range) {
            newValue = Number.isFinite(sliderValues[index + 1]) ? sliderValues[index + 1] - step * minStepsBetweenValues : max;
          }
          break;
        case HOME:
          newValue = min;
          if (range) {
            newValue = Number.isFinite(sliderValues[index - 1]) ? sliderValues[index - 1] + step * minStepsBetweenValues : min;
          }
          break;
        default:
          break;
      }
      if (newValue !== null) {
        handleInputChange(newValue, index, event);
        event.preventDefault();
      }
    },
    step,
    style: {
      ...visuallyHidden,
      // So that VoiceOver's focus indicator matches the thumb's dimensions
      width: "100%",
      height: "100%",
      writingMode: cssWritingMode
    },
    tabIndex: tabIndexProp ?? void 0,
    type: "range",
    value: thumbValue ?? ""
  }, fieldControlValidation.getInputValidationProps);
  const mergedInputRef = useMergedRefs(inputRef, fieldControlValidation.inputRef, inputRefProp);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: [forwardedRef, listItemRef, thumbRef],
    props: [{
      [SliderThumbDataAttributes.index]: index,
      children: (0, import_jsx_runtime58.jsxs)(React164.Fragment, {
        children: [childrenProp, (0, import_jsx_runtime58.jsx)("input", {
          ref: mergedInputRef,
          ...inputProps
        }), inset && !isMounted && renderBeforeHydration && // this must be rendered with the last thumb to ensure all
        // preceding thumbs are already rendered in the DOM
        last && (0, import_jsx_runtime58.jsx)("script", {
          // eslint-disable-next-line react/no-danger
          dangerouslySetInnerHTML: {
            __html: script
          },
          suppressHydrationWarning: true
        })]
      }),
      id,
      onBlur: onBlurProp,
      onFocus: onFocusProp,
      onPointerDown(event) {
        pressedThumbIndexRef.current = index;
        if (thumbRef.current != null) {
          const axis = orientation === "horizontal" ? "x" : "y";
          const midpoint = getMidpoint(thumbRef.current);
          const offset = (orientation === "horizontal" ? event.clientX : event.clientY) - midpoint[axis];
          pressedThumbCenterOffsetRef.current = offset;
        }
        if (inputRef.current != null && pressedInputRef.current !== inputRef.current) {
          pressedInputRef.current = inputRef.current;
        }
      },
      style: getThumbStyle(),
      suppressHydrationWarning: renderBeforeHydration || void 0,
      tabIndex: -1
    }, elementProps],
    stateAttributesMapping: sliderStateAttributesMapping
  });
  return element;
});
if (true) SliderThumb.displayName = "SliderThumb";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/slider/indicator/SliderIndicator.js
var React165 = __toESM(require_react(), 1);
function getInsetStyles(vertical, range, start, end, renderBeforeHydration, mounted) {
  const visibility = start === void 0 || range && end === void 0 ? "hidden" : void 0;
  const startEdge = vertical ? "bottom" : "insetInlineStart";
  const mainSide = vertical ? "height" : "width";
  const crossSide = vertical ? "width" : "height";
  const styles = {
    visibility: renderBeforeHydration && !mounted ? "hidden" : visibility,
    position: vertical ? "absolute" : "relative",
    [crossSide]: "inherit"
  };
  styles["--start-position"] = `${start ?? 0}%`;
  if (!range) {
    styles[startEdge] = 0;
    styles[mainSide] = "var(--start-position)";
    return styles;
  }
  styles["--relative-size"] = `${(end ?? 0) - (start ?? 0)}%`;
  styles[startEdge] = "var(--start-position)";
  styles[mainSide] = "var(--relative-size)";
  return styles;
}
function getCenteredStyles(vertical, range, start, end) {
  const startEdge = vertical ? "bottom" : "insetInlineStart";
  const mainSide = vertical ? "height" : "width";
  const crossSide = vertical ? "width" : "height";
  const styles = {
    position: vertical ? "absolute" : "relative",
    [crossSide]: "inherit"
  };
  if (!range) {
    styles[startEdge] = 0;
    styles[mainSide] = `${start}%`;
    return styles;
  }
  const size = end - start;
  styles[startEdge] = `${start}%`;
  styles[mainSide] = `${size}%`;
  return styles;
}
var SliderIndicator = React165.forwardRef(function SliderIndicator2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    indicatorPosition,
    inset,
    max,
    min,
    orientation,
    renderBeforeHydration,
    state,
    values
  } = useSliderRootContext();
  const [isMounted, setIsMounted] = React165.useState(false);
  useOnMount(() => setIsMounted(true));
  const vertical = orientation === "vertical";
  const range = values.length > 1;
  const style = inset ? getInsetStyles(vertical, range, indicatorPosition[0], indicatorPosition[1], renderBeforeHydration, isMounted) : getCenteredStyles(vertical, range, valueToPercent(values[0], min, max), valueToPercent(values[values.length - 1], min, max));
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      ["data-base-ui-slider-indicator"]: renderBeforeHydration ? "" : void 0,
      style,
      suppressHydrationWarning: renderBeforeHydration || void 0
    }, elementProps],
    stateAttributesMapping: sliderStateAttributesMapping
  });
  return element;
});
if (true) SliderIndicator.displayName = "SliderIndicator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toggle/Toggle.js
var React167 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toggle-group/ToggleGroupContext.js
var React166 = __toESM(require_react(), 1);
var ToggleGroupContext = React166.createContext(void 0);
if (true) ToggleGroupContext.displayName = "ToggleGroupContext";
function useToggleGroupContext(optional = true) {
  const context = React166.useContext(ToggleGroupContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: ToggleGroupContext is missing. ToggleGroup parts must be placed within <ToggleGroup>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toggle/Toggle.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var Toggle = React167.forwardRef(function Toggle2(componentProps, forwardedRef) {
  const {
    className,
    defaultPressed: defaultPressedProp = false,
    disabled: disabledProp = false,
    form,
    // never participates in form validation
    onPressedChange: onPressedChangeProp,
    pressed: pressedProp,
    render,
    type,
    // cannot change button type
    value: valueProp,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const value = valueProp ?? "";
  const groupContext = useToggleGroupContext();
  const groupValue = (groupContext == null ? void 0 : groupContext.value) ?? [];
  const defaultPressed = groupContext ? void 0 : defaultPressedProp;
  const disabled = (disabledProp || (groupContext == null ? void 0 : groupContext.disabled)) ?? false;
  const [pressed, setPressedState] = useControlled({
    controlled: groupContext && value ? (groupValue == null ? void 0 : groupValue.indexOf(value)) > -1 : pressedProp,
    default: defaultPressed,
    name: "Toggle",
    state: "pressed"
  });
  const onPressedChange = useEventCallback((nextPressed, eventDetails) => {
    var _a;
    (_a = groupContext == null ? void 0 : groupContext.setGroupValue) == null ? void 0 : _a.call(groupContext, value, nextPressed, eventDetails);
    onPressedChangeProp == null ? void 0 : onPressedChangeProp(nextPressed, eventDetails);
  });
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const state = React167.useMemo(() => ({
    disabled,
    pressed
  }), [disabled, pressed]);
  const refs = [buttonRef, forwardedRef];
  const props = [{
    "aria-pressed": pressed,
    onClick(event) {
      const nextPressed = !pressed;
      const details = createChangeEventDetails("none", event.nativeEvent);
      onPressedChange(nextPressed, details);
      if (details.isCanceled) {
        return;
      }
      setPressedState(nextPressed);
    }
  }, elementProps, getButtonProps];
  const element = useRenderElement("button", componentProps, {
    enabled: !groupContext,
    state,
    ref: refs,
    props
  });
  if (groupContext) {
    return (0, import_jsx_runtime59.jsx)(CompositeItem, {
      tag: "button",
      render,
      className,
      state,
      refs,
      props
    });
  }
  return element;
});
if (true) Toggle.displayName = "Toggle";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toggle-group/ToggleGroup.js
var React168 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toggle-group/ToggleGroupDataAttributes.js
var ToggleGroupDataAttributes = (function(ToggleGroupDataAttributes2) {
  ToggleGroupDataAttributes2["disabled"] = "data-disabled";
  ToggleGroupDataAttributes2["orientation"] = "data-orientation";
  ToggleGroupDataAttributes2["multiple"] = "data-multiple";
  return ToggleGroupDataAttributes2;
})({});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toggle-group/ToggleGroup.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var stateAttributesMapping21 = {
  multiple(value) {
    if (value) {
      return {
        [ToggleGroupDataAttributes.multiple]: ""
      };
    }
    return null;
  }
};
var ToggleGroup = React168.forwardRef(function ToggleGroup2(componentProps, forwardedRef) {
  const {
    defaultValue: defaultValueProp,
    disabled: disabledProp = false,
    loop = true,
    onValueChange,
    orientation = "horizontal",
    multiple = false,
    value: valueProp,
    className,
    render,
    ...elementProps
  } = componentProps;
  const toolbarContext = useToolbarRootContext(true);
  const defaultValue = React168.useMemo(() => {
    if (valueProp === void 0) {
      return defaultValueProp ?? [];
    }
    return void 0;
  }, [valueProp, defaultValueProp]);
  const disabled = ((toolbarContext == null ? void 0 : toolbarContext.disabled) ?? false) || disabledProp;
  const [groupValue, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "ToggleGroup",
    state: "value"
  });
  const setGroupValue = useEventCallback((newValue, nextPressed, eventDetails) => {
    let newGroupValue;
    if (multiple) {
      newGroupValue = groupValue.slice();
      if (nextPressed) {
        newGroupValue.push(newValue);
      } else {
        newGroupValue.splice(groupValue.indexOf(newValue), 1);
      }
    } else {
      newGroupValue = nextPressed ? [newValue] : [];
    }
    if (Array.isArray(newGroupValue)) {
      onValueChange == null ? void 0 : onValueChange(newGroupValue, eventDetails);
      if (eventDetails.isCanceled) {
        return;
      }
      setValueState(newGroupValue);
    }
  });
  const state = React168.useMemo(() => ({
    disabled,
    multiple,
    orientation
  }), [disabled, orientation, multiple]);
  const contextValue = React168.useMemo(() => ({
    disabled,
    orientation,
    setGroupValue,
    value: groupValue
  }), [disabled, orientation, setGroupValue, groupValue]);
  const defaultProps = {
    role: "group"
  };
  const element = useRenderElement("div", componentProps, {
    enabled: Boolean(toolbarContext),
    state,
    ref: forwardedRef,
    props: [defaultProps, elementProps],
    stateAttributesMapping: stateAttributesMapping21
  });
  return (0, import_jsx_runtime60.jsx)(ToggleGroupContext.Provider, {
    value: contextValue,
    children: toolbarContext ? element : (0, import_jsx_runtime60.jsx)(CompositeRoot, {
      render,
      className,
      state,
      refs: [forwardedRef],
      props: [defaultProps, elementProps],
      stateAttributesMapping: stateAttributesMapping21,
      loop
    })
  });
});
if (true) ToggleGroup.displayName = "ToggleGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/index.parts.js
var index_parts_exports27 = {};
__export(index_parts_exports27, {
  Button: () => ToolbarButton,
  Group: () => ToolbarGroup,
  Input: () => ToolbarInput,
  Link: () => ToolbarLink,
  Root: () => ToolbarRoot,
  Separator: () => ToolbarSeparator
});

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/separator/ToolbarSeparator.js
var React169 = __toESM(require_react(), 1);
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var ToolbarSeparator = React169.forwardRef(function ToolbarSeparator2(props, forwardedRef) {
  const context = useToolbarRootContext();
  const orientation = {
    vertical: "horizontal",
    horizontal: "vertical"
  }[context.orientation];
  return (0, import_jsx_runtime61.jsx)(Separator, {
    orientation,
    ...props,
    ref: forwardedRef
  });
});
if (true) ToolbarSeparator.displayName = "ToolbarSeparator";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/root/ToolbarRoot.js
var React170 = __toESM(require_react(), 1);
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var ToolbarRoot = React170.forwardRef(function ToolbarRoot2(componentProps, forwardedRef) {
  const {
    cols = 1,
    disabled = false,
    loop = true,
    orientation = "horizontal",
    className,
    render,
    ...elementProps
  } = componentProps;
  const [itemMap, setItemMap] = React170.useState(() => /* @__PURE__ */ new Map());
  const disabledIndices = React170.useMemo(() => {
    const output = [];
    for (const itemMetadata of itemMap.values()) {
      if ((itemMetadata == null ? void 0 : itemMetadata.index) && !itemMetadata.focusableWhenDisabled) {
        output.push(itemMetadata.index);
      }
    }
    return output;
  }, [itemMap]);
  const toolbarRootContext = React170.useMemo(() => ({
    disabled,
    orientation,
    setItemMap
  }), [disabled, orientation, setItemMap]);
  const state = React170.useMemo(() => ({
    disabled,
    orientation
  }), [disabled, orientation]);
  const defaultProps = {
    "aria-orientation": orientation,
    role: "toolbar"
  };
  return (0, import_jsx_runtime62.jsx)(ToolbarRootContext.Provider, {
    value: toolbarRootContext,
    children: (0, import_jsx_runtime62.jsx)(CompositeRoot, {
      render,
      className,
      state,
      refs: [forwardedRef],
      props: [defaultProps, elementProps],
      cols,
      disabledIndices,
      loop,
      onMapChange: setItemMap,
      orientation
    })
  });
});
if (true) ToolbarRoot.displayName = "ToolbarRoot";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/group/ToolbarGroup.js
var React172 = __toESM(require_react(), 1);

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/group/ToolbarGroupContext.js
var React171 = __toESM(require_react(), 1);
var ToolbarGroupContext = React171.createContext(void 0);
if (true) ToolbarGroupContext.displayName = "ToolbarGroupContext";
function useToolbarGroupContext(optional) {
  const context = React171.useContext(ToolbarGroupContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: ToolbarGroupContext is missing. ToolbarGroup parts must be placed within <Toolbar.Group>.");
  }
  return context;
}

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/group/ToolbarGroup.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var ToolbarGroup = React172.forwardRef(function ToolbarGroup2(componentProps, forwardedRef) {
  const {
    className,
    disabled: disabledProp = false,
    render,
    ...elementProps
  } = componentProps;
  const {
    orientation,
    disabled: toolbarDisabled
  } = useToolbarRootContext();
  const disabled = toolbarDisabled || disabledProp;
  const contextValue = React172.useMemo(() => ({
    disabled
  }), [disabled]);
  const state = React172.useMemo(() => ({
    disabled,
    orientation
  }), [disabled, orientation]);
  const element = useRenderElement("div", componentProps, {
    state,
    ref: forwardedRef,
    props: [{
      role: "group"
    }, elementProps]
  });
  return (0, import_jsx_runtime63.jsx)(ToolbarGroupContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) ToolbarGroup.displayName = "ToolbarGroup";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/button/ToolbarButton.js
var React173 = __toESM(require_react(), 1);
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var ToolbarButton = React173.forwardRef(function ToolbarButton2(componentProps, forwardedRef) {
  const {
    className,
    disabled: disabledProp = false,
    focusableWhenDisabled = true,
    render,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const itemMetadata = React173.useMemo(() => ({
    focusableWhenDisabled
  }), [focusableWhenDisabled]);
  const {
    disabled: toolbarDisabled,
    orientation
  } = useToolbarRootContext();
  const groupContext = useToolbarGroupContext(true);
  const disabled = toolbarDisabled || ((groupContext == null ? void 0 : groupContext.disabled) ?? false) || disabledProp;
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled,
    native: nativeButton
  });
  const state = React173.useMemo(() => ({
    disabled,
    orientation,
    focusable: focusableWhenDisabled
  }), [disabled, focusableWhenDisabled, orientation]);
  return (0, import_jsx_runtime64.jsx)(CompositeItem, {
    tag: "button",
    render,
    className,
    metadata: itemMetadata,
    state,
    refs: [forwardedRef, buttonRef],
    props: [
      elementProps,
      // for integrating with Menu and Select disabled states, `disabled` is
      // intentionally duplicated even though getButtonProps includes it already
      // TODO: follow up after https://github.com/mui/base-ui/issues/1976#issuecomment-2916905663
      {
        disabled
      },
      getButtonProps
    ]
  });
});
if (true) ToolbarButton.displayName = "ToolbarButton";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/link/ToolbarLink.js
var React174 = __toESM(require_react(), 1);
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var TOOLBAR_LINK_METADATA = {
  // links cannot be disabled, this metadata is only used for deriving `disabledIndices``
  // TODO: better name
  focusableWhenDisabled: true
};
var ToolbarLink = React174.forwardRef(function ToolbarLink2(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    orientation
  } = useToolbarRootContext();
  const state = React174.useMemo(() => ({
    orientation
  }), [orientation]);
  return (0, import_jsx_runtime65.jsx)(CompositeItem, {
    tag: "a",
    render,
    className,
    metadata: TOOLBAR_LINK_METADATA,
    state,
    refs: [forwardedRef],
    props: [elementProps]
  });
});
if (true) ToolbarLink.displayName = "ToolbarLink";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/toolbar/input/ToolbarInput.js
var React175 = __toESM(require_react(), 1);
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var ToolbarInput = React175.forwardRef(function ToolbarInput2(componentProps, forwardedRef) {
  const {
    className,
    focusableWhenDisabled = true,
    render,
    disabled: disabledProp = false,
    ...elementProps
  } = componentProps;
  const itemMetadata = React175.useMemo(() => ({
    focusableWhenDisabled
  }), [focusableWhenDisabled]);
  const {
    disabled: toolbarDisabled,
    orientation
  } = useToolbarRootContext();
  const groupContext = useToolbarGroupContext(true);
  const disabled = toolbarDisabled || ((groupContext == null ? void 0 : groupContext.disabled) ?? false) || disabledProp;
  const {
    props: focusableWhenDisabledProps
  } = useFocusableWhenDisabled({
    composite: true,
    disabled,
    focusableWhenDisabled,
    isNativeButton: false
  });
  const state = React175.useMemo(() => ({
    disabled,
    orientation,
    focusable: focusableWhenDisabled
  }), [disabled, focusableWhenDisabled, orientation]);
  const defaultProps = {
    onClick(event) {
      if (disabled) {
        event.preventDefault();
      }
    },
    onKeyDown(event) {
      if (event.key !== ARROW_LEFT && event.key !== ARROW_RIGHT && disabled) {
        stopEvent(event);
      }
    },
    onPointerDown(event) {
      if (disabled) {
        event.preventDefault();
      }
    }
  };
  return (0, import_jsx_runtime66.jsx)(CompositeItem, {
    tag: "input",
    render,
    className,
    metadata: itemMetadata,
    state,
    refs: [forwardedRef],
    props: [defaultProps, elementProps, focusableWhenDisabledProps]
  });
});
if (true) ToolbarInput.displayName = "ToolbarInput";

// ../../CF/kumo/node_modules/.pnpm/@base-ui-components+react@1.0.0-beta.4_@types+react@18.3.26_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/@base-ui-components/react/esm/use-render/useRender.js
function useRender(params) {
  return useRenderElement(params.defaultTagName ?? "div", params, params);
}
export {
  index_parts_exports9 as Accordion,
  index_parts_exports10 as AlertDialog,
  index_parts_exports11 as Autocomplete,
  index_parts_exports12 as Avatar,
  index_parts_exports13 as Checkbox,
  CheckboxGroup,
  index_parts_exports14 as Collapsible,
  index_parts_exports15 as Combobox,
  index_parts_exports16 as ContextMenu,
  index_parts_exports17 as Dialog,
  DirectionProvider,
  index_parts_exports2 as Field,
  index_parts_exports18 as Fieldset,
  Form,
  Input,
  index_parts_exports as Menu,
  Menubar,
  index_parts_exports3 as Meter,
  index_parts_exports19 as NavigationMenu,
  index_parts_exports20 as NumberField,
  index_parts_exports21 as Popover,
  index_parts_exports22 as PreviewCard,
  index_parts_exports23 as Progress,
  index_parts_exports24 as Radio,
  RadioGroup,
  index_parts_exports25 as ScrollArea,
  index_parts_exports4 as Select,
  Separator,
  index_parts_exports26 as Slider,
  index_parts_exports5 as Switch,
  index_parts_exports6 as Tabs,
  index_parts_exports7 as Toast,
  Toggle,
  ToggleGroup,
  index_parts_exports27 as Toolbar,
  index_parts_exports8 as Tooltip,
  makeEventPreventable,
  mergeClassNames,
  mergeProps,
  mergePropsN,
  useRender
};
/*! Bundled license information:

@base-ui-components/react/esm/index.js:
  (**
   * @base-ui-components/react v1.0.0-beta.4
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@base-ui-components_react.js.map
